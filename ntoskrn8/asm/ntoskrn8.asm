; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	d:\develop\3drprojects\ntoskrnl_emu\ntoskrn8.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_1GC@CHBHJDHK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AAL@ ; `string'
PUBLIC	??_C@_1FK@EKMFPBHJ@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAP?$AAa?$AAr?$AAe?$AAn?$AAt?$AAP?$AAr?$AAo@ ; `string'
PUBLIC	??_C@_1FC@BKOLPFKH@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAC?$AAo?$AAn?$AAc?$AAu?$AAr@ ; `string'
PUBLIC	??_C@_1FI@PIDPGOCO@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAT?$AAo?$AAp?$AAL?$AAe?$AAv@ ; `string'
PUBLIC	??_C@_1DO@JDJIFCCN@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FI@NJOLKHLK@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAT?$AAo?$AAk?$AAe?$AAn?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?9?$AAA?$AAd?$AAd@ ; `string'
PUBLIC	??_C@_1EO@EHHFOMPM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAR?$AAe?$AAm?$AAa?$AAi?$AAn?$AAi@ ; `string'
PUBLIC	??_C@_1FA@JMIOGDJM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt@ ; `string'
PUBLIC	??_C@_1EA@KEBBLPOF@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAG?$AAe?$AAn?$AAu?$AAi?$AAn?$AAe?$AAL?$AAo?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EK@HPCPNDNC@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAA?$AAl?$AAl?$AAo?$AAw?$AAM?$AAu?$AAl?$AAt@ ; `string'
PUBLIC	??_C@_1DO@LCFKLHPB@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAV?$AAR?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@ILDNAGKK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAH?$AAR?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	_IoDisconnectInterruptEx_k8@4
PUBLIC	??_C@_1DA@HKIKEJFJ@?$AAI?$AAo?$AAD?$AAi?$AAs?$AAc?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@ ; `string'
PUBLIC	_IoConnectInterruptEx_k8@4
PUBLIC	??_C@_1CK@NMEBKIIE@?$AAI?$AAo?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@ ; `string'
PUBLIC	_DEVPKEY_NAME
PUBLIC	_DEVPKEY_Device_DeviceDesc
PUBLIC	_DEVPKEY_Device_HardwareIds
PUBLIC	_DEVPKEY_Device_CompatibleIds
PUBLIC	_DEVPKEY_Device_Service
PUBLIC	_DEVPKEY_Device_Class
PUBLIC	_DEVPKEY_Device_ClassGuid
PUBLIC	_DEVPKEY_Device_Driver
PUBLIC	_DEVPKEY_Device_ConfigFlags
PUBLIC	_DEVPKEY_Device_Manufacturer
PUBLIC	_DEVPKEY_Device_FriendlyName
PUBLIC	_DEVPKEY_Device_LocationInfo
PUBLIC	_DEVPKEY_Device_PDOName
PUBLIC	_DEVPKEY_Device_Capabilities
PUBLIC	_DEVPKEY_Device_UINumber
PUBLIC	_DEVPKEY_Device_UpperFilters
PUBLIC	_DEVPKEY_Device_LowerFilters
PUBLIC	_DEVPKEY_Device_BusTypeGuid
PUBLIC	_DEVPKEY_Device_LegacyBusType
PUBLIC	_DEVPKEY_Device_BusNumber
PUBLIC	_DEVPKEY_Device_EnumeratorName
PUBLIC	_DEVPKEY_Device_Security
PUBLIC	_DEVPKEY_Device_SecuritySDS
PUBLIC	_DEVPKEY_Device_DevType
PUBLIC	_DEVPKEY_Device_Exclusive
PUBLIC	_DEVPKEY_Device_Characteristics
PUBLIC	_DEVPKEY_Device_Address
PUBLIC	_DEVPKEY_Device_UINumberDescFormat
PUBLIC	_DEVPKEY_Device_PowerData
PUBLIC	_DEVPKEY_Device_RemovalPolicy
PUBLIC	_DEVPKEY_Device_RemovalPolicyDefault
PUBLIC	_DEVPKEY_Device_RemovalPolicyOverride
PUBLIC	_DEVPKEY_Device_InstallState
PUBLIC	_DEVPKEY_Device_LocationPaths
PUBLIC	_DEVPKEY_Device_BaseContainerId
PUBLIC	_DEVPKEY_Device_DevNodeStatus
PUBLIC	_DEVPKEY_Device_ProblemCode
PUBLIC	_DEVPKEY_Device_EjectionRelations
PUBLIC	_DEVPKEY_Device_RemovalRelations
PUBLIC	_DEVPKEY_Device_PowerRelations
PUBLIC	_DEVPKEY_Device_BusRelations
PUBLIC	_DEVPKEY_Device_Parent
PUBLIC	_DEVPKEY_Device_Children
PUBLIC	_DEVPKEY_Device_Siblings
PUBLIC	_DEVPKEY_Device_TransportRelations
PUBLIC	_DEVPKEY_Device_Reported
PUBLIC	_DEVPKEY_Device_Legacy
PUBLIC	_DEVPKEY_Device_InstanceId
PUBLIC	_DEVPKEY_Device_ContainerId
PUBLIC	_DEVPKEY_Device_ModelId
PUBLIC	_DEVPKEY_Device_FriendlyNameAttributes
PUBLIC	_DEVPKEY_Device_ManufacturerAttributes
PUBLIC	_DEVPKEY_Device_PresenceNotForDevice
PUBLIC	_DEVPKEY_Numa_Proximity_Domain
PUBLIC	_DEVPKEY_Device_DHP_Rebalance_Policy
PUBLIC	_DEVPKEY_Device_Numa_Node
PUBLIC	_DEVPKEY_Device_BusReportedDeviceDesc
PUBLIC	_DEVPKEY_Device_SessionId
PUBLIC	_DEVPKEY_Device_InstallDate
PUBLIC	_DEVPKEY_Device_FirstInstallDate
PUBLIC	_DEVPKEY_Device_DriverDate
PUBLIC	_DEVPKEY_Device_DriverVersion
PUBLIC	_DEVPKEY_Device_DriverDesc
PUBLIC	_DEVPKEY_Device_DriverInfPath
PUBLIC	_DEVPKEY_Device_DriverInfSection
PUBLIC	_DEVPKEY_Device_DriverInfSectionExt
PUBLIC	_DEVPKEY_Device_MatchingDeviceId
PUBLIC	_DEVPKEY_Device_DriverProvider
PUBLIC	_DEVPKEY_Device_DriverPropPageProvider
PUBLIC	_DEVPKEY_Device_DriverCoInstallers
PUBLIC	_DEVPKEY_Device_ResourcePickerTags
PUBLIC	_DEVPKEY_Device_ResourcePickerExceptions
PUBLIC	_DEVPKEY_Device_DriverRank
PUBLIC	_DEVPKEY_Device_DriverLogoLevel
PUBLIC	_DEVPKEY_Device_NoConnectSound
PUBLIC	_DEVPKEY_Device_GenericDriverInstalled
PUBLIC	_DEVPKEY_Device_AdditionalSoftwareRequested
PUBLIC	_DEVPKEY_Device_SafeRemovalRequired
PUBLIC	_DEVPKEY_Device_SafeRemovalRequiredOverride
PUBLIC	_DEVPKEY_DrvPkg_Model
PUBLIC	_DEVPKEY_DrvPkg_VendorWebSite
PUBLIC	_DEVPKEY_DrvPkg_DetailedDescription
PUBLIC	_DEVPKEY_DrvPkg_DocumentationLink
PUBLIC	_DEVPKEY_DrvPkg_Icon
PUBLIC	_DEVPKEY_DrvPkg_BrandingIcon
PUBLIC	_DEVPKEY_DeviceClass_UpperFilters
PUBLIC	_DEVPKEY_DeviceClass_LowerFilters
PUBLIC	_DEVPKEY_DeviceClass_Security
PUBLIC	_DEVPKEY_DeviceClass_SecuritySDS
PUBLIC	_DEVPKEY_DeviceClass_DevType
PUBLIC	_DEVPKEY_DeviceClass_Exclusive
PUBLIC	_DEVPKEY_DeviceClass_Characteristics
PUBLIC	_DEVPKEY_DeviceClass_Name
PUBLIC	_DEVPKEY_DeviceClass_ClassName
PUBLIC	_DEVPKEY_DeviceClass_Icon
PUBLIC	_DEVPKEY_DeviceClass_ClassInstaller
PUBLIC	_DEVPKEY_DeviceClass_PropPageProvider
PUBLIC	_DEVPKEY_DeviceClass_NoInstallClass
PUBLIC	_DEVPKEY_DeviceClass_NoDisplayClass
PUBLIC	_DEVPKEY_DeviceClass_SilentInstall
PUBLIC	_DEVPKEY_DeviceClass_NoUseClass
PUBLIC	_DEVPKEY_DeviceClass_DefaultService
PUBLIC	_DEVPKEY_DeviceClass_IconPath
PUBLIC	_DEVPKEY_DeviceClass_DHPRebalanceOptOut
PUBLIC	_DEVPKEY_DeviceClass_ClassCoInstallers
PUBLIC	_DEVPKEY_DeviceInterface_FriendlyName
PUBLIC	_DEVPKEY_DeviceInterface_Enabled
PUBLIC	_DEVPKEY_DeviceInterface_ClassGuid
PUBLIC	_DEVPKEY_DeviceInterfaceClass_DefaultInterface
PUBLIC	_DEVPKEY_DeviceDisplay_IsShowInDisconnectedState
PUBLIC	_DEVPKEY_DeviceDisplay_IsNotInterestingForDisplay
PUBLIC	_DEVPKEY_DeviceDisplay_Category
PUBLIC	_DEVPKEY_DeviceDisplay_UnpairUninstall
PUBLIC	_DEVPKEY_DeviceDisplay_RequiresUninstallElevation
PUBLIC	_DEVPKEY_DeviceDisplay_AlwaysShowDeviceAsConnected
PUBLIC	_DUMMYGUID
;	COMDAT ??_C@_1GC@CHBHJDHK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AAL@
CONST	SEGMENT
??_C@_1GC@CHBHJDHK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AAL@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, '-', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, '-', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, '-', 00H, 'I', 00H, 'n', 00H, 's', 00H, 't'
	DB	00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'L', 00H, 'i', 00H
	DB	'm', 00H, 'i', 00H, 't', 00H, 'E', 00H, 'x', 00H, 'e', 00H, 'm'
	DB	00H, 'p', 00H, 't', 00H, 'e', 00H, 'd', 00H, 'A', 00H, 'p', 00H
	DB	'p', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@EKMFPBHJ@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAP?$AAa?$AAr?$AAe?$AAn?$AAt?$AAP?$AAr?$AAo@
CONST	SEGMENT
??_C@_1FK@EKMFPBHJ@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAP?$AAa?$AAr?$AAe?$AAn?$AAt?$AAP?$AAr?$AAo@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, '-', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, '-', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, '-', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'n', 00H, 'y'
	DB	00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@BKOLPFKH@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAC?$AAo?$AAn?$AAc?$AAu?$AAr@
CONST	SEGMENT
??_C@_1FC@BKOLPFKH@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAC?$AAo?$AAn?$AAc?$AAu?$AAr@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, '-', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, '-', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, '-', 00H, 'M', 00H, 'a', 00H, 'x', 00H, 'C'
	DB	00H, 'o', 00H, 'n', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'r', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, 'I', 00H, 'A', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@PIDPGOCO@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAT?$AAo?$AAp?$AAL?$AAe?$AAv@
CONST	SEGMENT
??_C@_1FI@PIDPGOCO@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAT?$AAo?$AAp?$AAL?$AAe?$AAv@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, '-', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, '-', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, '-', 00H, 'M', 00H, 'a', 00H, 'x', 00H, 'T'
	DB	00H, 'o', 00H, 'p', 00H, 'L', 00H, 'e', 00H, 'v', 00H, 'e', 00H
	DB	'l', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'P', 00H, 'e', 00H, 'r'
	DB	00H, 'A', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@JDJIFCCN@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@JDJIFCCN@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, '-', 00H, 'S', 00H, 'P', 00H, 'P', 00H, '-', 00H, 'R'
	DB	00H, 'e', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H
	DB	'd', 00H, '-', 00H, 'T', 00H, 'B', 00H, 'L', 00H, 'S', 00H, 't'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@NJOLKHLK@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAT?$AAo?$AAk?$AAe?$AAn?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?9?$AAA?$AAd?$AAd@
CONST	SEGMENT
??_C@_1FI@NJOLKHLK@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAT?$AAo?$AAk?$AAe?$AAn?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?9?$AAA?$AAd?$AAd@ DB 'S'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, '-', 00H, 'S', 00H, 'P', 00H, 'P', 00H, '-', 00H, 'T'
	DB	00H, 'o', 00H, 'k', 00H, 'e', 00H, 'n', 00H, 'A', 00H, 'c', 00H
	DB	't', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, '-', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'i', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 'I'
	DB	00H, 'n', 00H, 'f', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EHHFOMPM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAR?$AAe?$AAm?$AAa?$AAi?$AAn?$AAi@
CONST	SEGMENT
??_C@_1EO@EHHFOMPM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAR?$AAe?$AAm?$AAa?$AAi?$AAn?$AAi@ DB 'S'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, '-', 00H, 'S', 00H, 'P', 00H, 'P', 00H, '-', 00H, 'R'
	DB	00H, 'e', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H
	DB	'd', 00H, '-', 00H, 'T', 00H, 'B', 00H, 'L', 00H, 'R', 00H, 'e'
	DB	00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@JMIOGDJM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt@
CONST	SEGMENT
??_C@_1FA@JMIOGDJM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt@ DB 'S'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, '-', 00H, 'S', 00H, 'P', 00H, 'P', 00H, '-', 00H, 'R'
	DB	00H, 'e', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H
	DB	'd', 00H, '-', 00H, 'T', 00H, 'B', 00H, 'L', 00H, 'P', 00H, 'r'
	DB	00H, 'o', 00H, 'd', 00H, 'u', 00H, 'c', 00H, 't', 00H, 'K', 00H
	DB	'e', 00H, 'y', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@KEBBLPOF@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAG?$AAe?$AAn?$AAu?$AAi?$AAn?$AAe?$AAL?$AAo?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@KEBBLPOF@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAG?$AAe?$AAn?$AAu?$AAi?$AAn?$AAe?$AAL?$AAo?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@ DB 'S'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, '-', 00H, 'S', 00H, 'P', 00H, 'P', 00H, '-', 00H, 'G'
	DB	00H, 'e', 00H, 'n', 00H, 'u', 00H, 'i', 00H, 'n', 00H, 'e', 00H
	DB	'L', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'S', 00H, 't'
	DB	00H, 'a', 00H, 't', 00H, 'u', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@HPCPNDNC@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAA?$AAl?$AAl?$AAo?$AAw?$AAM?$AAu?$AAl?$AAt@
CONST	SEGMENT
??_C@_1EK@HPCPNDNC@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAA?$AAl?$AAl?$AAo?$AAw?$AAM?$AAu?$AAl?$AAt@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, '-', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, '-', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, '-', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'w', 00H, 'M', 00H, 'u', 00H, 'l', 00H, 't', 00H, 'i', 00H
	DB	'M', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@LCFKLHPB@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAV?$AAR?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@LCFKLHPB@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAV?$AAR?$AAe?$AAs?$AA?$AA@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, '-', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, '-', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, '-', 00H, 'M', 00H, 'a', 00H, 'x', 00H, 'V'
	DB	00H, 'R', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@ILDNAGKK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAH?$AAR?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@ILDNAGKK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAH?$AAR?$AAe?$AAs?$AA?$AA@ DB 'M'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, '-', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, '-', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, '-', 00H, 'M', 00H, 'a', 00H, 'x', 00H, 'H'
	DB	00H, 'R', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@HKIKEJFJ@?$AAI?$AAo?$AAD?$AAi?$AAs?$AAc?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@HKIKEJFJ@?$AAI?$AAo?$AAD?$AAi?$AAs?$AAc?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@ DB 'I'
	DB	00H, 'o', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'I', 00H, 'n'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'u', 00H, 'p', 00H
	DB	't', 00H, 'E', 00H, 'x', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@NMEBKIIE@?$AAI?$AAo?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@NMEBKIIE@?$AAI?$AAo?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@ DB 'I'
	DB	00H, 'o', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 'r', 00H, 'u', 00H, 'p', 00H, 't', 00H, 'E', 00H, 'x', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT _DUMMYGUID
CONST	SEGMENT
_DUMMYGUID DD	0deadbeefH
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
CONST	SEGMENT
_CRC_table DD	00H
	DD	077073096H
	DD	0ee0e612cH
	DD	0990951baH
	DD	076dc419H
	DD	0706af48fH
	DD	0e963a535H
	DD	09e6495a3H
	DD	0edb8832H
	DD	079dcb8a4H
	DD	0e0d5e91eH
	DD	097d2d988H
	DD	09b64c2bH
	DD	07eb17cbdH
	DD	0e7b82d07H
	DD	090bf1d91H
	DD	01db71064H
	DD	06ab020f2H
	DD	0f3b97148H
	DD	084be41deH
	DD	01adad47dH
	DD	06ddde4ebH
	DD	0f4d4b551H
	DD	083d385c7H
	DD	0136c9856H
	DD	0646ba8c0H
	DD	0fd62f97aH
	DD	08a65c9ecH
	DD	014015c4fH
	DD	063066cd9H
	DD	0fa0f3d63H
	DD	08d080df5H
	DD	03b6e20c8H
	DD	04c69105eH
	DD	0d56041e4H
	DD	0a2677172H
	DD	03c03e4d1H
	DD	04b04d447H
	DD	0d20d85fdH
	DD	0a50ab56bH
	DD	035b5a8faH
	DD	042b2986cH
	DD	0dbbbc9d6H
	DD	0acbcf940H
	DD	032d86ce3H
	DD	045df5c75H
	DD	0dcd60dcfH
	DD	0abd13d59H
	DD	026d930acH
	DD	051de003aH
	DD	0c8d75180H
	DD	0bfd06116H
	DD	021b4f4b5H
	DD	056b3c423H
	DD	0cfba9599H
	DD	0b8bda50fH
	DD	02802b89eH
	DD	05f058808H
	DD	0c60cd9b2H
	DD	0b10be924H
	DD	02f6f7c87H
	DD	058684c11H
	DD	0c1611dabH
	DD	0b6662d3dH
	DD	076dc4190H
	DD	01db7106H
	DD	098d220bcH
	DD	0efd5102aH
	DD	071b18589H
	DD	06b6b51fH
	DD	09fbfe4a5H
	DD	0e8b8d433H
	DD	07807c9a2H
	DD	0f00f934H
	DD	09609a88eH
	DD	0e10e9818H
	DD	07f6a0dbbH
	DD	086d3d2dH
	DD	091646c97H
	DD	0e6635c01H
	DD	06b6b51f4H
	DD	01c6c6162H
	DD	0856530d8H
	DD	0f262004eH
	DD	06c0695edH
	DD	01b01a57bH
	DD	08208f4c1H
	DD	0f50fc457H
	DD	065b0d9c6H
	DD	012b7e950H
	DD	08bbeb8eaH
	DD	0fcb9887cH
	DD	062dd1ddfH
	DD	015da2d49H
	DD	08cd37cf3H
	DD	0fbd44c65H
	DD	04db26158H
	DD	03ab551ceH
	DD	0a3bc0074H
	DD	0d4bb30e2H
	DD	04adfa541H
	DD	03dd895d7H
	DD	0a4d1c46dH
	DD	0d3d6f4fbH
	DD	04369e96aH
	DD	0346ed9fcH
	DD	0ad678846H
	DD	0da60b8d0H
	DD	044042d73H
	DD	033031de5H
	DD	0aa0a4c5fH
	DD	0dd0d7cc9H
	DD	05005713cH
	DD	0270241aaH
	DD	0be0b1010H
	DD	0c90c2086H
	DD	05768b525H
	DD	0206f85b3H
	DD	0b966d409H
	DD	0ce61e49fH
	DD	05edef90eH
	DD	029d9c998H
	DD	0b0d09822H
	DD	0c7d7a8b4H
	DD	059b33d17H
	DD	02eb40d81H
	DD	0b7bd5c3bH
	DD	0c0ba6cadH
	DD	0edb88320H
	DD	09abfb3b6H
	DD	03b6e20cH
	DD	074b1d29aH
	DD	0ead54739H
	DD	09dd277afH
	DD	04db2615H
	DD	073dc1683H
	DD	0e3630b12H
	DD	094643b84H
	DD	0d6d6a3eH
	DD	07a6a5aa8H
	DD	0e40ecf0bH
	DD	09309ff9dH
	DD	0a00ae27H
	DD	07d079eb1H
	DD	0f00f9344H
	DD	08708a3d2H
	DD	01e01f268H
	DD	06906c2feH
	DD	0f762575dH
	DD	0806567cbH
	DD	0196c3671H
	DD	06e6b06e7H
	DD	0fed41b76H
	DD	089d32be0H
	DD	010da7a5aH
	DD	067dd4accH
	DD	0f9b9df6fH
	DD	08ebeeff9H
	DD	017b7be43H
	DD	060b08ed5H
	DD	0d6d6a3e8H
	DD	0a1d1937eH
	DD	038d8c2c4H
	DD	04fdff252H
	DD	0d1bb67f1H
	DD	0a6bc5767H
	DD	03fb506ddH
	DD	048b2364bH
	DD	0d80d2bdaH
	DD	0af0a1b4cH
	DD	036034af6H
	DD	041047a60H
	DD	0df60efc3H
	DD	0a867df55H
	DD	0316e8eefH
	DD	04669be79H
	DD	0cb61b38cH
	DD	0bc66831aH
	DD	0256fd2a0H
	DD	05268e236H
	DD	0cc0c7795H
	DD	0bb0b4703H
	DD	0220216b9H
	DD	05505262fH
	DD	0c5ba3bbeH
	DD	0b2bd0b28H
	DD	02bb45a92H
	DD	05cb36a04H
	DD	0c2d7ffa7H
	DD	0b5d0cf31H
	DD	02cd99e8bH
	DD	05bdeae1dH
	DD	09b64c2b0H
	DD	0ec63f226H
	DD	0756aa39cH
	DD	026d930aH
	DD	09c0906a9H
	DD	0eb0e363fH
	DD	072076785H
	DD	05005713H
	DD	095bf4a82H
	DD	0e2b87a14H
	DD	07bb12baeH
	DD	0cb61b38H
	DD	092d28e9bH
	DD	0e5d5be0dH
	DD	07cdcefb7H
	DD	0bdbdf21H
	DD	086d3d2d4H
	DD	0f1d4e242H
	DD	068ddb3f8H
	DD	01fda836eH
	DD	081be16cdH
	DD	0f6b9265bH
	DD	06fb077e1H
	DD	018b74777H
	DD	088085ae6H
	DD	0ff0f6a70H
	DD	066063bcaH
	DD	011010b5cH
	DD	08f659effH
	DD	0f862ae69H
	DD	0616bffd3H
	DD	0166ccf45H
	DD	0a00ae278H
	DD	0d70dd2eeH
	DD	04e048354H
	DD	03903b3c2H
	DD	0a7672661H
	DD	0d06016f7H
	DD	04969474dH
	DD	03e6e77dbH
	DD	0aed16a4aH
	DD	0d9d65adcH
	DD	040df0b66H
	DD	037d83bf0H
	DD	0a9bcae53H
	DD	0debb9ec5H
	DD	047b2cf7fH
	DD	030b5ffe9H
	DD	0bdbdf21cH
	DD	0cabac28aH
	DD	053b39330H
	DD	024b4a3a6H
	DD	0bad03605H
	DD	0cdd70693H
	DD	054de5729H
	DD	023d967bfH
	DD	0b3667a2eH
	DD	0c4614ab8H
	DD	05d681b02H
	DD	02a6f2b94H
	DD	0b40bbe37H
	DD	0c30c8ea1H
	DD	05a05df1bH
	DD	02d02ef8dH
_RoutineAddressEnabled DW 028H
	DW	02aH
	DD	FLAT:??_C@_1CK@NMEBKIIE@?$AAI?$AAo?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@
	DD	FLAT:_IoConnectInterruptEx_k8@4
	DW	02eH
	DW	030H
	DD	FLAT:??_C@_1DA@HKIKEJFJ@?$AAI?$AAo?$AAD?$AAi?$AAs?$AAc?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAI?$AAn?$AAt?$AAe?$AAr?$AAr?$AAu?$AAp?$AAt?$AAE?$AAx?$AA?$AA@
	DD	FLAT:_IoDisconnectInterruptEx_k8@4
_LicenseValueArray DW 03cH
	DW	03eH
	DD	FLAT:??_C@_1DO@ILDNAGKK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAH?$AAR?$AAe?$AAs?$AA?$AA@
	DD	04H
	DD	04H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+12
	DW	03cH
	DW	03eH
	DD	FLAT:??_C@_1DO@LCFKLHPB@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAV?$AAR?$AAe?$AAs?$AA?$AA@
	DD	04H
	DD	04H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+12
	DW	048H
	DW	04aH
	DD	FLAT:??_C@_1EK@HPCPNDNC@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAA?$AAl?$AAl?$AAo?$AAw?$AAM?$AAu?$AAl?$AAt@
	DD	04H
	DD	04H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	ORG $+12
	DW	03eH
	DW	040H
	DD	FLAT:??_C@_1EA@KEBBLPOF@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAG?$AAe?$AAn?$AAu?$AAi?$AAn?$AAe?$AAL?$AAo?$AAc?$AAa?$AAl?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AA?$AA@
	DD	04H
	DD	04H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	ORG $+12
	DW	04eH
	DW	050H
	DD	FLAT:??_C@_1FA@JMIOGDJM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAP?$AAr?$AAo?$AAd?$AAu?$AAc?$AAt@
	DD	04H
	DD	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+12
	DW	04cH
	DW	04eH
	DD	FLAT:??_C@_1EO@EHHFOMPM@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAR?$AAe?$AAm?$AAa?$AAi?$AAn?$AAi@
	DD	04H
	DD	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+12
	DW	056H
	DW	058H
	DD	FLAT:??_C@_1FI@NJOLKHLK@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAT?$AAo?$AAk?$AAe?$AAn?$AAA?$AAc?$AAt?$AAi?$AAv?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?9?$AAA?$AAd?$AAd@
	DD	01H
	DD	00H
	DB	00H
	ORG $+15
	DW	03cH
	DW	03eH
	DD	FLAT:??_C@_1DO@JDJIFCCN@?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt?$AAy?$AA?9?$AAS?$AAP?$AAP?$AA?9?$AAR?$AAe?$AAs?$AAe?$AAr?$AAv?$AAe?$AAd?$AA?9?$AAT?$AAB?$AAL?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?$AA@
	DD	04H
	DD	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+12
	DW	056H
	DW	058H
	DD	FLAT:??_C@_1FI@PIDPGOCO@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAT?$AAo?$AAp?$AAL?$AAe?$AAv@
	DD	04H
	DD	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+12
	DW	050H
	DW	052H
	DD	FLAT:??_C@_1FC@BKOLPFKH@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAM?$AAa?$AAx?$AAC?$AAo?$AAn?$AAc?$AAu?$AAr@
	DD	04H
	DD	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+12
	DW	058H
	DW	05aH
	DD	FLAT:??_C@_1FK@EKMFPBHJ@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAP?$AAa?$AAr?$AAe?$AAn?$AAt?$AAP?$AAr?$AAo@
	DD	01H
	DD	00H
	DB	00H
	ORG $+15
	DW	060H
	DW	062H
	DD	FLAT:??_C@_1GC@CHBHJDHK@?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?9?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs?$AA?9?$AAC?$AAo?$AAr?$AAe?$AA?9?$AAI?$AAn?$AAs?$AAt?$AAa?$AAn?$AAc?$AAe?$AAL@
	DD	01H
	DD	00H
	DB	00H
	ORG $+15
_high_level DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DD	03000H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceDisplay_AlwaysShowDeviceAsConnected
CONST	SEGMENT
_DEVPKEY_DeviceDisplay_AlwaysShowDeviceAsConnected DD 078c34fc8H
	DW	0104aH
	DW	04acaH
	DB	09eH
	DB	0a4H
	DB	052H
	DB	04dH
	DB	052H
	DB	099H
	DB	06eH
	DB	057H
	DD	065H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceDisplay_RequiresUninstallElevation
CONST	SEGMENT
_DEVPKEY_DeviceDisplay_RequiresUninstallElevation DD 078c34fc8H
	DW	0104aH
	DW	04acaH
	DB	09eH
	DB	0a4H
	DB	052H
	DB	04dH
	DB	052H
	DB	099H
	DB	06eH
	DB	057H
	DD	063H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceDisplay_UnpairUninstall
CONST	SEGMENT
_DEVPKEY_DeviceDisplay_UnpairUninstall DD 078c34fc8H
	DW	0104aH
	DW	04acaH
	DB	09eH
	DB	0a4H
	DB	052H
	DB	04dH
	DB	052H
	DB	099H
	DB	06eH
	DB	057H
	DD	062H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceDisplay_Category
CONST	SEGMENT
_DEVPKEY_DeviceDisplay_Category DD 078c34fc8H
	DW	0104aH
	DW	04acaH
	DB	09eH
	DB	0a4H
	DB	052H
	DB	04dH
	DB	052H
	DB	099H
	DB	06eH
	DB	057H
	DD	05aH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceDisplay_IsNotInterestingForDisplay
CONST	SEGMENT
_DEVPKEY_DeviceDisplay_IsNotInterestingForDisplay DD 078c34fc8H
	DW	0104aH
	DW	04acaH
	DB	09eH
	DB	0a4H
	DB	052H
	DB	04dH
	DB	052H
	DB	099H
	DB	06eH
	DB	057H
	DD	04aH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceDisplay_IsShowInDisconnectedState
CONST	SEGMENT
_DEVPKEY_DeviceDisplay_IsShowInDisconnectedState DD 078c34fc8H
	DW	0104aH
	DW	04acaH
	DB	09eH
	DB	0a4H
	DB	052H
	DB	04dH
	DB	052H
	DB	099H
	DB	06eH
	DB	057H
	DD	044H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceInterfaceClass_DefaultInterface
CONST	SEGMENT
_DEVPKEY_DeviceInterfaceClass_DefaultInterface DD 014c83a99H
	DW	0b3fH
	DW	044b7H
	DB	0beH
	DB	04cH
	DB	0a1H
	DB	078H
	DB	0d3H
	DB	099H
	DB	05H
	DB	064H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceInterface_ClassGuid
CONST	SEGMENT
_DEVPKEY_DeviceInterface_ClassGuid DD 026e516eH
	DW	0b814H
	DW	0414bH
	DB	083H
	DB	0cdH
	DB	085H
	DB	06dH
	DB	06fH
	DB	0efH
	DB	048H
	DB	022H
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceInterface_Enabled
CONST	SEGMENT
_DEVPKEY_DeviceInterface_Enabled DD 026e516eH
	DW	0b814H
	DW	0414bH
	DB	083H
	DB	0cdH
	DB	085H
	DB	06dH
	DB	06fH
	DB	0efH
	DB	048H
	DB	022H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceInterface_FriendlyName
CONST	SEGMENT
_DEVPKEY_DeviceInterface_FriendlyName DD 026e516eH
	DW	0b814H
	DW	0414bH
	DB	083H
	DB	0cdH
	DB	085H
	DB	06dH
	DB	06fH
	DB	0efH
	DB	048H
	DB	022H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_ClassCoInstallers
CONST	SEGMENT
_DEVPKEY_DeviceClass_ClassCoInstallers DD 0713d1703H
	DW	0a2e2H
	DW	049f5H
	DB	092H
	DB	014H
	DB	056H
	DB	047H
	DB	02eH
	DB	0f3H
	DB	0daH
	DB	05cH
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_DHPRebalanceOptOut
CONST	SEGMENT
_DEVPKEY_DeviceClass_DHPRebalanceOptOut DD 0d14d3ef3H
	DW	066cfH
	DW	04ba2H
	DB	09dH
	DB	038H
	DB	0dH
	DB	0dbH
	DB	037H
	DB	0abH
	DB	047H
	DB	01H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_IconPath
CONST	SEGMENT
_DEVPKEY_DeviceClass_IconPath DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	0cH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_DefaultService
CONST	SEGMENT
_DEVPKEY_DeviceClass_DefaultService DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	0bH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_NoUseClass
CONST	SEGMENT
_DEVPKEY_DeviceClass_NoUseClass DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	0aH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_SilentInstall
CONST	SEGMENT
_DEVPKEY_DeviceClass_SilentInstall DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	09H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_NoDisplayClass
CONST	SEGMENT
_DEVPKEY_DeviceClass_NoDisplayClass DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	08H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_NoInstallClass
CONST	SEGMENT
_DEVPKEY_DeviceClass_NoInstallClass DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	07H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_PropPageProvider
CONST	SEGMENT
_DEVPKEY_DeviceClass_PropPageProvider DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	06H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_ClassInstaller
CONST	SEGMENT
_DEVPKEY_DeviceClass_ClassInstaller DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	05H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_Icon
CONST	SEGMENT
_DEVPKEY_DeviceClass_Icon DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_ClassName
CONST	SEGMENT
_DEVPKEY_DeviceClass_ClassName DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_Name
CONST	SEGMENT
_DEVPKEY_DeviceClass_Name DD 0259abffcH
	DW	050a7H
	DW	047ceH
	DB	0afH
	DB	08H
	DB	068H
	DB	0c9H
	DB	0a7H
	DB	0d7H
	DB	033H
	DB	066H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_Characteristics
CONST	SEGMENT
_DEVPKEY_DeviceClass_Characteristics DD 04321918bH
	DW	0f69eH
	DW	0470dH
	DB	0a5H
	DB	0deH
	DB	04dH
	DB	088H
	DB	0c7H
	DB	05aH
	DB	0d2H
	DB	04bH
	DD	01dH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_Exclusive
CONST	SEGMENT
_DEVPKEY_DeviceClass_Exclusive DD 04321918bH
	DW	0f69eH
	DW	0470dH
	DB	0a5H
	DB	0deH
	DB	04dH
	DB	088H
	DB	0c7H
	DB	05aH
	DB	0d2H
	DB	04bH
	DD	01cH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_DevType
CONST	SEGMENT
_DEVPKEY_DeviceClass_DevType DD 04321918bH
	DW	0f69eH
	DW	0470dH
	DB	0a5H
	DB	0deH
	DB	04dH
	DB	088H
	DB	0c7H
	DB	05aH
	DB	0d2H
	DB	04bH
	DD	01bH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_SecuritySDS
CONST	SEGMENT
_DEVPKEY_DeviceClass_SecuritySDS DD 04321918bH
	DW	0f69eH
	DW	0470dH
	DB	0a5H
	DB	0deH
	DB	04dH
	DB	088H
	DB	0c7H
	DB	05aH
	DB	0d2H
	DB	04bH
	DD	01aH
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_Security
CONST	SEGMENT
_DEVPKEY_DeviceClass_Security DD 04321918bH
	DW	0f69eH
	DW	0470dH
	DB	0a5H
	DB	0deH
	DB	04dH
	DB	088H
	DB	0c7H
	DB	05aH
	DB	0d2H
	DB	04bH
	DD	019H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_LowerFilters
CONST	SEGMENT
_DEVPKEY_DeviceClass_LowerFilters DD 04321918bH
	DW	0f69eH
	DW	0470dH
	DB	0a5H
	DB	0deH
	DB	04dH
	DB	088H
	DB	0c7H
	DB	05aH
	DB	0d2H
	DB	04bH
	DD	014H
CONST	ENDS
;	COMDAT _DEVPKEY_DeviceClass_UpperFilters
CONST	SEGMENT
_DEVPKEY_DeviceClass_UpperFilters DD 04321918bH
	DW	0f69eH
	DW	0470dH
	DB	0a5H
	DB	0deH
	DB	04dH
	DB	088H
	DB	0c7H
	DB	05aH
	DB	0d2H
	DB	04bH
	DD	013H
CONST	ENDS
;	COMDAT _DEVPKEY_DrvPkg_BrandingIcon
CONST	SEGMENT
_DEVPKEY_DrvPkg_BrandingIcon DD 0cf73bb51H
	DW	03abfH
	DW	044a2H
	DB	085H
	DB	0e0H
	DB	09aH
	DB	03dH
	DB	0c7H
	DB	0a1H
	DB	021H
	DB	032H
	DD	07H
CONST	ENDS
;	COMDAT _DEVPKEY_DrvPkg_Icon
CONST	SEGMENT
_DEVPKEY_DrvPkg_Icon DD 0cf73bb51H
	DW	03abfH
	DW	044a2H
	DB	085H
	DB	0e0H
	DB	09aH
	DB	03dH
	DB	0c7H
	DB	0a1H
	DB	021H
	DB	032H
	DD	06H
CONST	ENDS
;	COMDAT _DEVPKEY_DrvPkg_DocumentationLink
CONST	SEGMENT
_DEVPKEY_DrvPkg_DocumentationLink DD 0cf73bb51H
	DW	03abfH
	DW	044a2H
	DB	085H
	DB	0e0H
	DB	09aH
	DB	03dH
	DB	0c7H
	DB	0a1H
	DB	021H
	DB	032H
	DD	05H
CONST	ENDS
;	COMDAT _DEVPKEY_DrvPkg_DetailedDescription
CONST	SEGMENT
_DEVPKEY_DrvPkg_DetailedDescription DD 0cf73bb51H
	DW	03abfH
	DW	044a2H
	DB	085H
	DB	0e0H
	DB	09aH
	DB	03dH
	DB	0c7H
	DB	0a1H
	DB	021H
	DB	032H
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_DrvPkg_VendorWebSite
CONST	SEGMENT
_DEVPKEY_DrvPkg_VendorWebSite DD 0cf73bb51H
	DW	03abfH
	DW	044a2H
	DB	085H
	DB	0e0H
	DB	09aH
	DB	03dH
	DB	0c7H
	DB	0a1H
	DB	021H
	DB	032H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_DrvPkg_Model
CONST	SEGMENT
_DEVPKEY_DrvPkg_Model DD 0cf73bb51H
	DW	03abfH
	DW	044a2H
	DB	085H
	DB	0e0H
	DB	09aH
	DB	03dH
	DB	0c7H
	DB	0a1H
	DB	021H
	DB	032H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_SafeRemovalRequiredOverride
CONST	SEGMENT
_DEVPKEY_Device_SafeRemovalRequiredOverride DD 0afd97640H
	DW	086a3H
	DW	04210H
	DB	0b6H
	DB	07cH
	DB	028H
	DB	09cH
	DB	041H
	DB	0aaH
	DB	0beH
	DB	055H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_SafeRemovalRequired
CONST	SEGMENT
_DEVPKEY_Device_SafeRemovalRequired DD 0afd97640H
	DW	086a3H
	DW	04210H
	DB	0b6H
	DB	07cH
	DB	028H
	DB	09cH
	DB	041H
	DB	0aaH
	DB	0beH
	DB	055H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_AdditionalSoftwareRequested
CONST	SEGMENT
_DEVPKEY_Device_AdditionalSoftwareRequested DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	013H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_GenericDriverInstalled
CONST	SEGMENT
_DEVPKEY_Device_GenericDriverInstalled DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	012H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_NoConnectSound
CONST	SEGMENT
_DEVPKEY_Device_NoConnectSound DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	011H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverLogoLevel
CONST	SEGMENT
_DEVPKEY_Device_DriverLogoLevel DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	0fH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverRank
CONST	SEGMENT
_DEVPKEY_Device_DriverRank DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	0eH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ResourcePickerExceptions
CONST	SEGMENT
_DEVPKEY_Device_ResourcePickerExceptions DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	0dH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ResourcePickerTags
CONST	SEGMENT
_DEVPKEY_Device_ResourcePickerTags DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	0cH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverCoInstallers
CONST	SEGMENT
_DEVPKEY_Device_DriverCoInstallers DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	0bH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverPropPageProvider
CONST	SEGMENT
_DEVPKEY_Device_DriverPropPageProvider DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	0aH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverProvider
CONST	SEGMENT
_DEVPKEY_Device_DriverProvider DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	09H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_MatchingDeviceId
CONST	SEGMENT
_DEVPKEY_Device_MatchingDeviceId DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	08H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverInfSectionExt
CONST	SEGMENT
_DEVPKEY_Device_DriverInfSectionExt DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	07H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverInfSection
CONST	SEGMENT
_DEVPKEY_Device_DriverInfSection DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	06H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverInfPath
CONST	SEGMENT
_DEVPKEY_Device_DriverInfPath DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	05H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverDesc
CONST	SEGMENT
_DEVPKEY_Device_DriverDesc DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverVersion
CONST	SEGMENT
_DEVPKEY_Device_DriverVersion DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DriverDate
CONST	SEGMENT
_DEVPKEY_Device_DriverDate DD 0a8b865ddH
	DW	02e3dH
	DW	04094H
	DB	0adH
	DB	097H
	DB	0e5H
	DB	093H
	DB	0a7H
	DB	0cH
	DB	075H
	DB	0d6H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_FirstInstallDate
CONST	SEGMENT
_DEVPKEY_Device_FirstInstallDate DD 083da6326H
	DW	097a6H
	DW	04088H
	DB	094H
	DB	053H
	DB	0a1H
	DB	092H
	DB	03fH
	DB	057H
	DB	03bH
	DB	029H
	DD	065H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_InstallDate
CONST	SEGMENT
_DEVPKEY_Device_InstallDate DD 083da6326H
	DW	097a6H
	DW	04088H
	DB	094H
	DB	053H
	DB	0a1H
	DB	092H
	DB	03fH
	DB	057H
	DB	03bH
	DB	029H
	DD	064H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_SessionId
CONST	SEGMENT
_DEVPKEY_Device_SessionId DD 083da6326H
	DW	097a6H
	DW	04088H
	DB	094H
	DB	053H
	DB	0a1H
	DB	092H
	DB	03fH
	DB	057H
	DB	03bH
	DB	029H
	DD	06H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_BusReportedDeviceDesc
CONST	SEGMENT
_DEVPKEY_Device_BusReportedDeviceDesc DD 0540b947eH
	DW	08b40H
	DW	045bcH
	DB	0a8H
	DB	0a2H
	DB	06aH
	DB	0bH
	DB	089H
	DB	04cH
	DB	0bdH
	DB	0a2H
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Numa_Node
CONST	SEGMENT
_DEVPKEY_Device_Numa_Node DD 0540b947eH
	DW	08b40H
	DW	045bcH
	DB	0a8H
	DB	0a2H
	DB	06aH
	DB	0bH
	DB	089H
	DB	04cH
	DB	0bdH
	DB	0a2H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DHP_Rebalance_Policy
CONST	SEGMENT
_DEVPKEY_Device_DHP_Rebalance_Policy DD 0540b947eH
	DW	08b40H
	DW	045bcH
	DB	0a8H
	DB	0a2H
	DB	06aH
	DB	0bH
	DB	089H
	DB	04cH
	DB	0bdH
	DB	0a2H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Numa_Proximity_Domain
CONST	SEGMENT
_DEVPKEY_Numa_Proximity_Domain DD 0540b947eH
	DW	08b40H
	DW	045bcH
	DB	0a8H
	DB	0a2H
	DB	06aH
	DB	0bH
	DB	089H
	DB	04cH
	DB	0bdH
	DB	0a2H
	DD	01H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_PresenceNotForDevice
CONST	SEGMENT
_DEVPKEY_Device_PresenceNotForDevice DD 080d81ea6H
	DW	07473H
	DW	04b0cH
	DB	082H
	DB	016H
	DB	0efH
	DB	0c1H
	DB	01aH
	DB	02cH
	DB	04cH
	DB	08bH
	DD	05H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ManufacturerAttributes
CONST	SEGMENT
_DEVPKEY_Device_ManufacturerAttributes DD 080d81ea6H
	DW	07473H
	DW	04b0cH
	DB	082H
	DB	016H
	DB	0efH
	DB	0c1H
	DB	01aH
	DB	02cH
	DB	04cH
	DB	08bH
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_FriendlyNameAttributes
CONST	SEGMENT
_DEVPKEY_Device_FriendlyNameAttributes DD 080d81ea6H
	DW	07473H
	DW	04b0cH
	DB	082H
	DB	016H
	DB	0efH
	DB	0c1H
	DB	01aH
	DB	02cH
	DB	04cH
	DB	08bH
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ModelId
CONST	SEGMENT
_DEVPKEY_Device_ModelId DD 080d81ea6H
	DW	07473H
	DW	04b0cH
	DB	082H
	DB	016H
	DB	0efH
	DB	0c1H
	DB	01aH
	DB	02cH
	DB	04cH
	DB	08bH
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ContainerId
CONST	SEGMENT
_DEVPKEY_Device_ContainerId DD 08c7ed206H
	DW	03f8aH
	DW	04827H
	DB	0b3H
	DB	0abH
	DB	0aeH
	DB	09eH
	DB	01fH
	DB	0aeH
	DB	0fcH
	DB	06cH
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_InstanceId
CONST	SEGMENT
_DEVPKEY_Device_InstanceId DD 078c34fc8H
	DW	0104aH
	DW	04acaH
	DB	09eH
	DB	0a4H
	DB	052H
	DB	04dH
	DB	052H
	DB	099H
	DB	06eH
	DB	057H
	DD	0100H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Legacy
CONST	SEGMENT
_DEVPKEY_Device_Legacy DD 080497100H
	DW	08c73H
	DW	048b9H
	DB	0aaH
	DB	0d9H
	DB	0ceH
	DB	038H
	DB	07eH
	DB	019H
	DB	0c5H
	DB	06eH
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Reported
CONST	SEGMENT
_DEVPKEY_Device_Reported DD 080497100H
	DW	08c73H
	DW	048b9H
	DB	0aaH
	DB	0d9H
	DB	0ceH
	DB	038H
	DB	07eH
	DB	019H
	DB	0c5H
	DB	06eH
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_TransportRelations
CONST	SEGMENT
_DEVPKEY_Device_TransportRelations DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	0bH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Siblings
CONST	SEGMENT
_DEVPKEY_Device_Siblings DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	0aH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Children
CONST	SEGMENT
_DEVPKEY_Device_Children DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	09H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Parent
CONST	SEGMENT
_DEVPKEY_Device_Parent DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	08H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_BusRelations
CONST	SEGMENT
_DEVPKEY_Device_BusRelations DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	07H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_PowerRelations
CONST	SEGMENT
_DEVPKEY_Device_PowerRelations DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	06H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_RemovalRelations
CONST	SEGMENT
_DEVPKEY_Device_RemovalRelations DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	05H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_EjectionRelations
CONST	SEGMENT
_DEVPKEY_Device_EjectionRelations DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ProblemCode
CONST	SEGMENT
_DEVPKEY_Device_ProblemCode DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DevNodeStatus
CONST	SEGMENT
_DEVPKEY_Device_DevNodeStatus DD 04340a6c5H
	DW	093faH
	DW	04706H
	DB	097H
	DB	02cH
	DB	07bH
	DB	064H
	DB	080H
	DB	08H
	DB	0a5H
	DB	0a7H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_BaseContainerId
CONST	SEGMENT
_DEVPKEY_Device_BaseContainerId DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	026H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_LocationPaths
CONST	SEGMENT
_DEVPKEY_Device_LocationPaths DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	025H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_InstallState
CONST	SEGMENT
_DEVPKEY_Device_InstallState DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	024H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_RemovalPolicyOverride
CONST	SEGMENT
_DEVPKEY_Device_RemovalPolicyOverride DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	023H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_RemovalPolicyDefault
CONST	SEGMENT
_DEVPKEY_Device_RemovalPolicyDefault DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	022H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_RemovalPolicy
CONST	SEGMENT
_DEVPKEY_Device_RemovalPolicy DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	021H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_PowerData
CONST	SEGMENT
_DEVPKEY_Device_PowerData DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	020H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_UINumberDescFormat
CONST	SEGMENT
_DEVPKEY_Device_UINumberDescFormat DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	01fH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Address
CONST	SEGMENT
_DEVPKEY_Device_Address DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	01eH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Characteristics
CONST	SEGMENT
_DEVPKEY_Device_Characteristics DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	01dH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Exclusive
CONST	SEGMENT
_DEVPKEY_Device_Exclusive DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	01cH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DevType
CONST	SEGMENT
_DEVPKEY_Device_DevType DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	01bH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_SecuritySDS
CONST	SEGMENT
_DEVPKEY_Device_SecuritySDS DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	01aH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Security
CONST	SEGMENT
_DEVPKEY_Device_Security DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	019H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_EnumeratorName
CONST	SEGMENT
_DEVPKEY_Device_EnumeratorName DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	018H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_BusNumber
CONST	SEGMENT
_DEVPKEY_Device_BusNumber DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	017H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_LegacyBusType
CONST	SEGMENT
_DEVPKEY_Device_LegacyBusType DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	016H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_BusTypeGuid
CONST	SEGMENT
_DEVPKEY_Device_BusTypeGuid DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	015H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_LowerFilters
CONST	SEGMENT
_DEVPKEY_Device_LowerFilters DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	014H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_UpperFilters
CONST	SEGMENT
_DEVPKEY_Device_UpperFilters DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	013H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_UINumber
CONST	SEGMENT
_DEVPKEY_Device_UINumber DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	012H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Capabilities
CONST	SEGMENT
_DEVPKEY_Device_Capabilities DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	011H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_PDOName
CONST	SEGMENT
_DEVPKEY_Device_PDOName DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	010H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_LocationInfo
CONST	SEGMENT
_DEVPKEY_Device_LocationInfo DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	0fH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_FriendlyName
CONST	SEGMENT
_DEVPKEY_Device_FriendlyName DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	0eH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Manufacturer
CONST	SEGMENT
_DEVPKEY_Device_Manufacturer DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	0dH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ConfigFlags
CONST	SEGMENT
_DEVPKEY_Device_ConfigFlags DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	0cH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Driver
CONST	SEGMENT
_DEVPKEY_Device_Driver DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	0bH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_ClassGuid
CONST	SEGMENT
_DEVPKEY_Device_ClassGuid DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	0aH
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Class
CONST	SEGMENT
_DEVPKEY_Device_Class DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	09H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_Service
CONST	SEGMENT
_DEVPKEY_Device_Service DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	06H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_CompatibleIds
CONST	SEGMENT
_DEVPKEY_Device_CompatibleIds DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	04H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_HardwareIds
CONST	SEGMENT
_DEVPKEY_Device_HardwareIds DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	03H
CONST	ENDS
;	COMDAT _DEVPKEY_Device_DeviceDesc
CONST	SEGMENT
_DEVPKEY_Device_DeviceDesc DD 0a45c254eH
	DW	0df1cH
	DW	04efdH
	DB	080H
	DB	020H
	DB	067H
	DB	0d1H
	DB	046H
	DB	0a8H
	DB	050H
	DB	0e0H
	DD	02H
CONST	ENDS
;	COMDAT _DEVPKEY_NAME
CONST	SEGMENT
_DEVPKEY_NAME DD 0b725f130H
	DW	047efH
	DW	0101aH
	DB	0a5H
	DB	0f1H
	DB	02H
	DB	060H
	DB	08cH
	DB	09eH
	DB	0ebH
	DB	0acH
	DD	0aH
CONST	ENDS
PUBLIC	_KeInitializeSpinLock@4
; Function compile flags: /Ogsp
; File d:\develop\ddk\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

	npad	2
	push	ebp
	mov	ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

	mov	eax, DWORD PTR _SpinLock$[ebp]
	and	DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

	pop	ebp
	ret	4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	_KeGetCurrentProcessorNumber@0
; Function compile flags: /Ogsp
; File d:\develop\ddk\winddk\7600.16385.1\inc\ddk\ntddk.h
;	COMDAT _KeGetCurrentProcessorNumber@0
_TEXT	SEGMENT
_KeGetCurrentProcessorNumber@0 PROC			; COMDAT

; 6243 : #if (_MSC_FULL_VER >= 13012035)
; 6244 :     return (ULONG) __readfsbyte (FIELD_OFFSET (KPCR, Number));

	mov	al, BYTE PTR fs:81
	movzx	eax, al

; 6245 : #else
; 6246 :     __asm {  movzx eax, _PCR KPCR.Number  }
; 6247 : #endif
; 6248 : }

	ret	0
_KeGetCurrentProcessorNumber@0 ENDP
_TEXT	ENDS
PUBLIC	_Initialize@4
EXTRN	_gGuardedRegion_OldIrql:BYTE
EXTRN	_gGuardedRegionCounter:DWORD
EXTRN	_memset:PROC
_BSS	SEGMENT
_gLastEntry_LookasideListEx DD 01H DUP (?)
_gLastEntry_CreateProcessNotifyEx DD 01H DUP (?)
_gSpin_LookasideListEx DD 01H DUP (?)
_gSpin_CreateProcessNotifyEx DD 01H DUP (?)
_Array_CreateProcessNotifyEx DD 0100H DUP (?)
; Function compile flags: /Ogsp
; File d:\develop\3drprojects\ntoskrnl_emu\ntoskrn8.c
_BSS	ENDS
;	COMDAT _Initialize@4
_TEXT	SEGMENT
_RegistryPath$ = 8					; size = 4
_Initialize@4 PROC					; COMDAT

; 200  :     KLOCK_QUEUE_HANDLE  LockHandle;
; 201  : 
; 202  :     gGuardedRegionCounter  = 0;

	xor	eax, eax

; 203  :     gGuardedRegion_OldIrql = APC_LEVEL; // initial MAX irql
; 204  : 
; 205  :     KeInitializeSpinLock(&gSpin_CreateProcessNotifyEx);
; 206  :     KeInitializeSpinLock(&gSpin_LookasideListEx);
; 207  :     
; 208  :     gLastEntry_CreateProcessNotifyEx = 0;
; 209  :     gLastEntry_LookasideListEx = 0;
; 210  :     
; 211  :     RtlZeroMemory(Array_CreateProcessNotifyEx,  sizeof(Array_CreateProcessNotifyEx));

	push	1024					; 00000400H
	push	eax
	push	OFFSET _Array_CreateProcessNotifyEx
	mov	DWORD PTR _gGuardedRegionCounter, eax
	mov	BYTE PTR _gGuardedRegion_OldIrql, 1
	mov	DWORD PTR _gSpin_CreateProcessNotifyEx, eax
	mov	DWORD PTR _gSpin_LookasideListEx, eax
	mov	DWORD PTR _gLastEntry_CreateProcessNotifyEx, eax
	mov	DWORD PTR _gLastEntry_LookasideListEx, eax
	call	_memset
	add	esp, 12					; 0000000cH

; 212  :     //RtlZeroMemory(Array_LookasideListEx,        sizeof(Array_LookasideListEx));
; 213  :     
; 214  : }

	ret	4
_Initialize@4 ENDP
_TEXT	ENDS
PUBLIC	_KeFlushQueuedDpcs_k8@0
; Function compile flags: /Ogsp
;	COMDAT _KeFlushQueuedDpcs_k8@0
_TEXT	SEGMENT
_KeFlushQueuedDpcs_k8@0 PROC				; COMDAT

; 220  :     return; // do nothing as WinXP SP2 does
; 221  : }

	ret	0
_KeFlushQueuedDpcs_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_RtlQueryRegistryValuesEx_k8@20
EXTRN	__imp__RtlQueryRegistryValues@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _RtlQueryRegistryValuesEx_k8@20
_TEXT	SEGMENT
_RelativeTo$ = 8					; size = 4
_Path$ = 12						; size = 4
_QueryTable$ = 16					; size = 4
_Context$ = 20						; size = 4
_Environment$ = 24					; size = 4
_RtlQueryRegistryValuesEx_k8@20 PROC			; COMDAT

; 231  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 233  : }

	pop	ebp

; 232  :     return RtlQueryRegistryValues(RelativeTo, Path, QueryTable, Context, Environment);

	jmp	DWORD PTR __imp__RtlQueryRegistryValues@20
_RtlQueryRegistryValuesEx_k8@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_RtlCheckPortableOperatingSystem_k8@4
EXTRN	__imp__RtlCheckRegistryKey@8:PROC
;	COMDAT ??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@ DB 'M', 00H
	DB	'i', 00H, 'n', 00H, 'i', 00H, 'N', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _RtlCheckPortableOperatingSystem_k8@4
_TEXT	SEGMENT
_IsPortable$ = 8					; size = 4
_RtlCheckPortableOperatingSystem_k8@4 PROC		; COMDAT

; 238  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 239  :     if (RtlCheckRegistryKey(RTL_REGISTRY_CONTROL, L"MiniNT") == STATUS_SUCCESS)

	push	OFFSET ??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@
	push	2
	call	DWORD PTR __imp__RtlCheckRegistryKey@8
	mov	ecx, DWORD PTR _IsPortable$[ebp]
	neg	eax
	sbb	al, al
	inc	al
	mov	BYTE PTR [ecx], al

; 240  :         *IsPortable = TRUE;
; 241  :     else   
; 242  :         *IsPortable = FALSE;
; 243  :     
; 244  :     return STATUS_SUCCESS;

	xor	eax, eax

; 245  : }

	pop	ebp
	ret	4
_RtlCheckPortableOperatingSystem_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlSetPortableOperatingSystem_k8@4
; Function compile flags: /Ogsp
;	COMDAT _RtlSetPortableOperatingSystem_k8@4
_TEXT	SEGMENT
_IsPortable$ = 8					; size = 1
_RtlSetPortableOperatingSystem_k8@4 PROC		; COMDAT

; 251  :     return STATUS_SUCCESS;

	xor	eax, eax

; 252  : }

	ret	4
_RtlSetPortableOperatingSystem_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSetActivityIdIrp_k8@8
; Function compile flags: /Ogsp
;	COMDAT _IoSetActivityIdIrp_k8@8
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_Guid$ = 12						; size = 4
_IoSetActivityIdIrp_k8@8 PROC				; COMDAT

; 260  :     return STATUS_SUCCESS;

	xor	eax, eax

; 261  : }

	ret	8
_IoSetActivityIdIrp_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_IoGetActivityIdIrp_k8@8
; Function compile flags: /Ogsp
;	COMDAT _IoGetActivityIdIrp_k8@8
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_Guid$ = 12						; size = 4
_IoGetActivityIdIrp_k8@8 PROC				; COMDAT

; 268  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 269  :     RtlCopyMemory(  Guid,
; 270  :                     &DUMMYGUID,
; 271  :                     sizeof(GUID));

	mov	edi, DWORD PTR _Guid$[ebp]
	mov	esi, OFFSET _DUMMYGUID
	movsd
	movsd
	movsd
	movsd
	pop	edi

; 272  : 
; 273  :     return STATUS_SUCCESS;

	xor	eax, eax
	pop	esi

; 274  : }

	pop	ebp
	ret	8
_IoGetActivityIdIrp_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_EtwRegister_k8@16
; Function compile flags: /Ogsp
;	COMDAT _EtwRegister_k8@16
_TEXT	SEGMENT
_ProviderId$ = 8					; size = 4
_EnableCallback$ = 12					; size = 4
_CallbackContext$ = 16					; size = 4
_RegHandle$ = 20					; size = 4
_EtwRegister_k8@16 PROC					; COMDAT

; 283  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 284  :     *RegHandle = (REGHANDLE) 0; // is RegHandle=0 OK ?

	mov	eax, DWORD PTR _RegHandle$[ebp]
	and	DWORD PTR [eax], 0
	and	DWORD PTR [eax+4], 0

; 285  :     return STATUS_SUCCESS;

	xor	eax, eax

; 286  : }

	pop	ebp
	ret	16					; 00000010H
_EtwRegister_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_EtwUnregister_k8@8
; Function compile flags: /Ogsp
;	COMDAT _EtwUnregister_k8@8
_TEXT	SEGMENT
_RegHandle$ = 8						; size = 8
_EtwUnregister_k8@8 PROC				; COMDAT

; 293  :     return STATUS_SUCCESS;

	xor	eax, eax

; 294  : }

	ret	8
_EtwUnregister_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_EtwProviderEnabled_k8@20
; Function compile flags: /Ogsp
;	COMDAT _EtwProviderEnabled_k8@20
_TEXT	SEGMENT
_RegHandle$ = 8						; size = 8
_Level$ = 16						; size = 1
_Keyword$ = 20						; size = 8
_EtwProviderEnabled_k8@20 PROC				; COMDAT

; 303  :     return FALSE;

	xor	al, al

; 304  : }

	ret	20					; 00000014H
_EtwProviderEnabled_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_EtwEventEnabled_k8@12
; Function compile flags: /Ogsp
;	COMDAT _EtwEventEnabled_k8@12
_TEXT	SEGMENT
_RegHandle$ = 8						; size = 8
_EventDescriptor$ = 16					; size = 4
_EtwEventEnabled_k8@12 PROC				; COMDAT

; 312  :     return FALSE;

	xor	al, al

; 313  : }

	ret	12					; 0000000cH
_EtwEventEnabled_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_EtwWrite_k8@24
; Function compile flags: /Ogsp
;	COMDAT _EtwWrite_k8@24
_TEXT	SEGMENT
_RegHandle$ = 8						; size = 8
_EventDescriptor$ = 16					; size = 4
_ActivityId$ = 20					; size = 4
_UserDataCount$ = 24					; size = 4
_UserData$ = 28						; size = 4
_EtwWrite_k8@24 PROC					; COMDAT

; 324  :     return STATUS_SUCCESS;

	xor	eax, eax

; 325  : }

	ret	24					; 00000018H
_EtwWrite_k8@24 ENDP
_TEXT	ENDS
PUBLIC	_EtwActivityIdControl_k8@8
; Function compile flags: /Ogsp
;	COMDAT _EtwActivityIdControl_k8@8
_TEXT	SEGMENT
_ControlCode$ = 8					; size = 4
_ActivityId$ = 12					; size = 4
_EtwActivityIdControl_k8@8 PROC				; COMDAT

; 332  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 333  :     switch (ControlCode) {

	cmp	DWORD PTR _ControlCode$[ebp], 1
	je	SHORT $LN2@EtwActivit
	cmp	DWORD PTR _ControlCode$[ebp], 2
	jbe	SHORT $LN1@EtwActivit
	cmp	DWORD PTR _ControlCode$[ebp], 4
	ja	SHORT $LN1@EtwActivit
$LN2@EtwActivit:
	push	esi
	push	edi

; 334  :         case EVENT_ACTIVITY_CTRL_GET_ID:
; 335  :         case EVENT_ACTIVITY_CTRL_CREATE_ID:
; 336  :         case EVENT_ACTIVITY_CTRL_GET_SET_ID:
; 337  :             RtlCopyMemory(  ActivityId,
; 338  :                             &DUMMYGUID,
; 339  :                             sizeof(GUID));

	mov	edi, DWORD PTR _ActivityId$[ebp]
	mov	esi, OFFSET _DUMMYGUID
	movsd
	movsd
	movsd
	movsd
	pop	edi
	pop	esi
$LN1@EtwActivit:

; 340  :             break;
; 341  :         case EVENT_ACTIVITY_CTRL_SET_ID:
; 342  :         case EVENT_ACTIVITY_CTRL_CREATE_SET_ID:
; 343  :         default:
; 344  :         ;
; 345  :     }
; 346  : 
; 347  :     return STATUS_SUCCESS;

	xor	eax, eax

; 348  : }

	pop	ebp
	ret	8
_EtwActivityIdControl_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_EtwWriteTransfer_k8@28
; Function compile flags: /Ogsp
;	COMDAT _EtwWriteTransfer_k8@28
_TEXT	SEGMENT
_RegHandle$ = 8						; size = 8
_EventDescriptor$ = 16					; size = 4
_ActivityId$ = 20					; size = 4
_RelatedActivityId$ = 24				; size = 4
_UserDataCount$ = 28					; size = 4
_UserData$ = 32						; size = 4
_EtwWriteTransfer_k8@28 PROC				; COMDAT

; 361  :     return STATUS_SUCCESS;    

	xor	eax, eax

; 362  : }

	ret	28					; 0000001cH
_EtwWriteTransfer_k8@28 ENDP
_TEXT	ENDS
PUBLIC	_EtwWriteString_k8@28
; Function compile flags: /Ogsp
;	COMDAT _EtwWriteString_k8@28
_TEXT	SEGMENT
_RegHandle$ = 8						; size = 8
_Level$ = 16						; size = 1
_Keyword$ = 20						; size = 8
_ActivityId$ = 28					; size = 4
_String$ = 32						; size = 4
_EtwWriteString_k8@28 PROC				; COMDAT

; 373  :     return STATUS_SUCCESS;

	xor	eax, eax

; 374  : }

	ret	28					; 0000001cH
_EtwWriteString_k8@28 ENDP
_TEXT	ENDS
PUBLIC	_EtwRegisterClassicProvider_k8@20
; Function compile flags: /Ogsp
;	COMDAT _EtwRegisterClassicProvider_k8@20
_TEXT	SEGMENT
_Ptr$ = 8						; size = 4
_Flags$ = 12						; size = 4
_Callback$ = 16						; size = 4
_a4$ = 20						; size = 4
_a5$ = 24						; size = 4
_EtwRegisterClassicProvider_k8@20 PROC			; COMDAT

; 385  :     return STATUS_SUCCESS;

	xor	eax, eax

; 386  : }

	ret	20					; 00000014H
_EtwRegisterClassicProvider_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_ZwAlpcConnectPort_k8@44
; Function compile flags: /Ogsp
;	COMDAT _ZwAlpcConnectPort_k8@44
_TEXT	SEGMENT
_PortHandle$ = 8					; size = 4
_PortName$ = 12						; size = 4
_ObjectAttributes$ = 16					; size = 4
_PortAttributes$ = 20					; size = 4
_Flags$ = 24						; size = 4
_RequiredServerSid$ = 28				; size = 4
_ConnectionMessage$ = 32				; size = 4
_BufferLength$ = 36					; size = 4
_OutMessageAttributes$ = 40				; size = 4
_InMessageAttributes$ = 44				; size = 4
_Timeout$ = 48						; size = 4
_ZwAlpcConnectPort_k8@44 PROC				; COMDAT

; 403  :     return STATUS_SUCCESS;

	xor	eax, eax

; 404  : }

	ret	44					; 0000002cH
_ZwAlpcConnectPort_k8@44 ENDP
_TEXT	ENDS
PUBLIC	_ZwAlpcSendWaitReceivePort_k8@32
; Function compile flags: /Ogsp
;	COMDAT _ZwAlpcSendWaitReceivePort_k8@32
_TEXT	SEGMENT
_PortHandle$ = 8					; size = 4
_Flags$ = 12						; size = 4
_SendMessage$ = 16					; size = 4
_SendMessageAttributes$ = 20				; size = 4
_ReceiveMessage$ = 24					; size = 4
_BufferLength$ = 28					; size = 4
_ReceiveMessageAttributes$ = 32				; size = 4
_Timeout$ = 36						; size = 4
_ZwAlpcSendWaitReceivePort_k8@32 PROC			; COMDAT

; 418  :     return STATUS_SUCCESS;

	xor	eax, eax

; 419  : }

	ret	32					; 00000020H
_ZwAlpcSendWaitReceivePort_k8@32 ENDP
_TEXT	ENDS
PUBLIC	_KdRefreshDebuggerNotPresent_k8@0
EXTRN	_KdDebuggerNotPresent:DWORD
; Function compile flags: /Ogsp
;	COMDAT _KdRefreshDebuggerNotPresent_k8@0
_TEXT	SEGMENT
_KdRefreshDebuggerNotPresent_k8@0 PROC			; COMDAT

; 425  :     return KD_DEBUGGER_NOT_PRESENT;

	mov	eax, DWORD PTR _KdDebuggerNotPresent
	mov	al, BYTE PTR [eax]

; 426  :  }

	ret	0
_KdRefreshDebuggerNotPresent_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_IoGetDevicePropertyData_k8@32
; Function compile flags: /Ogsp
;	COMDAT _IoGetDevicePropertyData_k8@32
_TEXT	SEGMENT
_Pdo$ = 8						; size = 4
_PropertyKey$ = 12					; size = 4
_Lcid$ = 16						; size = 4
_Flags$ = 20						; size = 4
_Size$ = 24						; size = 4
_Data$ = 28						; size = 4
_RequiredSize$ = 32					; size = 4
_Type$ = 36						; size = 4
_IoGetDevicePropertyData_k8@32 PROC			; COMDAT

; 439  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 440  :     if (RtlEqualMemory( PropertyKey,
; 441  :                         &DEVPKEY_Device_MatchingDeviceId,
; 442  :                         sizeof(DEVPROPKEY)) ) {

	mov	esi, DWORD PTR _PropertyKey$[ebp]
	push	edi
	push	5
	pop	ecx
	mov	edi, OFFSET _DEVPKEY_Device_MatchingDeviceId
	xor	eax, eax
	repe cmpsd
	pop	edi
	pop	esi
	jne	SHORT $LN1@IoGetDevic

; 443  :         //TODO: find DeviceId on PDO
; 444  :         *Type = DEVPROP_TYPE_STRING;

	mov	eax, DWORD PTR _Type$[ebp]
	mov	DWORD PTR [eax], 18			; 00000012H
$LN1@IoGetDevic:

; 445  :     }
; 446  : 
; 447  :     return STATUS_SUCCESS;

	xor	eax, eax

; 448  : }

	pop	ebp
	ret	32					; 00000020H
_IoGetDevicePropertyData_k8@32 ENDP
_TEXT	ENDS
PUBLIC	_IoSetDevicePropertyData_k8@28
; Function compile flags: /Ogsp
;	COMDAT _IoSetDevicePropertyData_k8@28
_TEXT	SEGMENT
_Pdo$ = 8						; size = 4
_PropertyKey$ = 12					; size = 4
_Lcid$ = 16						; size = 4
_Flags$ = 20						; size = 4
_Type$ = 24						; size = 4
_Size$ = 28						; size = 4
_Data$ = 32						; size = 4
_IoSetDevicePropertyData_k8@28 PROC			; COMDAT

; 461  :     return STATUS_SUCCESS;

	xor	eax, eax

; 462  : }

	ret	28					; 0000001cH
_IoSetDevicePropertyData_k8@28 ENDP
_TEXT	ENDS
PUBLIC	_IopProcessWorkItem_k8@4
EXTRN	__imp_@ObfDereferenceObject@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _IopProcessWorkItem_k8@4
_TEXT	SEGMENT
_ioWorkItem$ = 8					; size = 4
_IopProcessWorkItem_k8@4 PROC				; COMDAT

; 469  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 470  :     PDEVICE_OBJECT deviceObject = ioWorkItem->IoObject;

	mov	eax, DWORD PTR _ioWorkItem$[ebp]

; 471  : 
; 472  :     if (ioWorkItem->Type) // routine_ex

	cmp	DWORD PTR [eax+28], 0
	push	esi
	mov	esi, DWORD PTR [eax+20]
	je	SHORT $LN2@IopProcess

; 473  :         ioWorkItem->Routine( deviceObject,
; 474  :                              ioWorkItem->Context,
; 475  :                              ioWorkItem );

	push	eax
	push	DWORD PTR [eax+24]
	push	esi
	call	DWORD PTR [eax+16]

; 476  :     else {

	jmp	SHORT $LN1@IopProcess
$LN2@IopProcess:

; 477  :         PIO_WORKITEM_ROUTINE ClassicCall = (PIO_WORKITEM_ROUTINE) ioWorkItem->Routine;
; 478  :         ClassicCall( deviceObject, ioWorkItem->Context );

	push	DWORD PTR [eax+24]
	push	esi
	call	DWORD PTR [eax+16]
$LN1@IopProcess:

; 479  :     }
; 480  : 
; 481  :     ObDereferenceObject( deviceObject );

	mov	ecx, esi
	call	DWORD PTR __imp_@ObfDereferenceObject@4
	pop	esi

; 482  : }

	pop	ebp
	ret	4
_IopProcessWorkItem_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_IoAllocateWorkItem_inject@4
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _IoAllocateWorkItem_inject@4
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_IoAllocateWorkItem_inject@4 PROC			; COMDAT

; 489  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 490  :     PIO_WORKITEM_EX ioWorkItem;
; 491  :     PWORK_QUEUE_ITEM exWorkItem;
; 492  : 
; 493  :     ioWorkItem = (PIO_WORKITEM_EX) ExAllocatePoolWithTag( NonPagedPool, sizeof( IO_WORKITEM_EX ), '  oI');

	push	538996553				; 20206f49H
	push	32					; 00000020H
	push	0
	call	DWORD PTR __imp__ExAllocatePoolWithTag@12

; 494  :     if (ioWorkItem != NULL) {

	test	eax, eax
	je	SHORT $LN1@IoAllocate

; 495  :         ioWorkItem->IoObject = DeviceObject;

	mov	ecx, DWORD PTR _DeviceObject$[ebp]

; 496  :         ioWorkItem->Type = 0;               // standart workitem

	and	DWORD PTR [eax+28], 0

; 497  : 
; 498  :         exWorkItem = &ioWorkItem->WorkItem;
; 499  :         exWorkItem->WorkerRoutine = (PWORKER_THREAD_ROUTINE) IopProcessWorkItem_k8;
; 500  :         exWorkItem->Parameter = ioWorkItem;
; 501  :         exWorkItem->List.Flink = NULL;

	and	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+8], OFFSET _IopProcessWorkItem_k8@4
	mov	DWORD PTR [eax+12], eax
$LN1@IoAllocate:

; 502  :     }
; 503  : 
; 504  :     return ioWorkItem;
; 505  : }

	pop	ebp
	ret	4
_IoAllocateWorkItem_inject@4 ENDP
_TEXT	ENDS
PUBLIC	_IoQueueWorkItemEx_k8@16
EXTRN	__imp__ExQueueWorkItem@8:PROC
EXTRN	__imp_@ObfReferenceObject@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _IoQueueWorkItemEx_k8@16
_TEXT	SEGMENT
_IoWorkItem$ = 8					; size = 4
_WorkerRoutineEx$ = 12					; size = 4
_QueueType$ = 16					; size = 4
_Context$ = 20						; size = 4
_IoQueueWorkItemEx_k8@16 PROC				; COMDAT

; 517  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 518  :     ObReferenceObject( IoWorkItem->IoObject );

	mov	esi, DWORD PTR _IoWorkItem$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	call	DWORD PTR __imp_@ObfReferenceObject@4

; 519  : 
; 520  :     IoWorkItem->Routine = WorkerRoutineEx;

	mov	eax, DWORD PTR _WorkerRoutineEx$[ebp]

; 521  :     IoWorkItem->Context = Context;
; 522  :     IoWorkItem->Type    = 1;            // WorkitemEx
; 523  : 
; 524  :     ExQueueWorkItem( &IoWorkItem->WorkItem, QueueType );

	push	DWORD PTR _QueueType$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _Context$[ebp]
	push	esi
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], 1
	call	DWORD PTR __imp__ExQueueWorkItem@8
	pop	esi

; 525  : }

	pop	ebp
	ret	16					; 00000010H
_IoQueueWorkItemEx_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_IoQueueWorkItem_inject@16
; Function compile flags: /Ogsp
;	COMDAT _IoQueueWorkItem_inject@16
_TEXT	SEGMENT
_IoWorkItem$ = 8					; size = 4
_WorkerRoutine$ = 12					; size = 4
_QueueType$ = 16					; size = 4
_Context$ = 20						; size = 4
_IoQueueWorkItem_inject@16 PROC				; COMDAT

; 533  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 534  :     ObReferenceObject( IoWorkItem->IoObject );

	mov	esi, DWORD PTR _IoWorkItem$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	call	DWORD PTR __imp_@ObfReferenceObject@4

; 535  : 
; 536  :     IoWorkItem->Routine = (PIO_WORKITEM_ROUTINE_EX_k8) WorkerRoutine;

	mov	eax, DWORD PTR _WorkerRoutine$[ebp]

; 537  :     IoWorkItem->Context = Context;
; 538  :     IoWorkItem->Type    = 0;            // standart workitem
; 539  : 
; 540  :     ExQueueWorkItem( &IoWorkItem->WorkItem, QueueType );

	push	DWORD PTR _QueueType$[ebp]
	and	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR _Context$[ebp]
	push	esi
	mov	DWORD PTR [esi+24], eax
	call	DWORD PTR __imp__ExQueueWorkItem@8
	pop	esi

; 541  : }

	pop	ebp
	ret	16					; 00000010H
_IoQueueWorkItem_inject@16 ENDP
_TEXT	ENDS
PUBLIC	_IoSizeofWorkItem_k8@0
; Function compile flags: /Ogsp
;	COMDAT _IoSizeofWorkItem_k8@0
_TEXT	SEGMENT
_IoSizeofWorkItem_k8@0 PROC				; COMDAT

; 549  :     return sizeof(IO_WORKITEM_EX);

	push	32					; 00000020H
	pop	eax

; 550  : }

	ret	0
_IoSizeofWorkItem_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_IoInitializeWorkItem_k8@8
; Function compile flags: /Ogsp
;	COMDAT _IoInitializeWorkItem_k8@8
_TEXT	SEGMENT
_IoObject$ = 8						; size = 4
_IoWorkItem$ = 12					; size = 4
_IoInitializeWorkItem_k8@8 PROC				; COMDAT

; 557  : {  

	npad	2
	push	ebp
	mov	ebp, esp

; 558  :     IoWorkItem->WorkItem.List.Flink = 0;

	mov	eax, DWORD PTR _IoWorkItem$[ebp]

; 559  :     IoWorkItem->Type = 0;                   // standart workitem
; 560  :     IoWorkItem->IoObject = (PDEVICE_OBJECT) IoObject;

	mov	ecx, DWORD PTR _IoObject$[ebp]
	and	DWORD PTR [eax], 0
	and	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+20], ecx

; 561  :     IoWorkItem->WorkItem.WorkerRoutine = (PWORKER_THREAD_ROUTINE) IopProcessWorkItem_k8;

	mov	DWORD PTR [eax+8], OFFSET _IopProcessWorkItem_k8@4

; 562  :     IoWorkItem->WorkItem.Parameter = IoWorkItem;

	mov	DWORD PTR [eax+12], eax

; 563  : }

	pop	ebp
	ret	8
_IoInitializeWorkItem_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_IoUninitializeWorkItem_k8@4
; Function compile flags: /Ogsp
;	COMDAT _IoUninitializeWorkItem_k8@4
_TEXT	SEGMENT
_IoWorkItem$ = 8					; size = 4
_IoUninitializeWorkItem_k8@4 PROC			; COMDAT

; 570  :     ; // nothing to do
; 571  : }

	ret	4
_IoUninitializeWorkItem_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryDpcWatchdogInformation_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeQueryDpcWatchdogInformation_k8@4
_TEXT	SEGMENT
_WatchdogInformation$ = 8				; size = 4
_KeQueryDpcWatchdogInformation_k8@4 PROC		; COMDAT

; 577  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 578  :     WatchdogInformation->DpcTimeLimit       = 0;

	mov	eax, DWORD PTR _WatchdogInformation$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 579  :     WatchdogInformation->DpcTimeCount       = 0;

	mov	DWORD PTR [eax+4], ecx

; 580  :     WatchdogInformation->DpcWatchdogLimit   = 0;

	mov	DWORD PTR [eax+8], ecx

; 581  :     WatchdogInformation->DpcWatchdogCount   = 0;

	mov	DWORD PTR [eax+12], ecx

; 582  : 
; 583  :     return STATUS_SUCCESS;

	xor	eax, eax

; 584  : }

	pop	ebp
	ret	4
_KeQueryDpcWatchdogInformation_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeGetProcessorIndexFromNumber_k8@4
EXTRN	__imp__KeNumberProcessors:BYTE
; Function compile flags: /Ogsp
;	COMDAT _KeGetProcessorIndexFromNumber_k8@4
_TEXT	SEGMENT
_ProcNumber$ = 8					; size = 4
_KeGetProcessorIndexFromNumber_k8@4 PROC		; COMDAT

; 593  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 594  :     if (ProcNumber->Group    != 0                  ||
; 595  :         ProcNumber->Number   >= KeNumberProcessors ||
; 596  :         ProcNumber->Reserved != 0 )

	mov	ecx, DWORD PTR _ProcNumber$[ebp]
	cmp	WORD PTR [ecx], 0
	jne	SHORT $LN1@KeGetProce
	mov	edx, DWORD PTR __imp__KeNumberProcessors
	movzx	eax, BYTE PTR [ecx+2]
	movsx	edx, BYTE PTR [edx]
	cmp	eax, edx
	jge	SHORT $LN1@KeGetProce
	cmp	BYTE PTR [ecx+3], 0

; 598  : 
; 599  :     return ProcNumber->Number;

	je	SHORT $LN3@KeGetProce
$LN1@KeGetProce:

; 597  :         return INVALID_PROCESSOR_INDEX;

	or	eax, -1
$LN3@KeGetProce:

; 600  : }

	pop	ebp
	ret	4
_KeGetProcessorIndexFromNumber_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeGetProcessorNumberFromIndex_k8@8
; Function compile flags: /Ogsp
;	COMDAT _KeGetProcessorNumberFromIndex_k8@8
_TEXT	SEGMENT
_ProcIndex$ = 8						; size = 4
_ProcNumber$ = 12					; size = 4
_KeGetProcessorNumberFromIndex_k8@8 PROC		; COMDAT

; 607  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 608  :     if (ProcIndex >= (ULONG)KeNumberProcessors)

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]
	mov	ecx, DWORD PTR _ProcIndex$[ebp]
	cmp	ecx, eax
	jb	SHORT $LN1@KeGetProce@2

; 609  :         return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	SHORT $LN2@KeGetProce@2
$LN1@KeGetProce@2:

; 610  :         
; 611  :     ProcNumber->Group    =  0;

	mov	eax, DWORD PTR _ProcNumber$[ebp]
	xor	edx, edx
	mov	WORD PTR [eax], dx

; 612  :     ProcNumber->Number   =  (UCHAR) ProcIndex;

	mov	BYTE PTR [eax+2], cl

; 613  :     ProcNumber->Reserved =  0;

	mov	BYTE PTR [eax+3], dl

; 614  :     return STATUS_SUCCESS;

	xor	eax, eax
$LN2@KeGetProce@2:

; 615  : }

	pop	ebp
	ret	8
_KeGetProcessorNumberFromIndex_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryActiveProcessorCount_k8@4
EXTRN	__imp__KeQueryActiveProcessors@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeQueryActiveProcessorCount_k8@4
_TEXT	SEGMENT
_ActiveProcessors$ = 8					; size = 4
_KeQueryActiveProcessorCount_k8@4 PROC			; COMDAT

; 622  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 623  :     if (ActiveProcessors != NULL)

	mov	esi, DWORD PTR _ActiveProcessors$[ebp]
	test	esi, esi
	je	SHORT $LN1@KeQueryAct

; 624  :             *ActiveProcessors = KeQueryActiveProcessors();

	call	DWORD PTR __imp__KeQueryActiveProcessors@0
	mov	DWORD PTR [esi], eax
$LN1@KeQueryAct:

; 625  :     
; 626  :     return KeNumberProcessors;

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]
	pop	esi

; 627  : }

	pop	ebp
	ret	4
_KeQueryActiveProcessorCount_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryActiveProcessorCountEx_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeQueryActiveProcessorCountEx_k8@4
_TEXT	SEGMENT
_GroupNumber$ = 8					; size = 2
_KeQueryActiveProcessorCountEx_k8@4 PROC		; COMDAT

; 633  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 634  :     if ( GroupNumber != 0 && GroupNumber != ALL_PROCESSOR_GROUPS )

	cmp	WORD PTR _GroupNumber$[ebp], 0
	je	SHORT $LN1@KeQueryAct@2
	mov	eax, 65535				; 0000ffffH
	cmp	WORD PTR _GroupNumber$[ebp], ax
	je	SHORT $LN1@KeQueryAct@2

; 635  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN2@KeQueryAct@2
$LN1@KeQueryAct@2:

; 636  : 
; 637  :     return KeNumberProcessors;

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]
$LN2@KeQueryAct@2:

; 638  : }

	pop	ebp
	ret	4
_KeQueryActiveProcessorCountEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeGetCurrentProcessorNumberEx_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeGetCurrentProcessorNumberEx_k8@4
_TEXT	SEGMENT
_ProcNumber$ = 8					; size = 4
_KeGetCurrentProcessorNumberEx_k8@4 PROC		; COMDAT

; 644  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 645  :     ULONG CurrentProcessorNumber;
; 646  :     
; 647  :     CurrentProcessorNumber = KeGetCurrentProcessorNumber();
; 648  :     if (ProcNumber != NULL) {

	mov	ecx, DWORD PTR _ProcNumber$[ebp]
	mov	al, BYTE PTR fs:81
	movzx	eax, al
	test	ecx, ecx
	je	SHORT $LN1@KeGetCurre

; 649  :             ProcNumber->Group    =  0;

	xor	edx, edx
	mov	WORD PTR [ecx], dx

; 650  :             ProcNumber->Number   =  (UCHAR) CurrentProcessorNumber;

	mov	BYTE PTR [ecx+2], al

; 651  :             ProcNumber->Reserved =  0;

	mov	BYTE PTR [ecx+3], dl
$LN1@KeGetCurre:

; 652  :     }
; 653  : 
; 654  :     return CurrentProcessorNumber;
; 655  : }

	pop	ebp
	ret	4
_KeGetCurrentProcessorNumberEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryMaximumProcessorCount_k8@0
; Function compile flags: /Ogsp
;	COMDAT _KeQueryMaximumProcessorCount_k8@0
_TEXT	SEGMENT
_KeQueryMaximumProcessorCount_k8@0 PROC			; COMDAT

; 661  :     return KeNumberProcessors;

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]

; 662  : }

	ret	0
_KeQueryMaximumProcessorCount_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryMaximumProcessorCountEx_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeQueryMaximumProcessorCountEx_k8@4
_TEXT	SEGMENT
_GroupNumber$ = 8					; size = 2
_KeQueryMaximumProcessorCountEx_k8@4 PROC		; COMDAT

; 668  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 669  :     if (GroupNumber == 0 || GroupNumber == ALL_PROCESSOR_GROUPS)

	cmp	WORD PTR _GroupNumber$[ebp], 0
	je	SHORT $LN1@KeQueryMax
	mov	eax, 65535				; 0000ffffH
	cmp	WORD PTR _GroupNumber$[ebp], ax
	je	SHORT $LN1@KeQueryMax

; 671  : 
; 672  :     return 0; // error

	xor	eax, eax
	jmp	SHORT $LN3@KeQueryMax
$LN1@KeQueryMax:

; 670  :         return KeNumberProcessors;

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]
$LN3@KeQueryMax:

; 673  : }

	pop	ebp
	ret	4
_KeQueryMaximumProcessorCountEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryActiveGroupCount_k8@0
; Function compile flags: /Ogsp
;	COMDAT _KeQueryActiveGroupCount_k8@0
_TEXT	SEGMENT
_KeQueryActiveGroupCount_k8@0 PROC			; COMDAT

; 679  :     return 1;  // active groups = 1 

	xor	eax, eax
	inc	eax

; 680  : }

	ret	0
_KeQueryActiveGroupCount_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryMaximumGroupCount_k8@0
; Function compile flags: /Ogsp
;	COMDAT _KeQueryMaximumGroupCount_k8@0
_TEXT	SEGMENT
_KeQueryMaximumGroupCount_k8@0 PROC			; COMDAT

; 686  :     return 1;  // total groups = 1 

	xor	eax, eax
	inc	eax

; 687  : }

	ret	0
_KeQueryMaximumGroupCount_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeSetSystemAffinityThread_inject@4
EXTRN	__imp__KeSetSystemAffinityThread@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeSetSystemAffinityThread_inject@4
_TEXT	SEGMENT
_Affinity$ = 8						; size = 4
_KeSetSystemAffinityThread_inject@4 PROC		; COMDAT

; 698  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 699  :     KAFFINITY AvailableAffinity;
; 700  : 
; 701  :     AvailableAffinity = KeQueryActiveProcessors();

	call	DWORD PTR __imp__KeQueryActiveProcessors@0

; 702  :     if ((Affinity & AvailableAffinity) == 0) { // bad requested affinity

	mov	ecx, DWORD PTR _Affinity$[ebp]
	test	eax, ecx
	jne	SHORT $LN1@KeSetSyste

; 703  :         Affinity = AvailableAffinity;

	mov	ecx, eax
$LN1@KeSetSyste:

; 704  :     }
; 705  : 
; 706  :     KeSetSystemAffinityThread(Affinity);

	push	ecx
	call	DWORD PTR __imp__KeSetSystemAffinityThread@4

; 707  : }   

	pop	ebp
	ret	4
_KeSetSystemAffinityThread_inject@4 ENDP
_TEXT	ENDS
PUBLIC	_KeSetSystemAffinityThreadEx_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeSetSystemAffinityThreadEx_k8@4
_TEXT	SEGMENT
_Affinity$ = 8						; size = 4
_KeSetSystemAffinityThreadEx_k8@4 PROC			; COMDAT

; 713  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 714  :     KeSetSystemAffinityThread_inject(Affinity);

	push	DWORD PTR _Affinity$[ebp]
	call	_KeSetSystemAffinityThread_inject@4

; 715  :     return (KAFFINITY) 0;

	xor	eax, eax

; 716  : }

	pop	ebp
	ret	4
_KeSetSystemAffinityThreadEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeSetSystemGroupAffinityThread_k8@8
; Function compile flags: /Ogsp
;	COMDAT _KeSetSystemGroupAffinityThread_k8@8
_TEXT	SEGMENT
_Affinity$ = 8						; size = 4
_PreviousAffinity$ = 12					; size = 4
_KeSetSystemGroupAffinityThread_k8@8 PROC		; COMDAT

; 723  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 724  :     KAFFINITY PrevAffinity;
; 725  :     KAFFINITY NewAffinity = 0;
; 726  :     
; 727  :     if (Affinity->Group       == 0  &&
; 728  :         Affinity->Reserved[0] == 0  &&
; 729  :         Affinity->Reserved[1] == 0  &&
; 730  :         Affinity->Reserved[2] == 0)

	mov	eax, DWORD PTR _Affinity$[ebp]
	xor	ecx, ecx
	cmp	WORD PTR [eax+4], cx
	jne	SHORT $LN2@KeSetSyste@2
	cmp	WORD PTR [eax+6], cx
	jne	SHORT $LN2@KeSetSyste@2
	cmp	WORD PTR [eax+8], cx
	jne	SHORT $LN2@KeSetSyste@2
	cmp	WORD PTR [eax+10], cx
	jne	SHORT $LN2@KeSetSyste@2

; 731  :             NewAffinity= Affinity->Mask;

	mov	ecx, DWORD PTR [eax]
$LN2@KeSetSyste@2:

; 732  :     
; 733  :     
; 734  :     PrevAffinity=KeSetSystemAffinityThreadEx_k8(NewAffinity);

	push	ecx
	call	_KeSetSystemAffinityThreadEx_k8@4

; 735  :     
; 736  :     if (PreviousAffinity != NULL)

	mov	ecx, DWORD PTR _PreviousAffinity$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@KeSetSyste@2

; 737  :     {
; 738  :         PreviousAffinity->Mask        = PrevAffinity;

	mov	DWORD PTR [ecx], eax

; 739  :         PreviousAffinity->Group       = 0;

	xor	eax, eax
	mov	WORD PTR [ecx+4], ax

; 740  :         PreviousAffinity->Reserved[0] = 0;

	mov	WORD PTR [ecx+6], ax

; 741  :         PreviousAffinity->Reserved[1] = 0;

	mov	WORD PTR [ecx+8], ax

; 742  :         PreviousAffinity->Reserved[2] = 0;

	mov	WORD PTR [ecx+10], ax
$LN1@KeSetSyste@2:

; 743  :     }
; 744  : }

	pop	ebp
	ret	8
_KeSetSystemGroupAffinityThread_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_KeRevertToUserAffinityThreadEx_k8@4
EXTRN	__imp__KeRevertToUserAffinityThread@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeRevertToUserAffinityThreadEx_k8@4
_TEXT	SEGMENT
_Affinity$ = 8						; size = 4
_KeRevertToUserAffinityThreadEx_k8@4 PROC		; COMDAT

; 750  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 751  :     if ( Affinity == 0)

	cmp	DWORD PTR _Affinity$[ebp], 0
	jne	SHORT $LN1@KeRevertTo

; 752  :         KeRevertToUserAffinityThread();

	call	DWORD PTR __imp__KeRevertToUserAffinityThread@0
$LN1@KeRevertTo:

; 753  : }

	pop	ebp
	ret	4
_KeRevertToUserAffinityThreadEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeRevertToUserGroupAffinityThread_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeRevertToUserGroupAffinityThread_k8@4
_TEXT	SEGMENT
_PreviousAffinity$ = 8					; size = 4
_KeRevertToUserGroupAffinityThread_k8@4 PROC		; COMDAT

; 759  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 760  :     if (PreviousAffinity->Reserved[0] != 0 ||
; 761  :         PreviousAffinity->Reserved[1] != 0 ||
; 762  :         PreviousAffinity->Reserved[2] != 0 )

	mov	eax, DWORD PTR _PreviousAffinity$[ebp]
	xor	edx, edx
	cmp	WORD PTR [eax+6], dx
	jne	SHORT $LN4@KeRevertTo@2
	cmp	WORD PTR [eax+8], dx
	jne	SHORT $LN4@KeRevertTo@2
	cmp	WORD PTR [eax+10], dx
	jne	SHORT $LN4@KeRevertTo@2

; 763  :         return;
; 764  :         
; 765  :     if (PreviousAffinity->Mask == 0)

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edx
	jne	SHORT $LN3@KeRevertTo@2

; 766  :         KeRevertToUserAffinityThread();

	call	DWORD PTR __imp__KeRevertToUserAffinityThread@0

; 767  :     else {

	jmp	SHORT $LN4@KeRevertTo@2
$LN3@KeRevertTo@2:

; 768  :         if (PreviousAffinity->Group == 0)

	cmp	WORD PTR [eax+4], dx
	jne	SHORT $LN4@KeRevertTo@2

; 769  :             KeRevertToUserAffinityThreadEx_k8(PreviousAffinity->Mask);

	push	ecx
	call	_KeRevertToUserAffinityThreadEx_k8@4
$LN4@KeRevertTo@2:

; 770  :     }
; 771  : }

	pop	ebp
	ret	4
_KeRevertToUserGroupAffinityThread_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeSetTargetProcessorDpcEx_k8@8
EXTRN	__imp__KeSetTargetProcessorDpc@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeSetTargetProcessorDpcEx_k8@8
_TEXT	SEGMENT
_Dpc$ = 8						; size = 4
_ProcNumber$ = 12					; size = 4
_KeSetTargetProcessorDpcEx_k8@8 PROC			; COMDAT

; 778  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 779  :     if (ProcNumber->Group    != 0                  ||
; 780  :         ProcNumber->Number   >= KeNumberProcessors ||
; 781  :         ProcNumber->Reserved != 0)

	mov	eax, DWORD PTR _ProcNumber$[ebp]
	cmp	WORD PTR [eax], 0
	jne	SHORT $LN1@KeSetTarge
	mov	cl, BYTE PTR [eax+2]
	push	esi
	mov	esi, DWORD PTR __imp__KeNumberProcessors
	movsx	esi, BYTE PTR [esi]
	movzx	edx, cl
	cmp	edx, esi
	pop	esi
	jge	SHORT $LN1@KeSetTarge
	cmp	BYTE PTR [eax+3], 0
	jne	SHORT $LN1@KeSetTarge

; 783  :         
; 784  :     KeSetTargetProcessorDpc(Dpc, ProcNumber->Number);

	push	ecx
	push	DWORD PTR _Dpc$[ebp]
	call	DWORD PTR __imp__KeSetTargetProcessorDpc@8

; 785  :     return STATUS_SUCCESS;    

	xor	eax, eax
	jmp	SHORT $LN3@KeSetTarge
$LN1@KeSetTarge:

; 782  :             return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
$LN3@KeSetTarge:

; 786  : }

	pop	ebp
	ret	8
_KeSetTargetProcessorDpcEx_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_KeGetCurrentNodeNumber_k8@0
; Function compile flags: /Ogsp
;	COMDAT _KeGetCurrentNodeNumber_k8@0
_TEXT	SEGMENT
_KeGetCurrentNodeNumber_k8@0 PROC			; COMDAT

; 792  :     return 0; // current node = 0

	xor	eax, eax

; 793  : }

	ret	0
_KeGetCurrentNodeNumber_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryHighestNodeNumber_k8@0
; Function compile flags: /Ogsp
;	COMDAT _KeQueryHighestNodeNumber_k8@0
_TEXT	SEGMENT
_KeQueryHighestNodeNumber_k8@0 PROC			; COMDAT

; 799  :     return 0; // total nodes = 0

	xor	eax, eax

; 800  : }

	ret	0
_KeQueryHighestNodeNumber_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryNodeActiveAffinity_k8@12
; Function compile flags: /Ogsp
;	COMDAT _KeQueryNodeActiveAffinity_k8@12
_TEXT	SEGMENT
_NodeNumber$ = 8					; size = 2
_Affinity$ = 12						; size = 4
_Count$ = 16						; size = 4
_KeQueryNodeActiveAffinity_k8@12 PROC			; COMDAT

; 808  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 809  :     if (NodeNumber > 0) {

	cmp	WORD PTR _NodeNumber$[ebp], 0
	jbe	SHORT $LN6@KeQueryNod

; 810  :         if (Affinity != NULL) { 

	mov	eax, DWORD PTR _Affinity$[ebp]
	test	eax, eax
	je	SHORT $LN5@KeQueryNod

; 811  :             Affinity->Group         = 0;

	xor	ecx, ecx

; 812  :             Affinity->Mask          = 0;

	and	DWORD PTR [eax], ecx
	mov	WORD PTR [eax+4], cx

; 813  :             Affinity->Reserved[0]   = 0;

	mov	WORD PTR [eax+6], cx

; 814  :             Affinity->Reserved[1]   = 0;

	mov	WORD PTR [eax+8], cx

; 815  :             Affinity->Reserved[2]   = 0;

	mov	WORD PTR [eax+10], cx
$LN5@KeQueryNod:

; 816  :         }
; 817  :         
; 818  :         if (Count != NULL)

	mov	eax, DWORD PTR _Count$[ebp]
	test	eax, eax
	je	SHORT $LN1@KeQueryNod

; 819  :             *Count= 0;    

	xor	ecx, ecx

; 820  :     }
; 821  : 
; 822  :     else {

	jmp	SHORT $LN9@KeQueryNod
$LN6@KeQueryNod:
	push	esi

; 823  :         if (Affinity != NULL) { 

	mov	esi, DWORD PTR _Affinity$[ebp]
	test	esi, esi
	je	SHORT $LN2@KeQueryNod

; 824  :             Affinity->Group         = 0;

	xor	eax, eax
	mov	WORD PTR [esi+4], ax

; 825  :             Affinity->Mask          = KeQueryActiveProcessors();

	call	DWORD PTR __imp__KeQueryActiveProcessors@0
	mov	DWORD PTR [esi], eax

; 826  :             Affinity->Reserved[0]   = 0;

	xor	eax, eax
	mov	WORD PTR [esi+6], ax

; 827  :             Affinity->Reserved[1]   = 0;

	mov	WORD PTR [esi+8], ax

; 828  :             Affinity->Reserved[2]   = 0;

	mov	WORD PTR [esi+10], ax
$LN2@KeQueryNod:

; 829  :         }
; 830  :         
; 831  :         if (Count != NULL)

	mov	eax, DWORD PTR _Count$[ebp]
	pop	esi
	test	eax, eax
	je	SHORT $LN1@KeQueryNod

; 832  :             *Count= KeNumberProcessors;

	mov	ecx, DWORD PTR __imp__KeNumberProcessors
	movsx	cx, BYTE PTR [ecx]
$LN9@KeQueryNod:
	mov	WORD PTR [eax], cx
$LN1@KeQueryNod:

; 833  :     }
; 834  : }

	pop	ebp
	ret	12					; 0000000cH
_KeQueryNodeActiveAffinity_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryGroupAffinity_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeQueryGroupAffinity_k8@4
_TEXT	SEGMENT
_GroupNumber$ = 8					; size = 2
_KeQueryGroupAffinity_k8@4 PROC				; COMDAT

; 840  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 841  :     if (GroupNumber != 0)

	cmp	WORD PTR _GroupNumber$[ebp], 0
	je	SHORT $LN1@KeQueryGro

; 842  :         return (KAFFINITY)0;

	xor	eax, eax
	jmp	SHORT $LN2@KeQueryGro
$LN1@KeQueryGro:

; 843  :     
; 844  :     return KeQueryActiveProcessors();    

	call	DWORD PTR __imp__KeQueryActiveProcessors@0
$LN2@KeQueryGro:

; 845  : }

	pop	ebp
	ret	4
_KeQueryGroupAffinity_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetAffinityInterrupt_k8@8
; Function compile flags: /Ogsp
;	COMDAT _IoGetAffinityInterrupt_k8@8
_TEXT	SEGMENT
_InterruptObject$ = 8					; size = 4
_GroupAffinity$ = 12					; size = 4
_IoGetAffinityInterrupt_k8@8 PROC			; COMDAT

; 852  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 853  :     GroupAffinity->Mask         = KeQueryActiveProcessors();

	call	DWORD PTR __imp__KeQueryActiveProcessors@0
	mov	ecx, DWORD PTR _GroupAffinity$[ebp]
	mov	DWORD PTR [ecx], eax

; 854  :     GroupAffinity->Group        = 0;

	xor	eax, eax
	mov	WORD PTR [ecx+4], ax

; 855  :     GroupAffinity->Reserved[0]  = 0;

	mov	WORD PTR [ecx+6], ax

; 856  :     GroupAffinity->Reserved[1]  = 0;

	mov	WORD PTR [ecx+8], ax

; 857  :     GroupAffinity->Reserved[2]  = 0;

	mov	WORD PTR [ecx+10], ax

; 858  :     
; 859  :     return STATUS_SUCCESS;    
; 860  : }

	pop	ebp
	ret	8
_IoGetAffinityInterrupt_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryLogicalProcessorRelationship_k8@16
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	_NtQuerySystemInformation@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeQueryLogicalProcessorRelationship_k8@16
_TEXT	SEGMENT
tv391 = -36						; size = 4
tv419 = -32						; size = 4
_ProcessorCoreMask$ = -28				; size = 4
_TotalCoresMask$ = -24					; size = 4
_ProcessorCore$32130 = -20				; size = 4
_Length$ = -20						; size = 4
_ProcessorFilter$ = -16					; size = 4
_PackageMask$ = -12					; size = 4
_Buffer$ = -12						; size = 4
_CollectedLength$ = -8					; size = 4
_TotalProcessors$ = -3					; size = 1
_SMT$ = -2						; size = 1
_LengthMode$ = -1					; size = 1
_i$32107 = 8						; size = 4
_pProcessorNumber$ = 8					; size = 4
_TotalCores$ = 11					; size = 1
_RelationshipType$ = 12					; size = 4
_Information$ = 16					; size = 4
_pLength$ = 20						; size = 4
_KeQueryLogicalProcessorRelationship_k8@16 PROC		; COMDAT

; 873  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi

; 874  :     #define     SizeofHeader    sizeof(LOGICAL_PROCESSOR_RELATIONSHIP) + \
; 875  :                                 sizeof(ULONG)
; 876  : 
; 877  :     ULONG       ProcessorFilter   = 0;

	xor	ebx, ebx

; 878  :     ULONG       CollectedLength   = 0;
; 879  :     BOOLEAN     LengthMode        = FALSE;
; 880  :     UCHAR       *Buffer;
; 881  :     ULONG       Length            = 0;
; 882  :     ULONG       Status;
; 883  :     //ULONG       ProcessorCore;
; 884  :     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX  NewEntry;
; 885  :     SYSTEM_LOGICAL_PROCESSOR_INFORMATION     *CurrentInfo;
; 886  :     KAFFINITY   Mask;
; 887  :     UCHAR       Flags;
; 888  :     UCHAR       TotalProcessors   = 0;
; 889  :     UCHAR       SMT               = 0;
; 890  :     UCHAR       TotalCores;
; 891  :     KAFFINITY   PackageMask;
; 892  :     KAFFINITY   ProcessorCoreMask = 1;
; 893  :     KAFFINITY   TotalCoresMask    = 0;
; 894  : 
; 895  :     Buffer = (UCHAR *) ExAllocatePoolWithTag( NonPagedPool, 65536 * sizeof(UCHAR), 200);

	mov	edi, 200				; 000000c8H
	push	edi
	mov	esi, 65536				; 00010000H
	push	esi
	push	ebx
	mov	DWORD PTR _ProcessorFilter$[ebp], ebx
	mov	DWORD PTR _CollectedLength$[ebp], ebx
	mov	BYTE PTR _LengthMode$[ebp], bl
	mov	DWORD PTR _Length$[ebp], ebx
	mov	BYTE PTR _TotalProcessors$[ebp], bl
	mov	BYTE PTR _SMT$[ebp], bl
	mov	DWORD PTR _ProcessorCoreMask$[ebp], 1
	mov	DWORD PTR _TotalCoresMask$[ebp], ebx
	call	DWORD PTR __imp__ExAllocatePoolWithTag@12

; 896  : 
; 897  :     //TODO: Bug in NtQuerySystemInformation, it never report SMT detection
; 898  :     Status = NtQuerySystemInformation( SystemLogicalProcessorInformation,
; 899  :                                      Buffer,
; 900  :                                      65536 * sizeof(UCHAR),
; 901  :                                      &Length);

	lea	ecx, DWORD PTR _Length$[ebp]
	push	ecx
	push	esi
	push	eax
	push	73					; 00000049H
	mov	DWORD PTR _Buffer$[ebp], eax
	call	_NtQuerySystemInformation@16

; 902  :     if (!Status) {

	test	eax, eax
	jne	SHORT $LN60@KeQueryLog

; 903  :         for (ULONG i = 0; i < Length/(ULONG)sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); i++)

	mov	eax, DWORD PTR _Length$[ebp]
	push	24					; 00000018H
	xor	edx, edx
	pop	ecx
	div	ecx
	cmp	eax, ebx
	jbe	SHORT $LN60@KeQueryLog
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, 8
$LL46@KeQueryLog:

; 904  :         {
; 905  :             CurrentInfo=(SYSTEM_LOGICAL_PROCESSOR_INFORMATION *) &Buffer[i * sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION)];
; 906  :             if (CurrentInfo->Relationship == RelationProcessorCore) {

	cmp	DWORD PTR [ecx-4], ebx
	jne	SHORT $LN45@KeQueryLog

; 907  :                 Mask  = CurrentInfo->ProcessorMask;

	mov	esi, DWORD PTR [ecx-8]

; 908  :                 Flags = CurrentInfo->ProcessorCore.Flags;
; 909  : 
; 910  :                 if (Flags)

	cmp	BYTE PTR [ecx], bl
	je	SHORT $LN42@KeQueryLog

; 911  :                         SMT++;

	inc	BYTE PTR _SMT$[ebp]
$LN42@KeQueryLog:

; 912  : 
; 913  :                 if (Mask)

	cmp	esi, ebx
	je	SHORT $LN45@KeQueryLog

; 914  :                         TotalProcessors++;

	inc	BYTE PTR _TotalProcessors$[ebp]
$LN45@KeQueryLog:

; 903  :         for (ULONG i = 0; i < Length/(ULONG)sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); i++)

	add	ecx, 24					; 00000018H
	dec	eax
	jne	SHORT $LL46@KeQueryLog
$LN60@KeQueryLog:

; 915  : 
; 916  :             }
; 917  :         }
; 918  :         
; 919  :     }
; 920  :     ExFreePoolWithTag(Buffer, 200);

	push	edi
	push	DWORD PTR _Buffer$[ebp]
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 921  :                 
; 922  :     if (SMT)

	xor	eax, eax
	cmp	BYTE PTR _SMT$[ebp], bl
	setne	al
	lea	eax, DWORD PTR [eax+eax+1]
	mov	DWORD PTR _PackageMask$[ebp], eax

; 923  :         PackageMask= (KAFFINITY)3;
; 924  :     else
; 925  :         PackageMask= (KAFFINITY)1;
; 926  : 
; 927  : 
; 928  :     if (Information == NULL) 

	cmp	DWORD PTR _Information$[ebp], ebx
	jne	SHORT $LN59@KeQueryLog

; 929  :         LengthMode = TRUE;

	mov	BYTE PTR _LengthMode$[ebp], 1
$LN59@KeQueryLog:

; 930  : 
; 931  :     if (pProcessorNumber != NULL) {

	mov	eax, DWORD PTR _pProcessorNumber$[ebp]
	cmp	eax, ebx
	je	SHORT $LN61@KeQueryLog

; 932  :         if (pProcessorNumber->Reserved != 0 ||
; 933  :             pProcessorNumber->Group    != 0 ||
; 934  :             pProcessorNumber->Number   >= 32 )

	cmp	BYTE PTR [eax+3], bl
	jne	SHORT $LN35@KeQueryLog
	cmp	WORD PTR [eax], bx
	jne	SHORT $LN35@KeQueryLog
	mov	al, BYTE PTR [eax+2]
	cmp	al, 32					; 00000020H
	jae	SHORT $LN35@KeQueryLog

; 936  :         else
; 937  :             ProcessorFilter=pProcessorNumber->Number;

	movzx	eax, al
	mov	DWORD PTR _ProcessorFilter$[ebp], eax
	jmp	SHORT $LN34@KeQueryLog
$LN35@KeQueryLog:

; 935  :             ProcessorFilter=INVALID_PROCESSOR_INDEX;

	or	DWORD PTR _ProcessorFilter$[ebp], -1
$LN34@KeQueryLog:

; 938  : 
; 939  :         if (ProcessorFilter >= (ULONG)KeNumberProcessors)

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]
	cmp	DWORD PTR _ProcessorFilter$[ebp], eax
	jb	SHORT $LN61@KeQueryLog

; 940  :             return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	$LN48@KeQueryLog
$LN61@KeQueryLog:

; 941  :     }
; 942  :  
; 943  : 
; 944  :     //TODO: Filter PROCESSOR_NUMBER
; 945  :     for (ULONG i = 0; i < TotalProcessors; i++) 

	movzx	eax, BYTE PTR _TotalProcessors$[ebp]
	mov	DWORD PTR _i$32107[ebp], ebx
	mov	DWORD PTR tv391[ebp], eax
	cmp	eax, ebx
	jbe	$LN72@KeQueryLog
	movzx	eax, BYTE PTR _SMT$[ebp]
	mov	DWORD PTR tv419[ebp], eax
$LL73@KeQueryLog:

; 946  :     {
; 947  :         if (i != 0) {    // skip first time

	cmp	DWORD PTR _i$32107[ebp], ebx
	je	SHORT $LN27@KeQueryLog

; 948  :             if (SMT)

	cmp	BYTE PTR _SMT$[ebp], bl
	je	SHORT $LN28@KeQueryLog

; 949  :                 PackageMask= PackageMask << 2;

	shl	DWORD PTR _PackageMask$[ebp], 2

; 950  :             else

	jmp	SHORT $LN27@KeQueryLog
$LN28@KeQueryLog:

; 951  :                 PackageMask= PackageMask << 1;

	shl	DWORD PTR _PackageMask$[ebp], 1
$LN27@KeQueryLog:

; 952  :         }
; 953  : 
; 954  :         if (
; 955  :              (RelationshipType == RelationProcessorPackage || RelationshipType == RelationAll) &&
; 956  :             ((ProcessorFilter  && ProcessorFilter == i)    || ProcessorFilter  == 0)    // filter anything but requested processor
; 957  :            )

	cmp	DWORD PTR _RelationshipType$[ebp], 3
	je	SHORT $LN67@KeQueryLog
	cmp	DWORD PTR _RelationshipType$[ebp], 65535 ; 0000ffffH
	jne	SHORT $LN74@KeQueryLog
$LN67@KeQueryLog:
	mov	eax, DWORD PTR _ProcessorFilter$[ebp]
	cmp	eax, ebx
	je	SHORT $LN24@KeQueryLog
	cmp	eax, DWORD PTR _i$32107[ebp]
	jne	SHORT $LN74@KeQueryLog
$LN24@KeQueryLog:

; 958  :         {
; 959  :              /* {
; 960  :                     BYTE            Flags;
; 961  :                     BYTE            Reserved[21];
; 962  :                     WORD            GroupCount;
; 963  :                     GROUP_AFFINITY  GroupMask[ANYSIZE_ARRAY];
; 964  :                 } PROCESSOR_RELATIONSHIP    */
; 965  : 
; 966  :             if (!LengthMode) {
; 967  :                 #define sizeof_ProcessorPackage (sizeof(PROCESSOR_RELATIONSHIP) + SizeofHeader)
; 968  :                 NewEntry = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
; 969  :                           ((UCHAR *)Information + CollectedLength);
; 970  :                 RtlZeroMemory(NewEntry, sizeof_ProcessorPackage);

	push	44					; 0000002cH
	pop	edi
	cmp	BYTE PTR _LengthMode$[ebp], bl
	jne	SHORT $LN22@KeQueryLog
	mov	eax, DWORD PTR _CollectedLength$[ebp]
	mov	ecx, DWORD PTR _Information$[ebp]
	push	edi
	lea	esi, DWORD PTR [eax+ecx]
	push	ebx
	push	esi
	call	_memset

; 971  : 
; 972  :                 NewEntry->Relationship          = RelationProcessorPackage;
; 973  :                 NewEntry->Size                  = sizeof_ProcessorPackage;
; 974  :                 NewEntry->Processor.Flags       = 0;
; 975  :                 NewEntry->Processor.Reserved[0] = 0;    // EfficiencyClass, win10 only
; 976  :                 NewEntry->Processor.GroupCount  = 1;

	xor	eax, eax
	inc	eax
	mov	WORD PTR [esi+30], ax

; 977  : 
; 978  :                 NewEntry->Processor.GroupMask[0].Mask        = PackageMask;

	mov	eax, DWORD PTR _PackageMask$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+32], eax

; 979  :                 NewEntry->Processor.GroupMask[0].Group       = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], 3
	mov	DWORD PTR [esi+4], edi
	mov	BYTE PTR [esi+8], bl
	mov	BYTE PTR [esi+9], bl
	mov	WORD PTR [esi+36], ax

; 980  :                 NewEntry->Processor.GroupMask[0].Reserved[0] = 0;

	mov	WORD PTR [esi+38], ax
$LN22@KeQueryLog:

; 981  :             }
; 982  :             
; 983  :             CollectedLength += sizeof_ProcessorPackage;

	add	DWORD PTR _CollectedLength$[ebp], edi
	jmp	SHORT $LN26@KeQueryLog
$LN74@KeQueryLog:
	push	44					; 0000002cH
	pop	edi
$LN26@KeQueryLog:

; 984  :         }
; 985  : 
; 986  :         for (ULONG ProcessorCore = 0; ProcessorCore <= SMT; ProcessorCore++)

	mov	eax, DWORD PTR _CollectedLength$[ebp]
	mov	ecx, DWORD PTR _Information$[ebp]
	mov	DWORD PTR _ProcessorCore$32130[ebp], ebx
	lea	esi, DWORD PTR [eax+ecx]
$LL21@KeQueryLog:

; 987  :         {
; 988  :             if (i != 0)             // skip first time

	cmp	DWORD PTR _i$32107[ebp], ebx
	je	SHORT $LN64@KeQueryLog

; 989  :              ProcessorCoreMask = ProcessorCoreMask << 1;

	shl	DWORD PTR _ProcessorCoreMask$[ebp], 1
$LN64@KeQueryLog:

; 990  : 
; 991  :             if (ProcessorFilter && ProcessorFilter != i)

	mov	eax, DWORD PTR _ProcessorFilter$[ebp]
	cmp	eax, ebx
	je	SHORT $LN17@KeQueryLog
	cmp	eax, DWORD PTR _i$32107[ebp]
	jne	$LN20@KeQueryLog
$LN17@KeQueryLog:

; 992  :             {
; 993  :                 continue;
; 994  :             }
; 995  : 
; 996  :             if (RelationshipType == RelationProcessorCore    || RelationshipType == RelationAll )

	cmp	DWORD PTR _RelationshipType$[ebp], ebx
	je	SHORT $LN15@KeQueryLog
	cmp	DWORD PTR _RelationshipType$[ebp], 65535 ; 0000ffffH
	jne	SHORT $LN16@KeQueryLog
$LN15@KeQueryLog:

; 997  :             {
; 998  :                 if (!LengthMode) {

	cmp	BYTE PTR _LengthMode$[ebp], bl
	jne	SHORT $LN14@KeQueryLog

; 999  :                     #define sizeof_ProcessorCore (sizeof(PROCESSOR_RELATIONSHIP) + SizeofHeader)
; 1000 :                     NewEntry = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
; 1001 :                               ((UCHAR *)Information + CollectedLength);
; 1002 :                     RtlZeroMemory(NewEntry, sizeof_ProcessorCore);

	push	edi
	push	ebx
	push	esi
	call	_memset

; 1003 : 
; 1004 :                     NewEntry->Relationship    = RelationProcessorCore;
; 1005 :                     NewEntry->Size            = sizeof_ProcessorCore;
; 1006 :                     // TODO: set Flags=LTP_PC_SMT if core has more than one logical processor
; 1007 :                     NewEntry->Processor.Flags       = 0;
; 1008 :                     NewEntry->Processor.Reserved[0] = 0;    // EfficiencyClass, win10 only
; 1009 :                     NewEntry->Processor.GroupCount  = 1;

	xor	eax, eax
	inc	eax
	mov	WORD PTR [esi+30], ax

; 1010 : 
; 1011 :                     NewEntry->Processor.GroupMask[0].Mask        = ProcessorCoreMask;

	mov	eax, DWORD PTR _ProcessorCoreMask$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+32], eax

; 1012 :                     NewEntry->Processor.GroupMask[0].Group       = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], edi
	mov	BYTE PTR [esi+8], bl
	mov	BYTE PTR [esi+9], bl
	mov	WORD PTR [esi+36], ax

; 1013 :                     NewEntry->Processor.GroupMask[0].Reserved[0] = 0;

	mov	WORD PTR [esi+38], ax
$LN14@KeQueryLog:

; 1014 :                 }
; 1015 :                 
; 1016 :                 CollectedLength += sizeof_ProcessorCore; 

	add	DWORD PTR _CollectedLength$[ebp], edi
	add	esi, edi
$LN16@KeQueryLog:

; 1017 :             }
; 1018 : 
; 1019 :             if (RelationshipType == RelationCache ||
; 1020 :                 RelationshipType == RelationAll   ||
; 1021 :                 ProcessorCore    == 0)   // show cache only on first thread

	cmp	DWORD PTR _RelationshipType$[ebp], 2
	je	SHORT $LN12@KeQueryLog
	cmp	DWORD PTR _RelationshipType$[ebp], 65535 ; 0000ffffH
	je	SHORT $LN12@KeQueryLog
	cmp	DWORD PTR _ProcessorCore$32130[ebp], ebx
	jne	SHORT $LN20@KeQueryLog
$LN12@KeQueryLog:

; 1022 :             {
; 1023 :                 /* {
; 1024 :                     BYTE                    Level;
; 1025 :                     BYTE                    Associativity;
; 1026 :                     WORD                    LineSize;
; 1027 :                     DWORD                   CacheSize;
; 1028 :                     PROCESSOR_CACHE_TYPE    Type;
; 1029 :                     BYTE                    Reserved[20];
; 1030 :                     GROUP_AFFINITY          GroupMask;
; 1031 :                 } CACHE_RELATIONSHIP */
; 1032 : 
; 1033 :                 if (!LengthMode) {

	cmp	BYTE PTR _LengthMode$[ebp], bl
	jne	SHORT $LN70@KeQueryLog

; 1034 :                     #define sizeof_Cache (sizeof(CACHE_RELATIONSHIP) + SizeofHeader)
; 1035 :                     NewEntry = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
; 1036 :                               ((UCHAR *)Information + CollectedLength);
; 1037 :                     RtlZeroMemory(NewEntry, sizeof_Cache);

	push	52					; 00000034H
	push	ebx
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 1038 : 
; 1039 :                     NewEntry->Relationship          = RelationCache;
; 1040 :                     NewEntry->Size                  = sizeof_Cache;
; 1041 :                     NewEntry->Cache.Level           = 1;  // L1 
; 1042 :                     NewEntry->Cache.Associativity   = 8;  // L1
; 1043 :                     NewEntry->Cache.LineSize        = 64;

	push	64					; 00000040H
	pop	eax
	mov	WORD PTR [esi+10], ax

; 1044 :                     NewEntry->Cache.CacheSize       = 16384;
; 1045 :                     NewEntry->Cache.Type            = CacheUnified;
; 1046 :                     NewEntry->Cache.Reserved[0]     = 0;
; 1047 : 
; 1048 :                     NewEntry->Cache.GroupMask.Mask          = PackageMask;

	mov	eax, DWORD PTR _PackageMask$[ebp]
	mov	DWORD PTR [esi+40], eax

; 1049 :                     NewEntry->Cache.GroupMask.Group         = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], 2
	mov	DWORD PTR [esi+4], 52			; 00000034H
	mov	BYTE PTR [esi+8], 1
	mov	BYTE PTR [esi+9], 8
	mov	DWORD PTR [esi+12], 16384		; 00004000H
	mov	DWORD PTR [esi+16], ebx
	mov	BYTE PTR [esi+20], bl
	mov	WORD PTR [esi+44], ax

; 1050 :                     NewEntry->Cache.GroupMask.Reserved[0]   = 0;

	mov	WORD PTR [esi+46], ax
$LN70@KeQueryLog:

; 1051 :                 }
; 1052 :                 
; 1053 :                 CollectedLength += sizeof_Cache;

	add	DWORD PTR _CollectedLength$[ebp], 52	; 00000034H
	add	esi, 52					; 00000034H
$LN20@KeQueryLog:
	inc	DWORD PTR _ProcessorCore$32130[ebp]
	mov	eax, DWORD PTR _ProcessorCore$32130[ebp]
	cmp	eax, DWORD PTR tv419[ebp]
	jbe	$LL21@KeQueryLog
	inc	DWORD PTR _i$32107[ebp]
	mov	eax, DWORD PTR _i$32107[ebp]
	cmp	eax, DWORD PTR tv391[ebp]
	jb	$LL73@KeQueryLog
$LN72@KeQueryLog:

; 1054 :             }
; 1055 :         }
; 1056 :     }
; 1057 : 
; 1058 :     TotalCores = TotalProcessors + TotalProcessors*SMT;

	mov	al, BYTE PTR _SMT$[ebp]
	inc	al
	imul	BYTE PTR _TotalProcessors$[ebp]
	mov	BYTE PTR _TotalCores$[ebp], al

; 1059 :     for (ULONG i = 0; i < TotalCores; i++)

	movzx	eax, al
	xor	ecx, ecx
	cmp	eax, ebx
	jbe	SHORT $LN8@KeQueryLog
$LL10@KeQueryLog:

; 1060 :     {
; 1061 :         TotalCoresMask =  TotalCoresMask | ((KAFFINITY)1 << i);

	xor	edx, edx
	inc	edx
	shl	edx, cl
	or	DWORD PTR _TotalCoresMask$[ebp], edx
	inc	ecx
	cmp	ecx, eax
	jb	SHORT $LL10@KeQueryLog
$LN8@KeQueryLog:

; 1062 :     }
; 1063 : 
; 1064 :     if (RelationshipType == RelationNumaNode || RelationshipType == RelationAll )

	cmp	DWORD PTR _RelationshipType$[ebp], 1
	je	SHORT $LN68@KeQueryLog
	cmp	DWORD PTR _RelationshipType$[ebp], 65535 ; 0000ffffH
	jne	SHORT $LN66@KeQueryLog
$LN68@KeQueryLog:

; 1065 :     {
; 1066 :         /* {
; 1067 :             ULONG        NodeNumber;
; 1068 :             UCHAR        Reserved[20];
; 1069 :             GROUP_AFFINITY    GroupMask;
; 1070 :            } NUMA_NODE_RELATIONSHIP
; 1071 :         */
; 1072 :         if (!LengthMode) {
; 1073 :             #define sizeof_Numa (sizeof(NUMA_NODE_RELATIONSHIP) + SizeofHeader)
; 1074 :             NewEntry = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
; 1075 :                       ((UCHAR *)Information + CollectedLength);

	mov	edi, DWORD PTR _CollectedLength$[ebp]
	cmp	BYTE PTR _LengthMode$[ebp], bl
	jne	SHORT $LN5@KeQueryLog
	mov	eax, DWORD PTR _Information$[ebp]

; 1076 :             RtlZeroMemory(NewEntry, sizeof_Numa);

	push	44					; 0000002cH
	lea	esi, DWORD PTR [edi+eax]
	push	ebx
	push	esi
	call	_memset

; 1077 : 
; 1078 :             NewEntry->Relationship          = RelationNumaNode;
; 1079 :             NewEntry->Size                  = sizeof_Numa;
; 1080 :             NewEntry->NumaNode.NodeNumber   = 0;
; 1081 :             NewEntry->NumaNode.Reserved[0]  = 0;
; 1082 : 
; 1083 :             NewEntry->NumaNode.GroupMask.Mask         = TotalCoresMask; 

	mov	eax, DWORD PTR _TotalCoresMask$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+32], eax

; 1084 :             NewEntry->NumaNode.GroupMask.Group        = 0;

	xor	eax, eax
	mov	DWORD PTR [esi], 1
	mov	DWORD PTR [esi+4], 44			; 0000002cH
	mov	DWORD PTR [esi+8], ebx
	mov	BYTE PTR [esi+12], bl
	mov	WORD PTR [esi+36], ax

; 1085 :             NewEntry->NumaNode.GroupMask.Reserved[0]  = 0;

	mov	WORD PTR [esi+38], ax
$LN5@KeQueryLog:

; 1086 :         }
; 1087 :         
; 1088 :         CollectedLength += sizeof_Numa;

	add	edi, 44					; 0000002cH
	jmp	SHORT $LN7@KeQueryLog
$LN66@KeQueryLog:
	mov	edi, DWORD PTR _CollectedLength$[ebp]
$LN7@KeQueryLog:

; 1089 :     }
; 1090 : 
; 1091 :     if ((RelationshipType == RelationGroup ||
; 1092 :          RelationshipType == RelationAll)  &&
; 1093 :         ProcessorFilter == 0) // skip groups if processor was filtered

	cmp	DWORD PTR _RelationshipType$[ebp], 4
	je	SHORT $LN3@KeQueryLog
	cmp	DWORD PTR _RelationshipType$[ebp], 65535 ; 0000ffffH
	jne	SHORT $LN4@KeQueryLog
$LN3@KeQueryLog:
	cmp	DWORD PTR _ProcessorFilter$[ebp], ebx
	jne	SHORT $LN4@KeQueryLog

; 1094 :     {
; 1095 :         /* {
; 1096 :             WORD                 MaximumGroupCount;
; 1097 :             WORD                 ActiveGroupCount;
; 1098 :             BYTE                 Reserved[20];
; 1099 :             PROCESSOR_GROUP_INFO GroupInfo[ANYSIZE_ARRAY];
; 1100 :         } GROUP_RELATIONSHIP,
; 1101 :         
; 1102 :           {
; 1103 :             BYTE  MaximumProcessorCount;
; 1104 :             BYTE  ActiveProcessorCount;
; 1105 :             BYTE  Reserved[38];
; 1106 :             KAFFINITY ActiveProcessorMask;
; 1107 :         } PROCESSOR_GROUP_INFO  */
; 1108 : 
; 1109 :         if (!LengthMode) {

	cmp	BYTE PTR _LengthMode$[ebp], bl
	jne	SHORT $LN69@KeQueryLog

; 1110 :             #define sizeof_Group (sizeof(GROUP_RELATIONSHIP) + SizeofHeader)
; 1111 :             NewEntry = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
; 1112 :                       ((UCHAR *)Information + CollectedLength);

	mov	eax, DWORD PTR _Information$[ebp]

; 1113 :             RtlZeroMemory(NewEntry, sizeof_Group);

	push	76					; 0000004cH
	lea	esi, DWORD PTR [edi+eax]
	push	ebx
	push	esi
	call	_memset

; 1114 :     
; 1115 :             NewEntry->Relationship              = RelationGroup;
; 1116 :             NewEntry->Size                      = sizeof_Group;
; 1117 :             NewEntry->Group.MaximumGroupCount   = 1;

	xor	eax, eax
	add	esp, 12					; 0000000cH
	inc	eax
	mov	WORD PTR [esi+8], ax

; 1118 :             NewEntry->Group.ActiveGroupCount    = 1;

	mov	WORD PTR [esi+10], ax

; 1119 :             NewEntry->Group.Reserved[0]         = 0;
; 1120 :             
; 1121 :             NewEntry->Group.GroupInfo[0].ActiveProcessorCount   = TotalCores;

	mov	al, BYTE PTR _TotalCores$[ebp]
	mov	BYTE PTR [esi+33], al

; 1122 :             NewEntry->Group.GroupInfo[0].MaximumProcessorCount  = TotalCores;

	mov	BYTE PTR [esi+32], al

; 1123 :             NewEntry->Group.GroupInfo[0].Reserved[0]            = 0;
; 1124 :             NewEntry->Group.GroupInfo[0].ActiveProcessorMask    = TotalCoresMask;

	mov	eax, DWORD PTR _TotalCoresMask$[ebp]
	mov	DWORD PTR [esi], 4
	mov	DWORD PTR [esi+4], 76			; 0000004cH
	mov	BYTE PTR [esi+12], bl
	mov	BYTE PTR [esi+34], bl
	mov	DWORD PTR [esi+72], eax
$LN69@KeQueryLog:

; 1125 :         }
; 1126 : 
; 1127 :         CollectedLength += sizeof_Group;

	add	edi, 76					; 0000004cH
$LN4@KeQueryLog:

; 1128 :     }
; 1129 :     
; 1130 :     if (LengthMode) {

	cmp	BYTE PTR _LengthMode$[ebp], bl
	je	SHORT $LN58@KeQueryLog
	mov	ebx, -1073741820			; c0000004H
$LN58@KeQueryLog:

; 1131 :         *pLength= CollectedLength;

	mov	eax, DWORD PTR _pLength$[ebp]
	mov	DWORD PTR [eax], edi

; 1132 :         return STATUS_INFO_LENGTH_MISMATCH; // Length Mode Status

	mov	eax, ebx
$LN48@KeQueryLog:
	pop	edi
	pop	esi
	pop	ebx

; 1133 :     }
; 1134 : 
; 1135 :     *pLength= CollectedLength;
; 1136 :     return STATUS_SUCCESS;    
; 1137 : }

	leave
	ret	16					; 00000010H
_KeQueryLogicalProcessorRelationship_k8@16 ENDP
_TEXT	ENDS
EXTRN	__imp__IoConnectInterrupt@44:PROC
; Function compile flags: /Ogsp
;	COMDAT _IoConnectInterruptEx_k8@4
_TEXT	SEGMENT
_Parameters$ = 8					; size = 4
_IoConnectInterruptEx_k8@4 PROC				; COMDAT

; 1147 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1148 :     if (Parameters->Version == CONNECT_FULLY_SPECIFIED  ||
; 1149 :         Parameters->Version == CONNECT_FULLY_SPECIFIED_GROUP) {

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax]
	xor	edx, edx
	inc	edx
	cmp	ecx, edx
	je	SHORT $LN4@IoConnectI
	cmp	ecx, 4
	je	SHORT $LN4@IoConnectI

; 1168 :     }
; 1169 :     else {
; 1170 :         Parameters->Version = CONNECT_FULLY_SPECIFIED;

	mov	DWORD PTR [eax], edx

; 1171 :         return STATUS_NOT_SUPPORTED;

	mov	eax, -1073741637			; c00000bbH
	jmp	SHORT $LN1@IoConnectI
$LN4@IoConnectI:

; 1150 :         
; 1151 :         if (Parameters->FullySpecified.PhysicalDeviceObject == NULL     ||
; 1152 :             Parameters->FullySpecified.ServiceRoutine       == NULL     ||
; 1153 :             Parameters->FullySpecified.SynchronizeIrql      < Parameters->FullySpecified.Irql)

	cmp	DWORD PTR [eax+4], 0
	push	esi
	je	SHORT $LN2@IoConnectI
	mov	esi, DWORD PTR [eax+12]
	test	esi, esi
	je	SHORT $LN2@IoConnectI
	mov	cl, BYTE PTR [eax+24]
	mov	dl, BYTE PTR [eax+32]
	cmp	cl, dl
	jb	SHORT $LN2@IoConnectI
	push	edi

; 1155 : 
; 1156 :         return IoConnectInterrupt(
; 1157 :                 Parameters->FullySpecified.InterruptObject,
; 1158 :                 Parameters->FullySpecified.ServiceRoutine,
; 1159 :                 Parameters->FullySpecified.ServiceContext,
; 1160 :                 Parameters->FullySpecified.SpinLock,
; 1161 :                 Parameters->FullySpecified.Vector,
; 1162 :                 Parameters->FullySpecified.Irql,
; 1163 :                 Parameters->FullySpecified.SynchronizeIrql,
; 1164 :                 Parameters->FullySpecified.InterruptMode,
; 1165 :                 Parameters->FullySpecified.ShareVector,
; 1166 :                 Parameters->FullySpecified.ProcessorEnableMask,
; 1167 :                 Parameters->FullySpecified.FloatingSave);

	movzx	edi, BYTE PTR [eax+25]
	push	edi
	push	DWORD PTR [eax+40]
	movzx	edi, BYTE PTR [eax+26]
	push	edi
	push	DWORD PTR [eax+36]
	push	ecx
	push	edx
	push	DWORD PTR [eax+28]
	push	DWORD PTR [eax+20]
	push	DWORD PTR [eax+16]
	push	esi
	push	DWORD PTR [eax+8]
	call	DWORD PTR __imp__IoConnectInterrupt@44
	pop	edi
	jmp	SHORT $LN8@IoConnectI
$LN2@IoConnectI:

; 1154 :             return STATUS_INVALID_PARAMETER;        

	mov	eax, -1073741811			; c000000dH
$LN8@IoConnectI:
	pop	esi
$LN1@IoConnectI:

; 1172 :         
; 1173 :     }
; 1174 : }

	pop	ebp
	ret	4
_IoConnectInterruptEx_k8@4 ENDP
_TEXT	ENDS
EXTRN	__imp__IoDisconnectInterrupt@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _IoDisconnectInterruptEx_k8@4
_TEXT	SEGMENT
_Parameters$ = 8					; size = 4
_IoDisconnectInterruptEx_k8@4 PROC			; COMDAT

; 1180 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1181 :     if (Parameters->Version == CONNECT_FULLY_SPECIFIED  ||
; 1182 :         Parameters->Version == CONNECT_FULLY_SPECIFIED_GROUP) 

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, 1
	je	SHORT $LN1@IoDisconne
	cmp	eax, 4
	jne	SHORT $LN2@IoDisconne
$LN1@IoDisconne:

; 1183 :         IoDisconnectInterrupt(Parameters->ConnectionContext.InterruptObject);

	push	DWORD PTR [ecx+4]
	call	DWORD PTR __imp__IoDisconnectInterrupt@4
$LN2@IoDisconne:

; 1184 : }

	pop	ebp
	ret	4
_IoDisconnectInterruptEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoGetSystemWake_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoGetSystemWake_k8@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_PoGetSystemWake_k8@4 PROC				; COMDAT

; 1191 :     return FALSE;

	xor	al, al

; 1192 : }

	ret	4
_PoGetSystemWake_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoSetSystemWake_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoSetSystemWake_k8@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_PoSetSystemWake_k8@4 PROC				; COMDAT

; 1199 : }

	ret	4
_PoSetSystemWake_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ObfReferenceObjectWithTag_k8@8
; Function compile flags: /Ogsp
;	COMDAT @ObfReferenceObjectWithTag_k8@8
_TEXT	SEGMENT
@ObfReferenceObjectWithTag_k8@8 PROC			; COMDAT
; _Object$ = ecx
; _Tag$ = edx

; 1207 :     return ObfReferenceObject(Object);

	jmp	DWORD PTR __imp_@ObfReferenceObject@4
@ObfReferenceObjectWithTag_k8@8 ENDP
_TEXT	ENDS
PUBLIC	@ObfDereferenceObjectWithTag_k8@8
; Function compile flags: /Ogsp
;	COMDAT @ObfDereferenceObjectWithTag_k8@8
_TEXT	SEGMENT
@ObfDereferenceObjectWithTag_k8@8 PROC			; COMDAT
; _Object$ = ecx
; _Tag$ = edx

; 1216 :     return ObfDereferenceObject(Object);

	jmp	DWORD PTR __imp_@ObfDereferenceObject@4
@ObfDereferenceObjectWithTag_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_PoRegisterPowerSettingCallback_k8@20
; Function compile flags: /Ogsp
;	COMDAT _PoRegisterPowerSettingCallback_k8@20
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_SettingGuid$ = 12					; size = 4
_Callback$ = 16						; size = 4
_Context$ = 20						; size = 4
_Handle$ = 24						; size = 4
_PoRegisterPowerSettingCallback_k8@20 PROC		; COMDAT

; 1228 :     return STATUS_SUCCESS;    

	xor	eax, eax

; 1229 : }

	ret	20					; 00000014H
_PoRegisterPowerSettingCallback_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_PoUnregisterPowerSettingCallback_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoUnregisterPowerSettingCallback_k8@4
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_PoUnregisterPowerSettingCallback_k8@4 PROC		; COMDAT

; 1236 :     return STATUS_SUCCESS;    

	xor	eax, eax

; 1237 : }

	ret	4
_PoUnregisterPowerSettingCallback_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_MmAllocateContiguousMemorySpecifyCacheNode_k8@36
EXTRN	__imp__MmAllocateContiguousMemorySpecifyCache@32:PROC
; Function compile flags: /Ogsp
;	COMDAT _MmAllocateContiguousMemorySpecifyCacheNode_k8@36
_TEXT	SEGMENT
_NumberOfBytes$ = 8					; size = 4
_LowestAcceptableAddress$ = 12				; size = 8
_HighestAcceptableAddress$ = 20				; size = 8
_BoundaryAddressMultiple$ = 28				; size = 8
_CacheType$ = 36					; size = 4
_PreferredNode$ = 40					; size = 4
_MmAllocateContiguousMemorySpecifyCacheNode_k8@36 PROC	; COMDAT

; 1250 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1251 :     return MmAllocateContiguousMemorySpecifyCache (
; 1252 :                 NumberOfBytes,
; 1253 :                 LowestAcceptableAddress,
; 1254 :                 HighestAcceptableAddress,
; 1255 :                 BoundaryAddressMultiple,
; 1256 :                 CacheType );

	push	DWORD PTR _CacheType$[ebp]
	push	DWORD PTR _BoundaryAddressMultiple$[ebp+4]
	push	DWORD PTR _BoundaryAddressMultiple$[ebp]
	push	DWORD PTR _HighestAcceptableAddress$[ebp+4]
	push	DWORD PTR _HighestAcceptableAddress$[ebp]
	push	DWORD PTR _LowestAcceptableAddress$[ebp+4]
	push	DWORD PTR _LowestAcceptableAddress$[ebp]
	push	DWORD PTR _NumberOfBytes$[ebp]
	call	DWORD PTR __imp__MmAllocateContiguousMemorySpecifyCache@32

; 1257 : }

	pop	ebp
	ret	36					; 00000024H
_MmAllocateContiguousMemorySpecifyCacheNode_k8@36 ENDP
_TEXT	ENDS
PUBLIC	_MmAllocateContiguousNodeMemory_k8@36
; Function compile flags: /Ogsp
;	COMDAT _MmAllocateContiguousNodeMemory_k8@36
_TEXT	SEGMENT
_NumberOfBytes$ = 8					; size = 4
_LowestAcceptableAddress$ = 12				; size = 8
_HighestAcceptableAddress$ = 20				; size = 8
_BoundaryAddressMultiple$ = 28				; size = 8
_Protect$ = 36						; size = 4
_PreferredNode$ = 40					; size = 4
_MmAllocateContiguousNodeMemory_k8@36 PROC		; COMDAT

; 1268 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1269 :     /*
; 1270 :     #define PAGE_NOACCESS            0x01
; 1271 :     #define PAGE_READONLY            0x02
; 1272 :     #define PAGE_READWRITE           0x04
; 1273 :     #define PAGE_WRITECOPY           0x08
; 1274 :     #define PAGE_EXECUTE             0x10
; 1275 :     #define PAGE_EXECUTE_READ        0x20
; 1276 :     #define PAGE_EXECUTE_READWRITE   0x40
; 1277 :     #define PAGE_EXECUTE_WRITECOPY   0x80
; 1278 :     #define PAGE_GUARD              0x100
; 1279 :     #define PAGE_NOCACHE            0x200
; 1280 :     #define PAGE_WRITECOMBINE       0x400
; 1281 : 
; 1282 :     0 MmNonCached = FALSE,
; 1283 :     1 MmCached = TRUE,
; 1284 :     2 MmWriteCombined = MmFrameBufferCached,
; 1285 :     3 MmHardwareCoherentCached,
; 1286 :     4 MmNonCachedUnordered,       // IA64
; 1287 :     5 MmUSWCCached,
; 1288 :     6 MmMaximumCacheType */
; 1289 :     
; 1290 :     MEMORY_CACHING_TYPE CacheType = MmCached;

	xor	eax, eax
	inc	eax

; 1291 : 
; 1292 :     if ( (Protect & PAGE_WRITECOMBINE) == PAGE_WRITECOMBINE )

	test	DWORD PTR _Protect$[ebp], 1024		; 00000400H
	je	SHORT $LN2@MmAllocate

; 1293 :         CacheType = MmWriteCombined;

	push	2
	pop	eax
$LN2@MmAllocate:

; 1294 :     
; 1295 :     if ( (Protect & PAGE_NOCACHE)      == PAGE_NOCACHE )

	test	DWORD PTR _Protect$[ebp], 512		; 00000200H
	je	SHORT $LN1@MmAllocate

; 1296 :         CacheType = MmNonCached;

	xor	eax, eax
$LN1@MmAllocate:

; 1297 :     
; 1298 :     return MmAllocateContiguousMemorySpecifyCache (
; 1299 :                 NumberOfBytes,
; 1300 :                 LowestAcceptableAddress,
; 1301 :                 HighestAcceptableAddress,
; 1302 :                 BoundaryAddressMultiple,
; 1303 :                 CacheType );

	push	eax
	push	DWORD PTR _BoundaryAddressMultiple$[ebp+4]
	push	DWORD PTR _BoundaryAddressMultiple$[ebp]
	push	DWORD PTR _HighestAcceptableAddress$[ebp+4]
	push	DWORD PTR _HighestAcceptableAddress$[ebp]
	push	DWORD PTR _LowestAcceptableAddress$[ebp+4]
	push	DWORD PTR _LowestAcceptableAddress$[ebp]
	push	DWORD PTR _NumberOfBytes$[ebp]
	call	DWORD PTR __imp__MmAllocateContiguousMemorySpecifyCache@32

; 1304 :     
; 1305 : }

	pop	ebp
	ret	36					; 00000024H
_MmAllocateContiguousNodeMemory_k8@36 ENDP
_TEXT	ENDS
PUBLIC	_DummyProc@0
; Function compile flags: /Ogsp
;	COMDAT _DummyProc@0
_TEXT	SEGMENT
_DummyProc@0 PROC					; COMDAT

; 1311 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1312 : }

	ret	0
_DummyProc@0 ENDP
_TEXT	ENDS
PUBLIC	_PoStartDeviceBusy_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoStartDeviceBusy_k8@4
_TEXT	SEGMENT
_IdlePointer$ = 8					; size = 4
_PoStartDeviceBusy_k8@4 PROC				; COMDAT

; 1318 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1319 :     PoSetDeviceBusy(IdlePointer);

	mov	eax, DWORD PTR _IdlePointer$[ebp]
	and	DWORD PTR [eax], 0

; 1320 : }

	pop	ebp
	ret	4
_PoStartDeviceBusy_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoEndDeviceBusy_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoEndDeviceBusy_k8@4
_TEXT	SEGMENT
_IdlePointer$ = 8					; size = 4
_PoEndDeviceBusy_k8@4 PROC				; COMDAT

; 1328 :     return;
; 1329 : }

	ret	4
_PoEndDeviceBusy_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoDisableSleepStates_k8@12
; Function compile flags: /Ogsp
;	COMDAT _PoDisableSleepStates_k8@12
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_PoDisableSleepStates_k8@12 PROC			; COMDAT

; 1335 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1336 : }

	ret	12					; 0000000cH
_PoDisableSleepStates_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_PoReenableSleepStates_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoReenableSleepStates_k8@4
_TEXT	SEGMENT
_a$ = 8							; size = 4
_PoReenableSleepStates_k8@4 PROC			; COMDAT

; 1342 :     ;
; 1343 : }

	ret	4
_PoReenableSleepStates_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_MmGetSystemRoutineAddress_inject@4
EXTRN	__imp__RtlEqualUnicodeString@12:PROC
EXTRN	__imp__MmGetSystemRoutineAddress@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _MmGetSystemRoutineAddress_inject@4
_TEXT	SEGMENT
_Address$ = -4						; size = 4
_SystemRoutineName$ = 8					; size = 4
_MmGetSystemRoutineAddress_inject@4 PROC		; COMDAT

; 1356 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1357 :     PVOID    Address = NULL;
; 1358 : 
; 1359 :     Address = MmGetSystemRoutineAddress(SystemRoutineName);

	push	DWORD PTR _SystemRoutineName$[ebp]
	call	DWORD PTR __imp__MmGetSystemRoutineAddress@4
	mov	DWORD PTR _Address$[ebp], eax

; 1360 :     if (Address == NULL) {

	test	eax, eax
	jne	SHORT $LN2@MmGetSyste
	push	ebx
	push	esi
	push	edi

; 1361 :         for (ULONG i = 0; i < ARRAYSIZE(RoutineAddressEnabled); i++) {

	xor	esi, esi
	mov	edi, OFFSET _RoutineAddressEnabled
	xor	ebx, ebx
$LL11@MmGetSyste:

; 1362 :             if (RtlEqualUnicodeString(
; 1363 :                     &RoutineAddressEnabled[i].RoutineName,
; 1364 :                     SystemRoutineName, FALSE)) {

	push	0
	push	DWORD PTR _SystemRoutineName$[ebp]
	push	edi
	call	DWORD PTR __imp__RtlEqualUnicodeString@12
	test	al, al
	jne	SHORT $LN9@MmGetSyste
	add	ebx, 12					; 0000000cH
	inc	esi
	add	edi, 12					; 0000000cH
	cmp	ebx, 24					; 00000018H
	jb	SHORT $LL11@MmGetSyste
	jmp	SHORT $LN12@MmGetSyste
$LN9@MmGetSyste:

; 1365 :                         Address = RoutineAddressEnabled[i].CallAddress;

	imul	esi, 12					; 0000000cH
	mov	eax, DWORD PTR _RoutineAddressEnabled[esi+8]
	mov	DWORD PTR _Address$[ebp], eax
$LN12@MmGetSyste:
	pop	edi
	pop	esi
	pop	ebx
$LN2@MmGetSyste:

; 1366 :                         break;
; 1367 :                     }
; 1368 :         }
; 1369 :     }
; 1370 : 
; 1371 :     return Address;

	mov	eax, DWORD PTR _Address$[ebp]

; 1372 : }

	leave
	ret	4
_MmGetSystemRoutineAddress_inject@4 ENDP
_TEXT	ENDS
PUBLIC	_LpcReplyWaitReplyPort_k8@12
; Function compile flags: /Ogsp
;	COMDAT _LpcReplyWaitReplyPort_k8@12
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_arg1$ = 12						; size = 4
_arg2$ = 16						; size = 4
_LpcReplyWaitReplyPort_k8@12 PROC			; COMDAT

; 1379 :     return STATUS_PORT_DISCONNECTED;

	mov	eax, -1073741769			; c0000037H

; 1380 : }

	ret	12					; 0000000cH
_LpcReplyWaitReplyPort_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_LpcSendWaitReceivePort_k8@28
; Function compile flags: /Ogsp
;	COMDAT _LpcSendWaitReceivePort_k8@28
_TEXT	SEGMENT
_arg0$ = 8						; size = 4
_arg1$ = 12						; size = 4
_arg2$ = 16						; size = 4
_arg3$ = 20						; size = 4
_arg4$ = 24						; size = 4
_arg5$ = 28						; size = 4
_arg6$ = 32						; size = 4
_LpcSendWaitReceivePort_k8@28 PROC			; COMDAT

; 1388 :     return STATUS_PORT_DISCONNECTED;

	mov	eax, -1073741769			; c0000037H

; 1389 : }

	ret	28					; 0000001cH
_LpcSendWaitReceivePort_k8@28 ENDP
_TEXT	ENDS
PUBLIC	_SeSetAuthorizationCallbacks_k8@8
; Function compile flags: /Ogsp
;	COMDAT _SeSetAuthorizationCallbacks_k8@8
_TEXT	SEGMENT
_Callback$ = 8						; size = 4
_Mode$ = 12						; size = 4
_SeSetAuthorizationCallbacks_k8@8 PROC			; COMDAT

; 1398 :     return STATUS_SUCCESS;    

	xor	eax, eax

; 1399 : }

	ret	8
_SeSetAuthorizationCallbacks_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_SeSetAuditParameter_k8@16
; Function compile flags: /Ogsp
;	COMDAT _SeSetAuditParameter_k8@16
_TEXT	SEGMENT
_AuditParameters$ = 8					; size = 4
_Type$ = 12						; size = 4
_Index$ = 16						; size = 4
_Data$ = 20						; size = 4
_SeSetAuditParameter_k8@16 PROC				; COMDAT

; 1409 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1410 : }

	ret	16					; 00000010H
_SeSetAuditParameter_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_SeReportSecurityEventWithSubCategory_k8@20
; Function compile flags: /Ogsp
;	COMDAT _SeReportSecurityEventWithSubCategory_k8@20
_TEXT	SEGMENT
_Flags$ = 8						; size = 4
_SourceName$ = 12					; size = 4
_UserSid$ = 16						; size = 4
_AuditParameters$ = 20					; size = 4
_AuditSubcategoryId$ = 24				; size = 4
_SeReportSecurityEventWithSubCategory_k8@20 PROC	; COMDAT

; 1421 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1422 : }

	ret	20					; 00000014H
_SeReportSecurityEventWithSubCategory_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_PcwRegister_k8@8
; Function compile flags: /Ogsp
;	COMDAT _PcwRegister_k8@8
_TEXT	SEGMENT
_Registration$ = 8					; size = 4
_Info$ = 12						; size = 4
_PcwRegister_k8@8 PROC					; COMDAT

; 1429 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1430 :     *Registration = NULL;

	mov	eax, DWORD PTR _Registration$[ebp]
	and	DWORD PTR [eax], 0

; 1431 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1432 : }

	pop	ebp
	ret	8
_PcwRegister_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_PcwUnregister_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PcwUnregister_k8@4
_TEXT	SEGMENT
_Registration$ = 8					; size = 4
_PcwUnregister_k8@4 PROC				; COMDAT

; 1439 :     return;
; 1440 : }

	ret	4
_PcwUnregister_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PcwCreateInstance_k8@20
; Function compile flags: /Ogsp
;	COMDAT _PcwCreateInstance_k8@20
_TEXT	SEGMENT
_Instance$ = 8						; size = 4
_Registration$ = 12					; size = 4
_Name$ = 16						; size = 4
_Count$ = 20						; size = 4
_Data$ = 24						; size = 4
_PcwCreateInstance_k8@20 PROC				; COMDAT

; 1450 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1451 :     *Instance = NULL;

	mov	eax, DWORD PTR _Instance$[ebp]
	and	DWORD PTR [eax], 0

; 1452 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1453 : }

	pop	ebp
	ret	20					; 00000014H
_PcwCreateInstance_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_PcwCloseInstance_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PcwCloseInstance_k8@4
_TEXT	SEGMENT
_Instance$ = 8						; size = 4
_PcwCloseInstance_k8@4 PROC				; COMDAT

; 1460 :     return;
; 1461 : }

	ret	4
_PcwCloseInstance_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PcwAddInstance_k8@20
; Function compile flags: /Ogsp
;	COMDAT _PcwAddInstance_k8@20
_TEXT	SEGMENT
_Buffer$ = 8						; size = 4
_Name$ = 12						; size = 4
_Id$ = 16						; size = 4
_Count$ = 20						; size = 4
_Data$ = 24						; size = 4
_PcwAddInstance_k8@20 PROC				; COMDAT

; 1472 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1473 : }

	ret	20					; 00000014H
_PcwAddInstance_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_IoUnregisterPlugPlayNotificationEx_k8@4
EXTRN	__imp__IoUnregisterPlugPlayNotification@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _IoUnregisterPlugPlayNotificationEx_k8@4
_TEXT	SEGMENT
_NotificationEntry$ = 8					; size = 4
_IoUnregisterPlugPlayNotificationEx_k8@4 PROC		; COMDAT

; 1479 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1481 : }

	pop	ebp

; 1480 :     return IoUnregisterPlugPlayNotification(NotificationEntry);

	jmp	DWORD PTR __imp__IoUnregisterPlugPlayNotification@4
_IoUnregisterPlugPlayNotificationEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_EmClientQueryRuleState_k8@8
; Function compile flags: /Ogsp
;	COMDAT _EmClientQueryRuleState_k8@8
_TEXT	SEGMENT
_RuleId$ = 8						; size = 4
_State$ = 12						; size = 4
_EmClientQueryRuleState_k8@8 PROC			; COMDAT

; 1489 : {   

	npad	2
	push	ebp
	mov	ebp, esp

; 1490 :     *State = STATE_UNKNOWN;

	mov	eax, DWORD PTR _State$[ebp]
	mov	DWORD PTR [eax], 1

; 1491 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1492 : }

	pop	ebp
	ret	8
_EmClientQueryRuleState_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_PoSetDeviceBusyEx_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoSetDeviceBusyEx_k8@4
_TEXT	SEGMENT
_IdlePointer$ = 8					; size = 4
_PoSetDeviceBusyEx_k8@4 PROC				; COMDAT

; 1498 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1499 :     PoSetDeviceBusy(IdlePointer);

	mov	eax, DWORD PTR _IdlePointer$[ebp]
	and	DWORD PTR [eax], 0

; 1500 : }

	pop	ebp
	ret	4
_PoSetDeviceBusyEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetIoPriorityHint_k8@4
; Function compile flags: /Ogsp
;	COMDAT _IoGetIoPriorityHint_k8@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_IoGetIoPriorityHint_k8@4 PROC				; COMDAT

; 1507 :     return IoPriorityNormal;

	push	2
	pop	eax

; 1508 : }

	ret	4
_IoGetIoPriorityHint_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_IoAllocateSfioStreamIdentifier_k8@16
; Function compile flags: /Ogsp
;	COMDAT _IoAllocateSfioStreamIdentifier_k8@16
_TEXT	SEGMENT
_FileObject$ = 8					; size = 4
_Length$ = 12						; size = 4
_Signature$ = 16					; size = 4
_StreamIdentifier$ = 20					; size = 4
_IoAllocateSfioStreamIdentifier_k8@16 PROC		; COMDAT

; 1518 :     // PVOID   *Buffer;
; 1519 :     // Buffer    = ExAllocatePoolWithTag(NonPagedPool, Length + 4*sizeof(ULONG_PTR), 'tSoI');
; 1520 :     // Buffer[0] = NULL;
; 1521 :     // Buffer[1] = NULL;
; 1522 :     // Buffer[2] = &Buffer[4];
; 1523 :     // Buffer[3] = Signature;
; 1524 :     // *StreamIdentifier = &Buffer[4];
; 1525 :     // return STATUS_SUCCESS;
; 1526 :     
; 1527 :     return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H

; 1528 : }

	ret	16					; 00000010H
_IoAllocateSfioStreamIdentifier_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_IoGetSfioStreamIdentifier_k8@8
; Function compile flags: /Ogsp
;	COMDAT _IoGetSfioStreamIdentifier_k8@8
_TEXT	SEGMENT
_FileObject$ = 8					; size = 4
_Signature$ = 12					; size = 4
_IoGetSfioStreamIdentifier_k8@8 PROC			; COMDAT

; 1536 :     return NULL;

	xor	eax, eax

; 1537 : }

	ret	8
_IoGetSfioStreamIdentifier_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_IoFreeSfioStreamIdentifier_k8@8
; Function compile flags: /Ogsp
;	COMDAT _IoFreeSfioStreamIdentifier_k8@8
_TEXT	SEGMENT
_FileObject$ = 8					; size = 4
_Signature$ = 12					; size = 4
_IoFreeSfioStreamIdentifier_k8@8 PROC			; COMDAT

; 1545 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1546 : }

	ret	8
_IoFreeSfioStreamIdentifier_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_Create_Process_Notify_Routine_XP@24
; Function compile flags: /Ogsp
;	COMDAT _Create_Process_Notify_Routine_XP@24
_TEXT	SEGMENT
_CreateInfo$ = -40					; size = 36
_i$32402 = -4						; size = 4
_ParentId$ = 8						; size = 4
_ProcessId$ = 12					; size = 4
_Create$ = 16						; size = 1
_ProcessExit$ = 20					; size = 4
_ProcessCreate$ = 24					; size = 4
_Thread$ = 28						; size = 4
_Create_Process_Notify_Routine_XP@24 PROC		; COMDAT

; 1563 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi

; 1564 : //                PspCreateThread x32 XP/2003
; 1565 : // EBX - ProcessCreate
; 1566 : // ESI - Thread
; 1567 : 
; 1568 : //                PspExitProcess  x32 XP/2003
; 1569 : // EDI - ProcessExit
; 1570 : 
; 1571 : //                PspCreateThread x64 XP
; 1572 : // R12 - Process
; 1573 : // [rsp+80h] - Thread
; 1574 : 
; 1575 : //                PspExitProcess  x64 XP
; 1576 : // RSI - ProcessExit
; 1577 : 
; 1578 : //                PspCreateThread x64 2003
; 1579 : // R12 - Process
; 1580 : // [rsp+80h] - Thread
; 1581 : 
; 1582 : //                PspExitProcess  x64 2003
; 1583 : // RSI - ProcessExit
; 1584 : 
; 1585 :     PS_CREATE_NOTIFY_INFO   CreateInfo;
; 1586 :     PFILE_OBJECT            FileObject;
; 1587 :     PCUNICODE_STRING        CommandLine;        
; 1588 :     PCUNICODE_STRING        ImageFileName;
; 1589 : 
; 1590 :     for (ULONG i = 0; i <= gLastEntry_CreateProcessNotifyEx; i++) {

	mov	esi, DWORD PTR _ProcessId$[ebp]
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR _ProcessCreate$[ebp]
	mov	DWORD PTR _i$32402[ebp], ebx
$LL7@Create_Pro:

; 1591 :         if (Array_CreateProcessNotifyEx[i].Routine ==  NULL) // skip empty entry

	mov	eax, DWORD PTR _i$32402[ebp]
	mov	ecx, DWORD PTR _Array_CreateProcessNotifyEx[eax*4]
	cmp	ecx, ebx
	je	SHORT $LN6@Create_Pro

; 1592 :                 continue;
; 1593 : 
; 1594 :         if (Create == FALSE)                                // exit process

	cmp	BYTE PTR _Create$[ebp], bl
	jne	SHORT $LN3@Create_Pro

; 1595 :                 Array_CreateProcessNotifyEx[i].Routine(
; 1596 :                                                 ProcessExit,
; 1597 :                                                 ProcessId,
; 1598 :                                                 NULL);

	push	ebx
	push	esi
	push	DWORD PTR _ProcessExit$[ebp]

; 1599 :         else {                                              // create thread/process

	jmp	SHORT $LN12@Create_Pro
$LN3@Create_Pro:

; 1600 :             CreateInfo.Size = sizeof(PS_CREATE_NOTIFY_INFO);
; 1601 :             CreateInfo.CreationStatus = 0;
; 1602 :             CreateInfo.Flags = 0;
; 1603 :             CreateInfo.ParentProcessId = ParentId;

	mov	eax, DWORD PTR _ParentId$[ebp]
	mov	DWORD PTR _CreateInfo$[ebp+8], eax

; 1604 :             CreateInfo.CreatingThreadId.UniqueProcess = ProcessId;
; 1605 :             CreateInfo.CreatingThreadId.UniqueThread = Thread->Cid.UniqueThread;

	mov	eax, DWORD PTR _Thread$[ebp]
	mov	eax, DWORD PTR [eax+488]
	mov	DWORD PTR _CreateInfo$[ebp+16], eax

; 1606 : 
; 1607 :             FileObject = ((PSECTION)ProcessCreate->SectionObject)->Segment->ControlArea->FilePointer;

	mov	eax, DWORD PTR [edi+292]
	mov	DWORD PTR _CreateInfo$[ebp+4], ebx
	mov	DWORD PTR _CreateInfo$[ebp], 36		; 00000024H
	mov	DWORD PTR _CreateInfo$[ebp+32], ebx
	mov	DWORD PTR _CreateInfo$[ebp+12], esi
	mov	eax, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+36]

; 1608 :             CreateInfo.FileObject = FileObject;

	mov	DWORD PTR _CreateInfo$[ebp+20], eax

; 1609 :             CreateInfo.ImageFileName = &FileObject->FileName;

	add	eax, 48					; 00000030H
	mov	DWORD PTR _CreateInfo$[ebp+24], eax

; 1610 :             CreateInfo.FileOpenNameAvailable = FALSE;   // or TRUE ?
; 1611 :             CreateInfo.CommandLine = NULL;
; 1612 : 
; 1613 :             Array_CreateProcessNotifyEx[i].Routine(
; 1614 :                                             ProcessCreate,
; 1615 :                                             ProcessId,
; 1616 :                                             &CreateInfo);

	lea	eax, DWORD PTR _CreateInfo$[ebp]
	push	eax
	push	esi
	mov	DWORD PTR _CreateInfo$[ebp+4], ebx
	mov	DWORD PTR _CreateInfo$[ebp+28], ebx
	push	edi
$LN12@Create_Pro:
	call	ecx
$LN6@Create_Pro:

; 1564 : //                PspCreateThread x32 XP/2003
; 1565 : // EBX - ProcessCreate
; 1566 : // ESI - Thread
; 1567 : 
; 1568 : //                PspExitProcess  x32 XP/2003
; 1569 : // EDI - ProcessExit
; 1570 : 
; 1571 : //                PspCreateThread x64 XP
; 1572 : // R12 - Process
; 1573 : // [rsp+80h] - Thread
; 1574 : 
; 1575 : //                PspExitProcess  x64 XP
; 1576 : // RSI - ProcessExit
; 1577 : 
; 1578 : //                PspCreateThread x64 2003
; 1579 : // R12 - Process
; 1580 : // [rsp+80h] - Thread
; 1581 : 
; 1582 : //                PspExitProcess  x64 2003
; 1583 : // RSI - ProcessExit
; 1584 : 
; 1585 :     PS_CREATE_NOTIFY_INFO   CreateInfo;
; 1586 :     PFILE_OBJECT            FileObject;
; 1587 :     PCUNICODE_STRING        CommandLine;        
; 1588 :     PCUNICODE_STRING        ImageFileName;
; 1589 : 
; 1590 :     for (ULONG i = 0; i <= gLastEntry_CreateProcessNotifyEx; i++) {

	inc	DWORD PTR _i$32402[ebp]
	mov	eax, DWORD PTR _i$32402[ebp]
	cmp	eax, DWORD PTR _gLastEntry_CreateProcessNotifyEx
	jbe	SHORT $LL7@Create_Pro
	pop	edi
	pop	esi
	pop	ebx

; 1617 : 
; 1618 :             if (CreateInfo.CreationStatus < 0)
; 1619 :             {
; 1620 :                 //TODO: PsTerminateProcess(ProcessCreate);
; 1621 :                 ;
; 1622 :             }
; 1623 : 
; 1624 :         }
; 1625 :     }
; 1626 : }

	leave
	ret	24					; 00000018H
_Create_Process_Notify_Routine_XP@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@FMAILBAG@ntoskrn8?3?5CreateProcessNotifyEx?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_PsSetCreateProcessNotifyRoutineEx_k8@8
EXTRN	__imp_@KeReleaseInStackQueuedSpinLock@4:PROC
EXTRN	__imp__KeBugCheckEx@20:PROC
EXTRN	_DbgPrint:PROC
EXTRN	__imp_@KeAcquireInStackQueuedSpinLock@8:PROC
;	COMDAT ??_C@_0CJ@FMAILBAG@ntoskrn8?3?5CreateProcessNotifyEx?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@FMAILBAG@ntoskrn8?3?5CreateProcessNotifyEx?5@FNODOBFM@ DB 'ntos'
	DB	'krn8: CreateProcessNotifyEx overflow', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _PsSetCreateProcessNotifyRoutineEx_k8@8
_TEXT	SEGMENT
_LockHandle$ = -12					; size = 12
_NotifyRoutine$ = 8					; size = 4
_Remove$ = 12						; size = 1
_PsSetCreateProcessNotifyRoutineEx_k8@8 PROC		; COMDAT

; 1633 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 1634 :     KLOCK_QUEUE_HANDLE  LockHandle;
; 1635 :     NTSTATUS            status = STATUS_SUCCESS;
; 1636 :     BOOLEAN             foundFreeEntry = FALSE;
; 1637 :     
; 1638 :     KeAcquireInStackQueuedSpinLock(&gSpin_CreateProcessNotifyEx, &LockHandle);

	lea	edx, DWORD PTR _LockHandle$[ebp]
	mov	ecx, OFFSET _gSpin_CreateProcessNotifyEx
	xor	ebx, ebx
	xor	edi, edi
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 1639 :     {
; 1640 :      if (Remove ==  FALSE) { // Add new callback

	cmp	BYTE PTR _Remove$[ebp], bl
	jne	SHORT $LN23@PsSetCreat

; 1641 :      
; 1642 :             // check for double
; 1643 :             FIND_DOUBLE_ENTRY_BEGIN (CreateProcessNotifyEx, Routine, NotifyRoutine) {

	mov	esi, DWORD PTR _NotifyRoutine$[ebp]
	mov	ecx, DWORD PTR _gLastEntry_CreateProcessNotifyEx
	xor	eax, eax
$LL22@PsSetCreat:
	cmp	DWORD PTR _Array_CreateProcessNotifyEx[eax*4], esi
	je	SHORT $LN30@PsSetCreat
	inc	eax
	cmp	eax, ecx
	jbe	SHORT $LL22@PsSetCreat

; 1649 :                 ADDENTRY_BEGIN (CreateProcessNotifyEx, Routine) {

	xor	eax, eax
$LL17@PsSetCreat:
	cmp	DWORD PTR _Array_CreateProcessNotifyEx[eax*4], ebx
	je	SHORT $LN31@PsSetCreat
	inc	eax
	cmp	eax, 256				; 00000100H
	jb	SHORT $LL17@PsSetCreat

; 1651 :                 }
; 1652 :                 ADDENTRY_END(CreateProcessNotifyEx, 0x3, NotifyRoutine, Remove)

	push	OFFSET ??_C@_0CJ@FMAILBAG@ntoskrn8?3?5CreateProcessNotifyEx?5@FNODOBFM@
	call	_DbgPrint
	pop	ecx
	push	ebx
	push	ebx
	push	esi
	push	3
	push	-559038737				; deadbeefH
	call	DWORD PTR __imp__KeBugCheckEx@20
$LN40@PsSetCreat:
$LN30@PsSetCreat:

; 1644 :                 status = STATUS_INVALID_PARAMETER;

	mov	edi, -1073741811			; c000000dH

; 1645 :             }
; 1646 :             FIND_DOUBLE_ENTRY_END()
; 1647 :             
; 1648 :             if (status != STATUS_INVALID_PARAMETER) {

	jmp	SHORT $LN2@PsSetCreat
$LN31@PsSetCreat:

; 1649 :                 ADDENTRY_BEGIN (CreateProcessNotifyEx, Routine) {

	cmp	eax, ecx
	jbe	SHORT $LN13@PsSetCreat
	mov	DWORD PTR _gLastEntry_CreateProcessNotifyEx, eax
$LN13@PsSetCreat:

; 1650 :                     Array_CreateProcessNotifyEx[iii].Routine = NotifyRoutine;

	mov	DWORD PTR _Array_CreateProcessNotifyEx[eax*4], esi

; 1651 :                 }
; 1652 :                 ADDENTRY_END(CreateProcessNotifyEx, 0x3, NotifyRoutine, Remove)

	jmp	SHORT $LN2@PsSetCreat
$LN23@PsSetCreat:

; 1653 :             }
; 1654 :      }
; 1655 :      else                   // remove callback & shrink CreateProcessNotifyExArray
; 1656 :          CLEANUP_ENTRY(Array_CreateProcessNotifyEx, Routine, NotifyRoutine, gLastEntry_CreateProcessNotifyEx)

	mov	eax, DWORD PTR _gLastEntry_CreateProcessNotifyEx
	xor	ecx, ecx
$LL10@PsSetCreat:
	mov	edx, DWORD PTR _Array_CreateProcessNotifyEx[ecx*4]
	cmp	edx, DWORD PTR _NotifyRoutine$[ebp]
	je	SHORT $LN32@PsSetCreat
	inc	ecx
	cmp	ecx, eax
	jbe	SHORT $LL10@PsSetCreat
	jmp	SHORT $LN2@PsSetCreat
$LN32@PsSetCreat:
	mov	DWORD PTR _Array_CreateProcessNotifyEx[ecx*4], ebx
	cmp	ecx, eax
	jne	SHORT $LN2@PsSetCreat
	cmp	eax, ebx
	jbe	SHORT $LN2@PsSetCreat
	dec	eax
	mov	DWORD PTR _gLastEntry_CreateProcessNotifyEx, eax
	je	SHORT $LN2@PsSetCreat
$LL5@PsSetCreat:
	cmp	DWORD PTR _Array_CreateProcessNotifyEx[eax*4], ebx
	jne	SHORT $LN2@PsSetCreat
	lea	ecx, DWORD PTR [eax-1]
	dec	eax
	mov	DWORD PTR _gLastEntry_CreateProcessNotifyEx, ecx
	jne	SHORT $LL5@PsSetCreat
$LN2@PsSetCreat:

; 1657 :     }
; 1658 :     KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 1659 :     
; 1660 :     return status; 

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1661 : }

	leave
	ret	8
$LN39@PsSetCreat:
_PsSetCreateProcessNotifyRoutineEx_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_RtlIsNtDdiVersionAvailable_k8@4
EXTRN	__imp__PsGetVersion@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _RtlIsNtDdiVersionAvailable_k8@4
_TEXT	SEGMENT
_MinorVersion$ = -8					; size = 4
_MajorVersion$ = -4					; size = 4
_Version$ = 8						; size = 4
_RtlIsNtDdiVersionAvailable_k8@4 PROC			; COMDAT

; 1685 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx

; 1686 :     ULONG MajorVersion;
; 1687 :     ULONG MinorVersion;
; 1688 : 
; 1689 :     if ((USHORT)Version != 0)

	xor	eax, eax
	cmp	WORD PTR _Version$[ebp], ax
	je	SHORT $LN4@RtlIsNtDdi

; 1690 :         return FALSE;

	xor	al, al
	jmp	SHORT $LN2@RtlIsNtDdi
$LN4@RtlIsNtDdi:

; 1691 :     else
; 1692 :     {
; 1693 :         PsGetVersion(
; 1694 :             &MajorVersion,
; 1695 :             &MinorVersion,
; 1696 :             0,              // BuildNumber,
; 1697 :             0);             // CSDVersion

	push	eax
	push	eax
	lea	eax, DWORD PTR _MinorVersion$[ebp]
	push	eax
	lea	eax, DWORD PTR _MajorVersion$[ebp]
	push	eax
	call	DWORD PTR __imp__PsGetVersion@16

; 1698 :            
; 1699 :         if (((MinorVersion + (MajorVersion << 8)) << 16) >= Version)

	mov	eax, DWORD PTR _MajorVersion$[ebp]
	shl	eax, 8
	add	eax, DWORD PTR _MinorVersion$[ebp]
	shl	eax, 16					; 00000010H
	cmp	eax, DWORD PTR _Version$[ebp]
	sbb	al, al
	inc	al
$LN2@RtlIsNtDdi:

; 1700 :             return TRUE;
; 1701 :         else
; 1702 :             return FALSE;
; 1703 :     }
; 1704 : }

	leave
	ret	4
_RtlIsNtDdiVersionAvailable_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ExGetFirmwareEnvironmentVariable_k8@20
; Function compile flags: /Ogsp
;	COMDAT _ExGetFirmwareEnvironmentVariable_k8@20
_TEXT	SEGMENT
_VariableName$ = 8					; size = 4
_VendorGuid$ = 12					; size = 4
_Value$ = 16						; size = 4
_ValueLength$ = 20					; size = 4
_Attributes$ = 24					; size = 4
_ExGetFirmwareEnvironmentVariable_k8@20 PROC		; COMDAT

; 1715 :     return STATUS_NOT_IMPLEMENTED;

	mov	eax, -1073741822			; c0000002H

; 1716 : }

	ret	20					; 00000014H
_ExGetFirmwareEnvironmentVariable_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_ExSetFirmwareEnvironmentVariable_k8@20
; Function compile flags: /Ogsp
;	COMDAT _ExSetFirmwareEnvironmentVariable_k8@20
_TEXT	SEGMENT
_VariableName$ = 8					; size = 4
_VendorGuid$ = 12					; size = 4
_Value$ = 16						; size = 4
_ValueLength$ = 20					; size = 4
_Attributes$ = 24					; size = 4
_ExSetFirmwareEnvironmentVariable_k8@20 PROC		; COMDAT

; 1727 :     return STATUS_NOT_IMPLEMENTED;

	mov	eax, -1073741822			; c0000002H

; 1728 : }    

	ret	20					; 00000014H
_ExSetFirmwareEnvironmentVariable_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_ZwQueryLicenseValue_k8@20
EXTRN	_memcpy:PROC
; Function compile flags: /Ogsp
;	COMDAT _ZwQueryLicenseValue_k8@20
_TEXT	SEGMENT
_name$ = 8						; size = 4
_result_type$ = 12					; size = 4
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_result_len$ = 24					; size = 4
_ZwQueryLicenseValue_k8@20 PROC				; COMDAT

; 1774 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1775 :     BOOLEAN found=FALSE;
; 1776 :     ULONG   Type, Length ;
; 1777 :     UCHAR   *Value;
; 1778 :     
; 1779 :     if (!name || !name->Buffer || !name->Length || !result_len)

	mov	esi, DWORD PTR _name$[ebp]
	xor	ebx, ebx
	push	edi
	cmp	esi, ebx
	je	SHORT $LN9@ZwQueryLic
	cmp	DWORD PTR [esi+4], ebx
	je	SHORT $LN9@ZwQueryLic
	cmp	WORD PTR [esi], bx
	je	SHORT $LN9@ZwQueryLic
	cmp	DWORD PTR _result_len$[ebp], ebx
	je	SHORT $LN9@ZwQueryLic

; 1781 :     
; 1782 :     for (ULONG i = 0; i < ARRAYSIZE(LicenseValueArray); i++) {

	mov	edi, OFFSET _LicenseValueArray
$LL17@ZwQueryLic:

; 1783 :         if (RtlEqualUnicodeString( &LicenseValueArray[i].Name, name, FALSE)) {

	push	0
	push	esi
	push	edi
	call	DWORD PTR __imp__RtlEqualUnicodeString@12
	test	al, al
	jne	SHORT $LN14@ZwQueryLic
	inc	ebx
	add	edi, 32					; 00000020H
	cmp	ebx, 12					; 0000000cH
	jb	SHORT $LL17@ZwQueryLic

; 1784 :             found=  TRUE;
; 1785 :             Type=            LicenseValueArray[i].Type;
; 1786 :             Length=          LicenseValueArray[i].Length;
; 1787 :             Value=  (UCHAR *)LicenseValueArray[i].Value;
; 1788 :             break;
; 1789 :         }
; 1790 :     } 
; 1791 :     
; 1792 :     if (found == FALSE)
; 1793 :         return STATUS_OBJECT_NAME_NOT_FOUND;

	mov	eax, -1073741772			; c0000034H
	jmp	SHORT $LN11@ZwQueryLic
$LN14@ZwQueryLic:

; 1794 :     
; 1795 :     if (result_type)

	mov	esi, DWORD PTR _result_type$[ebp]
	mov	eax, ebx
	shl	eax, 5
	mov	edx, DWORD PTR _LicenseValueArray[eax+8]
	mov	ecx, DWORD PTR _LicenseValueArray[eax+12]
	lea	eax, DWORD PTR _LicenseValueArray[eax+16]
	test	esi, esi
	je	SHORT $LN3@ZwQueryLic

; 1796 :         *result_type = Type;

	mov	DWORD PTR [esi], edx
$LN3@ZwQueryLic:

; 1797 :             
; 1798 :     *result_len = Length;              

	mov	edx, DWORD PTR _result_len$[ebp]
	mov	DWORD PTR [edx], ecx

; 1799 :  
; 1800 :     if (length < Length)

	cmp	DWORD PTR _length$[ebp], ecx
	jae	SHORT $LN2@ZwQueryLic

; 1801 :         return STATUS_BUFFER_TOO_SMALL;

	mov	eax, -1073741789			; c0000023H
	jmp	SHORT $LN11@ZwQueryLic
$LN2@ZwQueryLic:

; 1802 :     
; 1803 :     if (data)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN1@ZwQueryLic

; 1804 :         RtlCopyMemory(data, Value, Length); 

	push	ecx
	push	eax
	push	DWORD PTR _data$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@ZwQueryLic:

; 1805 :         
; 1806 :     return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN11@ZwQueryLic
$LN9@ZwQueryLic:

; 1780 :         return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
$LN11@ZwQueryLic:
	pop	edi
	pop	esi
	pop	ebx

; 1807 : }

	pop	ebp
	ret	20					; 00000014H
_ZwQueryLicenseValue_k8@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09JAJJNGHD@CSRSS?4EXE?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_PsIsProtectedProcess_k8@4
EXTRN	__imp___stricmp:PROC
;	COMDAT ??_C@_09JAJJNGHD@CSRSS?4EXE?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_09JAJJNGHD@CSRSS?4EXE?$AA@FNODOBFM@ DB 'CSRSS.EXE', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _PsIsProtectedProcess_k8@4
_TEXT	SEGMENT
_Process$ = 8						; size = 4
_PsIsProtectedProcess_k8@4 PROC				; COMDAT

; 1812 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1813 :     const char *pszImageFile = (const char *)Process->ImageFileName;

	mov	eax, DWORD PTR _Process$[ebp]
	add	eax, 356				; 00000164H

; 1814 :     if (!pszImageFile)

	jne	SHORT $LN2@PsIsProtec

; 1815 :         return FALSE;

	xor	al, al
	jmp	SHORT $LN1@PsIsProtec
$LN2@PsIsProtec:

; 1816 : 
; 1817 :     if (!_stricmp(pszImageFile, "CSRSS.EXE"))

	push	OFFSET ??_C@_09JAJJNGHD@CSRSS?4EXE?$AA@FNODOBFM@
	push	eax
	call	DWORD PTR __imp___stricmp
	neg	eax
	pop	ecx
	sbb	al, al
	pop	ecx
	inc	al
$LN1@PsIsProtec:

; 1818 :         return TRUE;
; 1819 :     
; 1820 :     return FALSE;
; 1821 : }

	pop	ebp
	ret	4
_PsIsProtectedProcess_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ZwAllocateLocallyUniqueId_k8@4
EXTRN	_NtAllocateLocallyUniqueId@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _ZwAllocateLocallyUniqueId_k8@4
_TEXT	SEGMENT
_Luid$ = 8						; size = 4
_ZwAllocateLocallyUniqueId_k8@4 PROC			; COMDAT

; 1826 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1828 : }

	pop	ebp

; 1827 :     return NtAllocateLocallyUniqueId(Luid);

	jmp	_NtAllocateLocallyUniqueId@4
_ZwAllocateLocallyUniqueId_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeSetActualBasePriorityThread_k8@8
EXTRN	__imp__KeSetPriorityThread@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeSetActualBasePriorityThread_k8@8
_TEXT	SEGMENT
_Thread$ = 8						; size = 4
_Priority$ = 12						; size = 4
_KeSetActualBasePriorityThread_k8@8 PROC		; COMDAT

; 1835 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1836 :     KPRIORITY PrevBasePriority= Thread->BasePriority;

	mov	ecx, DWORD PTR _Thread$[ebp]

; 1837 :     
; 1838 :     Thread->BasePriority=(SCHAR)Priority;

	mov	edx, DWORD PTR _Priority$[ebp]
	lea	eax, DWORD PTR [ecx+289]
	push	esi
	movsx	esi, BYTE PTR [eax]
	mov	BYTE PTR [eax], dl

; 1839 :     
; 1840 :     if (Thread->Priority != (SCHAR)Priority) {

	cmp	BYTE PTR [ecx+91], dl
	je	SHORT $LN1@KeSetActua

; 1841 :         KeSetPriorityThread(Thread, Priority);

	push	edx
	push	ecx
	call	DWORD PTR __imp__KeSetPriorityThread@8
$LN1@KeSetActua:

; 1842 :     }
; 1843 :     
; 1844 :     return PrevBasePriority;

	mov	eax, esi
	pop	esi

; 1845 : }

	pop	ebp
	ret	8
_KeSetActualBasePriorityThread_k8@8 ENDP
_TEXT	ENDS
PUBLIC	@KeInvalidateRangeAllCaches_k8@8
EXTRN	_KeInvalidateAllCaches_k8@0:PROC
EXTRN	_CPUID@20:PROC
; Function compile flags: /Ogsp
;	COMDAT @KeInvalidateRangeAllCaches_k8@8
_TEXT	SEGMENT
_OutEax$ = -16						; size = 4
_OutEcx$ = -12						; size = 4
_OutEbx$ = -8						; size = 4
_OutEdx$ = -4						; size = 4
@KeInvalidateRangeAllCaches_k8@8 PROC			; COMDAT
; _BaseAddress$ = ecx
; _Length$ = edx

; 1852 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi

; 1853 :     CHAR  *Addr;
; 1854 :     CHAR  *EndAddr;
; 1855 :     ULONG  IncAddr;
; 1856 :     // IncAddr = [PEB+3BCh];
; 1857 :     // cache line size=  (bits 8-15 of EBX CPUID(EAX=1)
; 1858 :     // shr     ebx, 5
; 1859 :     // and     ebx, 11111111000b
; 1860 :     
; 1861 :     ULONG OutEax,OutEbx,OutEcx,OutEdx;
; 1862 :     CPU_INFO CPU_Info;
; 1863 :     
; 1864 :     #if defined(_X86_)  // x32
; 1865 :         CPUID(1, &OutEax, &OutEbx, &OutEcx, &OutEdx);

	lea	eax, DWORD PTR _OutEdx$[ebp]
	push	eax
	lea	eax, DWORD PTR _OutEcx$[ebp]
	push	eax
	lea	eax, DWORD PTR _OutEbx$[ebp]
	push	eax
	lea	eax, DWORD PTR _OutEax$[ebp]
	push	eax
	push	1
	mov	edi, edx
	mov	esi, ecx
	call	_CPUID@20

; 1866 :     #else               // x64
; 1867 :         KiCpuId(0x1, 0, &CPU_Info);
; 1868 :         OutEax=CPU_Info.Eax;
; 1869 :         OutEbx=CPU_Info.Ebx;
; 1870 :         OutEcx=CPU_Info.Ecx;
; 1871 :         OutEdx=CPU_Info.Edx;
; 1872 :     #endif
; 1873 :     
; 1874 :     if ( (OutEdx & (1L < 19)) == 1) {    //clflush features if CPUID.01H:EDX[bit 19]=1

	test	BYTE PTR _OutEdx$[ebp], 1
	je	SHORT $LN4@

; 1875 :         Addr    = BaseAddress;
; 1876 :         IncAddr = (OutEbx >> 5) & 0x07F8UL;  // OutEbx= CacheLine Size, 11111111000b

	mov	eax, DWORD PTR _OutEbx$[ebp]
	shr	eax, 5

; 1877 :         EndAddr = BaseAddress + Length - 1;

	lea	ecx, DWORD PTR [esi+edi-1]
	and	eax, 2040				; 000007f8H
	mov	edx, esi

; 1878 :         while (Addr <= EndAddr )

	cmp	esi, ecx
	ja	SHORT $LN1@
$LL3@:

; 1879 :         {
; 1880 :             _mm_clflush(Addr);

	clflush	DWORD PTR [edx]

; 1881 :             Addr += IncAddr;

	add	edx, eax
	cmp	edx, ecx
	jbe	SHORT $LL3@

; 1882 :         }
; 1883 :     }
; 1884 :     else {

	jmp	SHORT $LN1@
$LN4@:

; 1885 :         KeInvalidateAllCaches_k8();

	call	_KeInvalidateAllCaches_k8@0
$LN1@:
	pop	edi
	pop	esi

; 1886 :     }
; 1887 :     
; 1888 : }

	leave
	ret	0
@KeInvalidateRangeAllCaches_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_ExAllocatePoolEx@16
; Function compile flags: /Ogsp
;	COMDAT _ExAllocatePoolEx@16
_TEXT	SEGMENT
_PoolType$ = 8						; size = 4
_NumberOfBytes$ = 12					; size = 4
_Tag$ = 16						; size = 4
_Lookaside$ = 20					; size = 4
_ExAllocatePoolEx@16 PROC				; COMDAT

; 1897 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1898 :     return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);

	push	DWORD PTR _Tag$[ebp]
	push	DWORD PTR _NumberOfBytes$[ebp]
	push	DWORD PTR _PoolType$[ebp]
	call	DWORD PTR __imp__ExAllocatePoolWithTag@12

; 1899 : }

	pop	ebp
	ret	16					; 00000010H
_ExAllocatePoolEx@16 ENDP
_TEXT	ENDS
PUBLIC	_ExFreePoolEx@8
; Function compile flags: /Ogsp
;	COMDAT _ExFreePoolEx@8
_TEXT	SEGMENT
_Buffer$ = 8						; size = 4
_Lookaside$ = 12					; size = 4
_ExFreePoolEx@8 PROC					; COMDAT

; 1906 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1907 :     ExFreePoolWithTag(Buffer, 0);

	push	0
	push	DWORD PTR _Buffer$[ebp]
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 1908 : }

	pop	ebp
	ret	8
_ExFreePoolEx@8 ENDP
_TEXT	ENDS
PUBLIC	_ExInitializeLookasideListEx_k8@32
EXTRN	__imp__ExInitializeNPagedLookasideList@28:PROC
EXTRN	__imp__ExInitializePagedLookasideList@28:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExInitializeLookasideListEx_k8@32
_TEXT	SEGMENT
_LookasideEx$ = 8					; size = 4
_AllocateEx$ = 12					; size = 4
_FreeEx$ = 16						; size = 4
_PoolType$ = 20						; size = 4
_Flags$ = 24						; size = 4
_Size$ = 28						; size = 4
_Tag$ = 32						; size = 4
_Depth$ = 36						; size = 2
_ExInitializeLookasideListEx_k8@32 PROC			; COMDAT

; 1921 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1922 :     PALLOCATE_FUNCTION  AllocateExFunc = (PALLOCATE_FUNCTION) AllocateEx;
; 1923 :     PFREE_FUNCTION      FreeExFunc     = (PFREE_FUNCTION)     FreeEx;
; 1924 :     KLOCK_QUEUE_HANDLE  LockHandle;
; 1925 :     BOOLEAN             foundFreeEntry = FALSE;
; 1926 :         
; 1927 :     if (PoolType & 0xFFFFFE18L || (PoolType & 3) == 3 ) // 11111111111111111111111000011000

	test	DWORD PTR _PoolType$[ebp], -488		; fffffe18H
	mov	ecx, DWORD PTR _FreeEx$[ebp]
	push	esi
	mov	esi, DWORD PTR _AllocateEx$[ebp]
	jne	SHORT $LN6@ExInitiali
	mov	eax, DWORD PTR _PoolType$[ebp]
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN6@ExInitiali

; 1929 :     
; 1930 :     if (Size <= 4)

	mov	eax, DWORD PTR _Size$[ebp]
	cmp	eax, 4
	ja	SHORT $LN5@ExInitiali

; 1931 :             Size = 4;

	push	4
	pop	eax
$LN5@ExInitiali:

; 1932 :     
; 1933 :     if (AllocateExFunc == NULL)

	test	esi, esi
	jne	SHORT $LN4@ExInitiali

; 1934 :             AllocateExFunc= (PALLOCATE_FUNCTION) ExAllocatePoolEx;

	mov	esi, OFFSET _ExAllocatePoolEx@16
$LN4@ExInitiali:

; 1935 :           
; 1936 :     if (FreeExFunc == NULL)

	test	ecx, ecx
	jne	SHORT $LN3@ExInitiali

; 1937 :             FreeExFunc= (PFREE_FUNCTION) ExFreePoolEx;

	mov	ecx, OFFSET _ExFreePoolEx@8
$LN3@ExInitiali:

; 1938 : 
; 1939 : /*
; 1940 :         Flags &= 1; // XP support only pool allocation flag
; 1941 :         ADDENTRY_BEGIN (LookasideListEx, LookasideEx) {
; 1942 :             Array_LookasideListEx[iii].AllocateEx= AllocateEx;
; 1943 :             Array_LookasideListEx[iii].FreeEx =    FreeEx;
; 1944 :             Array_LookasideListEx[iii].LookasideEx = LookasideEx;
; 1945 :         }
; 1946 :         ADDENTRY_END(LookasideListEx, 0x4, LookasideEx, Size)
; 1947 :             
; 1948 :     }
; 1949 : */
; 1950 :     
; 1951 :     if (PoolType & 1) {                         // PagedPool

	test	BYTE PTR _PoolType$[ebp], 1

; 1952 :         ExInitializePagedLookasideList(
; 1953 :            (PPAGED_LOOKASIDE_LIST)  LookasideEx,
; 1954 :                                     AllocateExFunc,
; 1955 :                                     FreeExFunc,
; 1956 :                                     Flags,
; 1957 :                                     Size,
; 1958 :                                     Tag,
; 1959 :                                     Depth );

	push	DWORD PTR _Depth$[ebp]
	push	DWORD PTR _Tag$[ebp]
	push	eax
	push	DWORD PTR _Flags$[ebp]
	push	ecx
	push	esi
	push	DWORD PTR _LookasideEx$[ebp]
	je	SHORT $LN2@ExInitiali
	call	DWORD PTR __imp__ExInitializePagedLookasideList@28

; 1960 :     }
; 1961 :     else {                                      // NonPagedPool

	jmp	SHORT $LN1@ExInitiali
$LN2@ExInitiali:

; 1962 :         ExInitializeNPagedLookasideList(
; 1963 :            (PNPAGED_LOOKASIDE_LIST) LookasideEx,
; 1964 :                                     AllocateExFunc,
; 1965 :                                     FreeExFunc,
; 1966 :                                     Flags,
; 1967 :                                     Size,
; 1968 :                                     Tag,
; 1969 :                                     Depth );

	call	DWORD PTR __imp__ExInitializeNPagedLookasideList@28
$LN1@ExInitiali:

; 1970 :     }
; 1971 :     
; 1972 :     return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN8@ExInitiali
$LN6@ExInitiali:

; 1928 :           return STATUS_INVALID_PARAMETER_4;

	mov	eax, -1073741582			; c00000f2H
$LN8@ExInitiali:
	pop	esi

; 1973 : }

	pop	ebp
	ret	32					; 00000020H
_ExInitializeLookasideListEx_k8@32 ENDP
_TEXT	ENDS
PUBLIC	_ExDeleteLookasideListEx_k8@4
EXTRN	__imp__ExDeleteNPagedLookasideList@4:PROC
EXTRN	__imp__ExDeletePagedLookasideList@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExDeleteLookasideListEx_k8@4
_TEXT	SEGMENT
_Lookaside$ = 8						; size = 4
_ExDeleteLookasideListEx_k8@4 PROC			; COMDAT

; 1979 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1980 :     if (Lookaside->L.Type & 1) {                  // PagedPool

	mov	eax, DWORD PTR _Lookaside$[ebp]
	test	BYTE PTR [eax+28], 1

; 1981 :       ExDeletePagedLookasideList( (PPAGED_LOOKASIDE_LIST) Lookaside);

	push	eax
	je	SHORT $LN2@ExDeleteLo
	call	DWORD PTR __imp__ExDeletePagedLookasideList@4

; 1982 :     }
; 1983 :     else {                                      // NonPagedPool     

	jmp	SHORT $LN1@ExDeleteLo
$LN2@ExDeleteLo:

; 1984 :       ExDeleteNPagedLookasideList((PNPAGED_LOOKASIDE_LIST) Lookaside);

	call	DWORD PTR __imp__ExDeleteNPagedLookasideList@4
$LN1@ExDeleteLo:

; 1985 :     }
; 1986 :         
; 1987 : }

	pop	ebp
	ret	4
_ExDeleteLookasideListEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlQueryElevationFlags_k8@4
; Function compile flags: /Ogsp
;	COMDAT _RtlQueryElevationFlags_k8@4
_TEXT	SEGMENT
_Result$ = 8						; size = 4
_RtlQueryElevationFlags_k8@4 PROC			; COMDAT

; 1992 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1993 :     *Result=0;

	mov	eax, DWORD PTR _Result$[ebp]
	and	DWORD PTR [eax], 0

; 1994 :     return STATUS_SUCCESS;

	xor	eax, eax

; 1995 : }

	pop	ebp
	ret	4
_RtlQueryElevationFlags_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PsEnterPriorityRegion_k8@0
; Function compile flags: /Ogsp
;	COMDAT _PsEnterPriorityRegion_k8@0
_TEXT	SEGMENT
_PsEnterPriorityRegion_k8@0 PROC			; COMDAT

; 2001 :     ;
; 2002 : }

	ret	0
_PsEnterPriorityRegion_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_PsLeavePriorityRegion_k8@0
; Function compile flags: /Ogsp
;	COMDAT _PsLeavePriorityRegion_k8@0
_TEXT	SEGMENT
_PsLeavePriorityRegion_k8@0 PROC			; COMDAT

; 2008 :     ;
; 2009 : }

	ret	0
_PsLeavePriorityRegion_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_ExEnterPriorityRegionAndAcquireResourceExclusive_k8@4
EXTRN	_ExEnterCriticalRegionAndAcquireResourceExclusive_k8@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExEnterPriorityRegionAndAcquireResourceExclusive_k8@4
_TEXT	SEGMENT
_Resource$ = 8						; size = 4
_ExEnterPriorityRegionAndAcquireResourceExclusive_k8@4 PROC ; COMDAT

; 2014 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2016 : }

	pop	ebp

; 2015 :     return ExEnterCriticalRegionAndAcquireResourceExclusive_k8(Resource);

	jmp	_ExEnterCriticalRegionAndAcquireResourceExclusive_k8@4
_ExEnterPriorityRegionAndAcquireResourceExclusive_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ExEnterPriorityRegionAndAcquireResourceShared_k8@4
EXTRN	_ExEnterCriticalRegionAndAcquireResourceShared_k8@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExEnterPriorityRegionAndAcquireResourceShared_k8@4
_TEXT	SEGMENT
_Resource$ = 8						; size = 4
_ExEnterPriorityRegionAndAcquireResourceShared_k8@4 PROC ; COMDAT

; 2021 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2023 : }

	pop	ebp

; 2022 :     return ExEnterCriticalRegionAndAcquireResourceShared_k8(Resource);

	jmp	_ExEnterCriticalRegionAndAcquireResourceShared_k8@4
_ExEnterPriorityRegionAndAcquireResourceShared_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExReleaseResourceAndLeavePriorityRegion_k8@4
EXTRN	@ExReleaseResourceAndLeaveCriticalRegion_k8@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExReleaseResourceAndLeavePriorityRegion_k8@4
_TEXT	SEGMENT
@ExReleaseResourceAndLeavePriorityRegion_k8@4 PROC	; COMDAT
; _Resource$ = ecx

; 2029 :     ExReleaseResourceAndLeaveCriticalRegion_k8(Resource);

	jmp	@ExReleaseResourceAndLeaveCriticalRegion_k8@4
@ExReleaseResourceAndLeavePriorityRegion_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PsAcquireProcessExitSynchronization_k8@4
EXTRN	__imp_@ExAcquireRundownProtection@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _PsAcquireProcessExitSynchronization_k8@4
_TEXT	SEGMENT
_Process$ = 8						; size = 4
_PsAcquireProcessExitSynchronization_k8@4 PROC		; COMDAT

; 2035 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2036 :     ULONG_PTR       Value, NewValue;
; 2037 :     PEX_RUNDOWN_REF RundownProtect;
; 2038 :     
; 2039 :     RundownProtect=&Process->RundownProtect;

	mov	ecx, DWORD PTR _Process$[ebp]
	add	ecx, 144				; 00000090H

; 2040 :     Value = RundownProtect->Count & 0xFFFFFFFEL;

	mov	edx, DWORD PTR [ecx]
	and	edx, -2					; fffffffeH
	push	esi

; 2041 :     NewValue = Value + EX_RUNDOWN_COUNT_INC;

	lea	eax, DWORD PTR [edx+2]
	push	edi

; 2042 : 
; 2043 :     #if !defined(_WIN64)
; 2044 :         NewValue=(ULONG_PTR) InterlockedCompareExchange(
; 2045 :                             (LONG *)RundownProtect,
; 2046 :                             NewValue,
; 2047 :                             Value);

	mov	esi, eax
	mov	edi, ecx
	mov	eax, edx
	lock	 cmpxchg DWORD PTR [edi], esi
	pop	edi
	pop	esi

; 2048 :     #else
; 2049 :         NewValue=(ULONG_PTR) InterlockedCompareExchange64(
; 2050 :                             (LONG64 *)RundownProtect,
; 2051 :                             NewValue,
; 2052 :                             Value);
; 2053 :     #endif
; 2054 :     
; 2055 :     if (Value==NewValue) {

	cmp	edx, eax
	jne	SHORT $LN4@PsAcquireP

; 2056 :         return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN2@PsAcquireP
$LN4@PsAcquireP:

; 2057 :     } else {
; 2058 :     
; 2059 :         if (ExAcquireRundownProtection(RundownProtect) == FALSE) {

	call	DWORD PTR __imp_@ExAcquireRundownProtection@4
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 1073741558				; 3ffffef6H
	add	eax, -1073741558			; c000010aH
$LN2@PsAcquireP:

; 2060 :             return STATUS_PROCESS_IS_TERMINATING;
; 2061 :         }
; 2062 :         else {
; 2063 :             return STATUS_SUCCESS;
; 2064 :         }
; 2065 :     }
; 2066 : }

	pop	ebp
	ret	4
_PsAcquireProcessExitSynchronization_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PsReleaseProcessExitSynchronization_k8@4
EXTRN	__imp_@ExReleaseRundownProtection@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _PsReleaseProcessExitSynchronization_k8@4
_TEXT	SEGMENT
_Process$ = 8						; size = 4
_PsReleaseProcessExitSynchronization_k8@4 PROC		; COMDAT

; 2071 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2072 :     ULONG_PTR       Value, NewValue;
; 2073 :     PEX_RUNDOWN_REF RundownProtect;
; 2074 :     
; 2075 :     RundownProtect=&Process->RundownProtect;

	mov	ecx, DWORD PTR _Process$[ebp]
	add	ecx, 144				; 00000090H

; 2076 :     Value = RundownProtect->Count & 0xFFFFFFFEL;

	mov	edx, DWORD PTR [ecx]
	and	edx, -2					; fffffffeH
	push	esi

; 2077 :     NewValue = Value - EX_RUNDOWN_COUNT_INC;

	lea	eax, DWORD PTR [edx-2]
	push	edi

; 2078 : 
; 2079 :     #if !defined(_WIN64)
; 2080 :         NewValue=(ULONG_PTR) InterlockedCompareExchange(
; 2081 :                             (LONG *)RundownProtect,
; 2082 :                             NewValue,
; 2083 :                             Value);

	mov	esi, eax
	mov	edi, ecx
	mov	eax, edx
	lock	 cmpxchg DWORD PTR [edi], esi
	pop	edi
	pop	esi

; 2084 :     #else
; 2085 :         NewValue=(ULONG_PTR) InterlockedCompareExchange64(
; 2086 :                             (LONG64 *)RundownProtect,
; 2087 :                             NewValue,
; 2088 :                             Value);
; 2089 :     #endif
; 2090 : 
; 2091 :     if (Value != NewValue)

	cmp	edx, eax
	je	SHORT $LN1@PsReleaseP

; 2092 :         ExReleaseRundownProtection(RundownProtect);

	call	DWORD PTR __imp_@ExReleaseRundownProtection@4
$LN1@PsReleaseP:

; 2093 : }

	pop	ebp
	ret	4
_PsReleaseProcessExitSynchronization_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ObGetObjectType_k8@4
; Function compile flags: /Ogsp
;	COMDAT _ObGetObjectType_k8@4
_TEXT	SEGMENT
_Object$ = 8						; size = 4
_ObGetObjectType_k8@4 PROC				; COMDAT

; 2103 : ObGetObjectType_k8 (PVOID Object) {

	npad	2
	push	ebp
	mov	ebp, esp

; 2104 :     POBJECT_HEADER  ObjectHeader;
; 2105 :     
; 2106 :     ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);
; 2107 :     return ObjectHeader->Type;

	mov	eax, DWORD PTR _Object$[ebp]
	mov	eax, DWORD PTR [eax-16]

; 2108 : }

	pop	ebp
	ret	4
_ObGetObjectType_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_OBJECT_HEADER_TO_NAME_INFO_EXISTS@4
; Function compile flags: /Ogsp
;	COMDAT _OBJECT_HEADER_TO_NAME_INFO_EXISTS@4
_TEXT	SEGMENT
_ObjectHeader$ = 8					; size = 4
_OBJECT_HEADER_TO_NAME_INFO_EXISTS@4 PROC		; COMDAT

; 2115 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2116 :     return (POBJECT_HEADER_NAME_INFO)((PUCHAR)ObjectHeader -
; 2117 :                                       ObjectHeader->NameInfoOffset);

	mov	eax, DWORD PTR _ObjectHeader$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	sub	eax, ecx

; 2118 : }

	pop	ebp
	ret	4
_OBJECT_HEADER_TO_NAME_INFO_EXISTS@4 ENDP
_TEXT	ENDS
PUBLIC	_OBJECT_HEADER_TO_NAME_INFO@4
; Function compile flags: /Ogsp
;	COMDAT _OBJECT_HEADER_TO_NAME_INFO@4
_TEXT	SEGMENT
_ObjectHeader$ = 8					; size = 4
_OBJECT_HEADER_TO_NAME_INFO@4 PROC			; COMDAT

; 2124 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2125 :     POBJECT_HEADER_NAME_INFO nameInfo;
; 2126 : 
; 2127 :     if (ObjectHeader->NameInfoOffset != 0) {

	mov	eax, DWORD PTR _ObjectHeader$[ebp]
	mov	cl, BYTE PTR [eax+12]
	test	cl, cl
	je	SHORT $LN2@OBJECT_HEA

; 2128 :         nameInfo = OBJECT_HEADER_TO_NAME_INFO_EXISTS(ObjectHeader);

	movzx	ecx, cl
	sub	eax, ecx

; 2129 :     } else {

	jmp	SHORT $LN1@OBJECT_HEA
$LN2@OBJECT_HEA:

; 2130 :         nameInfo = NULL;

	xor	eax, eax
$LN1@OBJECT_HEA:

; 2131 :     }
; 2132 : 
; 2133 :     return nameInfo;
; 2134 : }

	pop	ebp
	ret	4
_OBJECT_HEADER_TO_NAME_INFO@4 ENDP
_TEXT	ENDS
PUBLIC	_ObQueryNameInfo_k8@4
; Function compile flags: /Ogsp
;	COMDAT _ObQueryNameInfo_k8@4
_TEXT	SEGMENT
_Object$ = 8						; size = 4
_ObQueryNameInfo_k8@4 PROC				; COMDAT

; 2138 : ObQueryNameInfo_k8 (PVOID Object) {

	npad	2
	push	ebp
	mov	ebp, esp

; 2139 :     POBJECT_HEADER  ObjectHeader;
; 2140 :     POBJECT_HEADER_NAME_INFO NameInfo;
; 2141 :         
; 2142 :     ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

	mov	eax, DWORD PTR _Object$[ebp]

; 2143 :     NameInfo =     OBJECT_HEADER_TO_NAME_INFO(ObjectHeader);

	mov	cl, BYTE PTR [eax-12]
	add	eax, -24				; ffffffe8H
	test	cl, cl
	je	SHORT $LN4@ObQueryNam
	movzx	ecx, cl
	sub	eax, ecx
	jmp	SHORT $LN3@ObQueryNam
$LN4@ObQueryNam:
	xor	eax, eax
$LN3@ObQueryNam:

; 2144 :     
; 2145 :     return NameInfo;
; 2146 : }

	pop	ebp
	ret	4
_ObQueryNameInfo_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoUserShutdownInitiated_k8@0
; Function compile flags: /Ogsp
;	COMDAT _PoUserShutdownInitiated_k8@0
_TEXT	SEGMENT
_PoUserShutdownInitiated_k8@0 PROC			; COMDAT

; 2153 :     ;
; 2154 : }

	ret	0
_PoUserShutdownInitiated_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_LdrResFindResource_k8@36
EXTRN	_LdrAccessResource@16:PROC
EXTRN	_LdrFindResource_U@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _LdrResFindResource_k8@36
_TEXT	SEGMENT
_IdPath$ = -12						; size = 12
_DllHandle$ = 8						; size = 4
_ResourceDataEntry$ = 12				; size = 4
_Type$ = 12						; size = 4
_Name$ = 16						; size = 4
_Lang$ = 20						; size = 4
_ResourcePtr$ = 24					; size = 4
_Size$ = 28						; size = 4
_a7$ = 32						; size = 4
_a8$ = 36						; size = 4
_Flags$ = 40						; size = 4
_LdrResFindResource_k8@36 PROC				; COMDAT

; 2169 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2170 :     NTSTATUS                    Status; 
; 2171 :     ULONG_PTR                   IdPath[3];
; 2172 :     PIMAGE_RESOURCE_DATA_ENTRY  ResourceDataEntry;
; 2173 :     
; 2174 :     IdPath[0] = Type;

	mov	eax, DWORD PTR _Type$[ebp]
	mov	DWORD PTR _IdPath$[ebp], eax

; 2175 :     IdPath[1] = Name;

	mov	eax, DWORD PTR _Name$[ebp]
	mov	DWORD PTR _IdPath$[ebp+4], eax

; 2176 :     IdPath[2] = Lang;

	mov	eax, DWORD PTR _Lang$[ebp]
	mov	DWORD PTR _IdPath$[ebp+8], eax

; 2177 :     
; 2178 :     Status = LdrFindResource_U(
; 2179 :                 DllHandle,
; 2180 :                 IdPath,
; 2181 :                 3,
; 2182 :                 &ResourceDataEntry );

	lea	eax, DWORD PTR _ResourceDataEntry$[ebp]
	push	eax
	push	3
	lea	eax, DWORD PTR _IdPath$[ebp]
	push	eax
	push	DWORD PTR _DllHandle$[ebp]
	call	_LdrFindResource_U@16

; 2183 :                 
; 2184 :     if (Status != STATUS_SUCCESS)

	test	eax, eax
	je	SHORT $LN1@LdrResFind

; 2185 :         return STATUS_RESOURCE_DATA_NOT_FOUND;

	mov	eax, -1073741687			; c0000089H
	jmp	SHORT $LN2@LdrResFind
$LN1@LdrResFind:

; 2186 :     
; 2187 :     *ResourcePtr=0;
; 2188 :     Status = LdrAccessResource(
; 2189 :                     DllHandle,
; 2190 :                     ResourceDataEntry,
; 2191 :           (PVOID *) ResourcePtr,
; 2192 :                     Size );

	push	DWORD PTR _Size$[ebp]
	mov	eax, DWORD PTR _ResourcePtr$[ebp]
	and	DWORD PTR [eax], 0
	push	eax
	push	DWORD PTR _ResourceDataEntry$[ebp]
	push	DWORD PTR _DllHandle$[ebp]
	call	_LdrAccessResource@16
$LN2@LdrResFind:

; 2193 :                 
; 2194 :     return Status;
; 2195 :                 
; 2196 : }

	leave
	ret	36					; 00000024H
_LdrResFindResource_k8@36 ENDP
_TEXT	ENDS
PUBLIC	_LdrResFindResourceDirectory_k8@28
EXTRN	_LdrFindResourceDirectory_U@16:PROC
; Function compile flags: /Ogsp
;	COMDAT _LdrResFindResourceDirectory_k8@28
_TEXT	SEGMENT
_DllHandle$ = 8						; size = 4
_IdPath$ = 12						; size = 4
_Type$ = 12						; size = 4
_Lang$ = 16						; size = 4
_ResourceDirectory$ = 20				; size = 4
_a6$ = 24						; size = 4
_a7$ = 28						; size = 4
_a8$ = 32						; size = 4
_LdrResFindResourceDirectory_k8@28 PROC			; COMDAT

; 2209 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2210 : 
; 2211 :     NTSTATUS                  Status; 
; 2212 :     ULONG_PTR                 IdPath[1];
; 2213 :         
; 2214 :     IdPath[0] = Type;
; 2215 :     
; 2216 :     Status = LdrFindResourceDirectory_U(
; 2217 :                 DllHandle,
; 2218 :                 IdPath,
; 2219 :                 1,
; 2220 :                 ResourceDirectory);

	push	DWORD PTR _ResourceDirectory$[ebp]
	mov	eax, DWORD PTR _Type$[ebp]
	mov	DWORD PTR _IdPath$[ebp], eax
	push	1
	lea	eax, DWORD PTR _IdPath$[ebp]
	push	eax
	push	DWORD PTR _DllHandle$[ebp]
	call	_LdrFindResourceDirectory_U@16

; 2221 :                 
; 2222 :     return Status;
; 2223 : }

	pop	ebp
	ret	28					; 0000001cH
_LdrResFindResourceDirectory_k8@28 ENDP
_TEXT	ENDS
PUBLIC	_DbgkLkmdRegisterCallback_k8@12
; Function compile flags: /Ogsp
;	COMDAT _DbgkLkmdRegisterCallback_k8@12
_TEXT	SEGMENT
_CallBack$ = 8						; size = 4
_Context$ = 12						; size = 4
_Mode$ = 16						; size = 4
_DbgkLkmdRegisterCallback_k8@12 PROC			; COMDAT

; 2232 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2233 : }

	ret	12					; 0000000cH
_DbgkLkmdRegisterCallback_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_RpcBindingBind@12
; Function compile flags: /Ogsp
;	COMDAT _RpcBindingBind@12
_TEXT	SEGMENT
_pAsync$ = 8						; size = 4
_Binding$ = 12						; size = 4
_IfSpec$ = 16						; size = 4
_RpcBindingBind@12 PROC					; COMDAT

; 2308 :     return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH

; 2309 : }

	ret	12					; 0000000cH
_RpcBindingBind@12 ENDP
_TEXT	ENDS
PUBLIC	_RpcBindingCreateW@16
; Function compile flags: /Ogsp
;	COMDAT _RpcBindingCreateW@16
_TEXT	SEGMENT
_Template$ = 8						; size = 4
_Security$ = 12						; size = 4
_Options$ = 16						; size = 4
_Binding$ = 20						; size = 4
_RpcBindingCreateW@16 PROC				; COMDAT

; 2319 :     return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH

; 2320 : }

	ret	16					; 00000010H
_RpcBindingCreateW@16 ENDP
_TEXT	ENDS
PUBLIC	_RpcBindingCopy@8
; Function compile flags: /Ogsp
;	COMDAT _RpcBindingCopy@8
_TEXT	SEGMENT
_SourceBinding$ = 8					; size = 4
_DestinationBinding$ = 12				; size = 4
_RpcBindingCopy@8 PROC					; COMDAT

; 2328 :     return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH

; 2329 : }

	ret	8
_RpcBindingCopy@8 ENDP
_TEXT	ENDS
PUBLIC	_RpcBindingFree@4
; Function compile flags: /Ogsp
;	COMDAT _RpcBindingFree@4
_TEXT	SEGMENT
_Binding$ = 8						; size = 4
_RpcBindingFree@4 PROC					; COMDAT

; 2336 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2337 : }

	ret	4
_RpcBindingFree@4 ENDP
_TEXT	ENDS
PUBLIC	_RpcBindingUnbind@4
; Function compile flags: /Ogsp
;	COMDAT _RpcBindingUnbind@4
_TEXT	SEGMENT
_Binding$ = 8						; size = 4
_RpcBindingUnbind@4 PROC				; COMDAT

; 2344 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2345 : }

	ret	4
_RpcBindingUnbind@4 ENDP
_TEXT	ENDS
PUBLIC	_RpcAsyncInitializeHandle@8
; Function compile flags: /Ogsp
;	COMDAT _RpcAsyncInitializeHandle@8
_TEXT	SEGMENT
_pAsync$ = 8						; size = 4
_Size$ = 12						; size = 4
_RpcAsyncInitializeHandle@8 PROC			; COMDAT

; 2353 :     return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH

; 2354 : }

	ret	8
_RpcAsyncInitializeHandle@8 ENDP
_TEXT	ENDS
PUBLIC	_RpcAsyncCompleteCall@8
; Function compile flags: /Ogsp
;	COMDAT _RpcAsyncCompleteCall@8
_TEXT	SEGMENT
_pAsync$ = 8						; size = 4
_Reply$ = 12						; size = 4
_RpcAsyncCompleteCall@8 PROC				; COMDAT

; 2362 :     return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH

; 2363 : }

	ret	8
_RpcAsyncCompleteCall@8 ENDP
_TEXT	ENDS
PUBLIC	_RpcAsyncCancelCall@8
; Function compile flags: /Ogsp
;	COMDAT _RpcAsyncCancelCall@8
_TEXT	SEGMENT
_pAsync$ = 8						; size = 4
_fAbort$ = 12						; size = 1
_RpcAsyncCancelCall@8 PROC				; COMDAT

; 2371 :     return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH

; 2372 : }

	ret	8
_RpcAsyncCancelCall@8 ENDP
_TEXT	ENDS
PUBLIC	_NdrAsyncClientCall
; Function compile flags: /Ogsp
;	COMDAT _NdrAsyncClientCall
_TEXT	SEGMENT
_pStubDescriptor$ = 8					; size = 4
_pFormat$ = 12						; size = 4
_NdrAsyncClientCall PROC				; COMDAT

; 2382 :     return (CLIENT_CALL_RETURN)NULL;

	xor	eax, eax

; 2383 : }

	ret	0
_NdrAsyncClientCall ENDP
_TEXT	ENDS
PUBLIC	_I_RpcGetCompleteAndFreeRoutine@0
; Function compile flags: /Ogsp
;	COMDAT _I_RpcGetCompleteAndFreeRoutine@0
_TEXT	SEGMENT
_I_RpcGetCompleteAndFreeRoutine@0 PROC			; COMDAT

; 2389 :     return NULL;

	xor	eax, eax

; 2390 : }

	ret	0
_I_RpcGetCompleteAndFreeRoutine@0 ENDP
_TEXT	ENDS
PUBLIC	_I_RpcExceptionFilter@4
; Function compile flags: /Ogsp
;	COMDAT _I_RpcExceptionFilter@4
_TEXT	SEGMENT
_ExceptionCode$ = 8					; size = 4
_I_RpcExceptionFilter@4 PROC				; COMDAT

; 2398 :     return 0;

	xor	eax, eax

; 2399 : }

	ret	4
_I_RpcExceptionFilter@4 ENDP
_TEXT	ENDS
PUBLIC	_ZwPowerInformation_inject@20
EXTRN	__imp__ZwPowerInformation@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _ZwPowerInformation_inject@20
_TEXT	SEGMENT
_InformationLevel$ = 8					; size = 4
_InputBuffer$ = 12					; size = 4
_InputBufferLength$ = 16				; size = 4
_OutputBuffer$ = 20					; size = 4
_OutputBufferLength$ = 24				; size = 4
_ZwPowerInformation_inject@20 PROC			; COMDAT

; 2442 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2443 :     switch (InformationLevel) {

	mov	eax, DWORD PTR _InformationLevel$[ebp]
	sub	eax, 29					; 0000001dH
	push	edi
	je	SHORT $LN6@ZwPowerInf
	dec	eax
	je	SHORT $LN2@ZwPowerInf
	dec	eax
	je	SHORT $LN2@ZwPowerInf
	sub	eax, 10					; 0000000aH
	je	SHORT $LN7@ZwPowerInf
	dec	eax
	je	SHORT $LN2@ZwPowerInf
	sub	eax, 5
	je	SHORT $LN2@ZwPowerInf
	pop	edi

; 2476 :     }
; 2477 : }

	pop	ebp

; 2451 :         break;
; 2452 :         
; 2453 :     case 0x1E:
; 2454 :         return STATUS_SUCCESS;
; 2455 :         break;
; 2456 :         
; 2457 :     case 0x1F:
; 2458 :         return STATUS_SUCCESS;
; 2459 :         break;
; 2460 :         
; 2461 :     case 0x2A:
; 2462 :         return STATUS_SUCCESS;
; 2463 :         break;
; 2464 :         
; 2465 :     case 0x2F:
; 2466 :         return STATUS_SUCCESS;
; 2467 :         break;
; 2468 :         
; 2469 :     default:
; 2470 :         return ZwPowerInformation(
; 2471 :                     InformationLevel,
; 2472 :                     InputBuffer,
; 2473 :                     InputBufferLength,
; 2474 :                     OutputBuffer,
; 2475 :                     OutputBufferLength );

	jmp	DWORD PTR __imp__ZwPowerInformation@20
$LN7@ZwPowerInf:

; 2444 :     case 0x29:                                  // Sleep TimeOuts
; 2445 :         RtlZeroMemory(OutputBuffer, 0x1C);

	mov	edi, DWORD PTR _OutputBuffer$[ebp]
	push	7
	pop	ecx
	xor	eax, eax
	rep stosd

; 2446 :         return STATUS_SUCCESS;

	jmp	SHORT $LN2@ZwPowerInf
$LN6@ZwPowerInf:

; 2447 :         break;
; 2448 :     case 0x1D:                                  // PopConsoleDisplayState
; 2449 :         RtlZeroMemory(OutputBuffer, 0x04);

	mov	edi, DWORD PTR _OutputBuffer$[ebp]
	xor	eax, eax
	stosd
$LN2@ZwPowerInf:

; 2450 :         return STATUS_SUCCESS;

	xor	eax, eax
	pop	edi

; 2476 :     }
; 2477 : }

	pop	ebp
	ret	20					; 00000014H
_ZwPowerInformation_inject@20 ENDP
_TEXT	ENDS
PUBLIC	_SeQueryInformationToken_inject@12
EXTRN	__imp__SeQueryInformationToken@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _SeQueryInformationToken_inject@12
_TEXT	SEGMENT
_Token$ = 8						; size = 4
_TokenInformationClass$ = 12				; size = 4
_TokenInformation$ = 16					; size = 4
_SeQueryInformationToken_inject@12 PROC			; COMDAT

; 2498 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2499 :     TOKEN_MANDATORY_LABEL  *tml;
; 2500 :     PSID                    psid;
; 2501 :     
; 2502 :     switch (TokenInformationClass) {

	mov	eax, DWORD PTR _TokenInformationClass$[ebp]
	sub	eax, 25					; 00000019H
	je	SHORT $LN3@SeQueryInf
	dec	eax
	je	SHORT $LN2@SeQueryInf

; 2523 :     }
; 2524 : }

	pop	ebp

; 2517 :         break;
; 2518 :     default:
; 2519 :         return SeQueryInformationToken(
; 2520 :                     Token,
; 2521 :                     TokenInformationClass,
; 2522 :                     TokenInformation );

	jmp	DWORD PTR __imp__SeQueryInformationToken@12
$LN2@SeQueryInf:

; 2513 :         break;
; 2514 :     case TokenUIAccess:
; 2515 :         *TokenInformation= NULL;

	mov	eax, DWORD PTR _TokenInformation$[ebp]
	and	DWORD PTR [eax], 0

; 2516 :         return STATUS_SUCCESS;

	jmp	SHORT $LN9@SeQueryInf
$LN3@SeQueryInf:

; 2503 :     case TokenIntegrityLevel:
; 2504 :          /* report always "S-1-16-12288" (high mandatory level) for now */
; 2505 :             tml = (TOKEN_MANDATORY_LABEL *) Token;
; 2506 :             psid = tml + 1;

	mov	ecx, DWORD PTR _Token$[ebp]
	push	esi
	push	edi
	lea	eax, DWORD PTR [ecx+8]

; 2507 : 
; 2508 :             tml->Label.Sid = psid;

	mov	DWORD PTR [ecx], eax

; 2509 :             tml->Label.Attributes = SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED;

	mov	DWORD PTR [ecx+4], 96			; 00000060H

; 2510 :             memcpy(psid, &high_level, sizeof(SID)); 
; 2511 :             *TokenInformation=psid;

	mov	ecx, DWORD PTR _TokenInformation$[ebp]
	mov	esi, OFFSET _high_level
	mov	edi, eax
	movsd
	movsd
	movsd
	pop	edi
	mov	DWORD PTR [ecx], eax
	pop	esi
$LN9@SeQueryInf:

; 2512 :         return STATUS_SUCCESS;

	xor	eax, eax

; 2523 :     }
; 2524 : }

	pop	ebp
	ret	12					; 0000000cH
_SeQueryInformationToken_inject@12 ENDP
_TEXT	ENDS
PUBLIC	_RtlComputeCrc32_k8@12
; Function compile flags: /Ogsp
;	COMDAT _RtlComputeCrc32_k8@12
_TEXT	SEGMENT
_dwInitial$ = 8						; size = 4
_pData$ = 12						; size = 4
_iLen$ = 16						; size = 4
_RtlComputeCrc32_k8@12 PROC				; COMDAT

; 2540 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2541 :   ULONG crc = ~dwInitial;
; 2542 : 
; 2543 :   while (iLen > 0)

	cmp	DWORD PTR _iLen$[ebp], 0
	mov	eax, DWORD PTR _dwInitial$[ebp]
	not	eax
	jle	SHORT $LN1@RtlCompute
	mov	ecx, DWORD PTR _pData$[ebp]
$LL2@RtlCompute:

; 2544 :   {
; 2545 :     crc = CRC_table[(crc ^ *pData) & 0xff] ^ (crc >> 8);

	movzx	edx, BYTE PTR [ecx]
	xor	edx, eax
	and	edx, 255				; 000000ffH
	shr	eax, 8
	xor	eax, DWORD PTR _CRC_table[edx*4]

; 2546 :     pData++;

	inc	ecx

; 2547 :     iLen--;

	dec	DWORD PTR _iLen$[ebp]
	cmp	DWORD PTR _iLen$[ebp], 0
	jg	SHORT $LL2@RtlCompute
$LN1@RtlCompute:

; 2548 :   }
; 2549 :   return ~crc;

	not	eax

; 2550 : }

	pop	ebp
	ret	12					; 0000000cH
_RtlComputeCrc32_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryUnbiasedInterruptTime_k8@0
EXTRN	__imp__KeQueryInterruptTime@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeQueryUnbiasedInterruptTime_k8@0
_TEXT	SEGMENT
_KeQueryUnbiasedInterruptTime_k8@0 PROC			; COMDAT

; 2555 : 	return KeQueryInterruptTime();

	jmp	DWORD PTR __imp__KeQueryInterruptTime@0
_KeQueryUnbiasedInterruptTime_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KseRegisterShim_k8@12
; Function compile flags: /Ogsp
;	COMDAT _KseRegisterShim_k8@12
_TEXT	SEGMENT
_Shim$ = 8						; size = 4
_Ignored$ = 12						; size = 4
_Flags$ = 16						; size = 4
_KseRegisterShim_k8@12 PROC				; COMDAT

; 2564 : 	return STATUS_SUCCESS;

	xor	eax, eax

; 2565 : }

	ret	12					; 0000000cH
_KseRegisterShim_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_PoFxActivateComponent_k8@12
; Function compile flags: /Ogsp
;	COMDAT _PoFxActivateComponent_k8@12
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_Component$ = 12					; size = 4
_Flags$ = 16						; size = 4
_PoFxActivateComponent_k8@12 PROC			; COMDAT

; 2573 : 	;
; 2574 : }

	ret	12					; 0000000cH
_PoFxActivateComponent_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_PoFxCompleteDevicePowerNotRequired_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoFxCompleteDevicePowerNotRequired_k8@4
_TEXT	SEGMENT
_NewIrql$ = 8						; size = 4
_PoFxCompleteDevicePowerNotRequired_k8@4 PROC		; COMDAT

; 2580 : 	;
; 2581 : }

	ret	4
_PoFxCompleteDevicePowerNotRequired_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoFxCompleteIdleCondition_k8@8
; Function compile flags: /Ogsp
;	COMDAT _PoFxCompleteIdleCondition_k8@8
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_Component$ = 12					; size = 4
_PoFxCompleteIdleCondition_k8@8 PROC			; COMDAT

; 2588 : 	;
; 2589 : }

	ret	8
_PoFxCompleteIdleCondition_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_PoFxCompleteIdleState_k8@8
; Function compile flags: /Ogsp
;	COMDAT _PoFxCompleteIdleState_k8@8
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_Component$ = 12					; size = 4
_PoFxCompleteIdleState_k8@8 PROC			; COMDAT

; 2597 : 	;
; 2598 : }

	ret	8
_PoFxCompleteIdleState_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_PoFxIdleComponent_k8@12
; Function compile flags: /Ogsp
;	COMDAT _PoFxIdleComponent_k8@12
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_Component$ = 12					; size = 4
_Flags$ = 16						; size = 4
_PoFxIdleComponent_k8@12 PROC				; COMDAT

; 2607 : 	;
; 2608 : }

	ret	12					; 0000000cH
_PoFxIdleComponent_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_PoFxPowerControl_k8@28
; Function compile flags: /Ogsp
;	COMDAT _PoFxPowerControl_k8@28
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_PowerControlCode$ = 12					; size = 4
_InBuffer$ = 16						; size = 4
_InBufferSize$ = 20					; size = 4
_OutBuffer$ = 24					; size = 4
_OutBufferSize$ = 28					; size = 4
_BytesReturned$ = 32					; size = 4
_PoFxPowerControl_k8@28 PROC				; COMDAT

; 2621 : 	return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H

; 2622 : }

	ret	28					; 0000001cH
_PoFxPowerControl_k8@28 ENDP
_TEXT	ENDS
PUBLIC	_PoFxPowerOnCrashdumpDevice_k8@8
; Function compile flags: /Ogsp
;	COMDAT _PoFxPowerOnCrashdumpDevice_k8@8
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_Context$ = 12						; size = 4
_PoFxPowerOnCrashdumpDevice_k8@8 PROC			; COMDAT

; 2630 : 	return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H

; 2631 : }

	ret	8
_PoFxPowerOnCrashdumpDevice_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_PoFxRegisterCrashdumpDevice_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoFxRegisterCrashdumpDevice_k8@4
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_PoFxRegisterCrashdumpDevice_k8@4 PROC			; COMDAT

; 2638 : 	return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H

; 2639 : }

	ret	4
_PoFxRegisterCrashdumpDevice_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoFxRegisterDevice_k8@12
; Function compile flags: /Ogsp
;	COMDAT _PoFxRegisterDevice_k8@12
_TEXT	SEGMENT
_Pdo$ = 8						; size = 4
_Device$ = 12						; size = 4
_Handle$ = 16						; size = 4
_PoFxRegisterDevice_k8@12 PROC				; COMDAT

; 2647 : {	

	npad	2
	push	ebp
	mov	ebp, esp

; 2648 : 	*Handle = NULL;

	mov	eax, DWORD PTR _Handle$[ebp]
	and	DWORD PTR [eax], 0

; 2649 : 	return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H

; 2650 : }

	pop	ebp
	ret	12					; 0000000cH
_PoFxRegisterDevice_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_PoFxReportDevicePoweredOn_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoFxReportDevicePoweredOn_k8@4
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_PoFxReportDevicePoweredOn_k8@4 PROC			; COMDAT

; 2656 : 	;
; 2657 : }

	ret	4
_PoFxReportDevicePoweredOn_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoFxSetComponentLatency_k8@16
; Function compile flags: /Ogsp
;	COMDAT _PoFxSetComponentLatency_k8@16
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_Component$ = 12					; size = 4
_Latency$ = 16						; size = 8
_PoFxSetComponentLatency_k8@16 PROC			; COMDAT

; 2666 : 	;
; 2667 : }

	ret	16					; 00000010H
_PoFxSetComponentLatency_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_PoFxSetComponentResidency_k8@16
; Function compile flags: /Ogsp
;	COMDAT _PoFxSetComponentResidency_k8@16
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_Component$ = 12					; size = 4
_Residency$ = 16					; size = 8
_PoFxSetComponentResidency_k8@16 PROC			; COMDAT

; 2676 : 	
; 2677 : 	;
; 2678 : }

	ret	16					; 00000010H
_PoFxSetComponentResidency_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_PoFxSetDeviceIdleTimeout_k8@12
; Function compile flags: /Ogsp
;	COMDAT _PoFxSetDeviceIdleTimeout_k8@12
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_IdleTimeout$ = 12					; size = 8
_PoFxSetDeviceIdleTimeout_k8@12 PROC			; COMDAT

; 2686 : 	;
; 2687 : }

	ret	12					; 0000000cH
_PoFxSetDeviceIdleTimeout_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_PoFxStartDevicePowerManagement_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoFxStartDevicePowerManagement_k8@4
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_PoFxStartDevicePowerManagement_k8@4 PROC		; COMDAT

; 2693 : 	;
; 2694 : }

	ret	4
_PoFxStartDevicePowerManagement_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoFxUnregisterDevice_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoFxUnregisterDevice_k8@4
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_PoFxUnregisterDevice_k8@4 PROC				; COMDAT

; 2700 : 	;
; 2701 : }

	ret	4
_PoFxUnregisterDevice_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PoRegisterCoalescingCallback_k8@16
; Function compile flags: /Ogsp
;	COMDAT _PoRegisterCoalescingCallback_k8@16
_TEXT	SEGMENT
_Callback$ = 8						; size = 4
_ClientOrSrever$ = 12					; size = 1
_Handle$ = 16						; size = 4
_Context$ = 20						; size = 4
_PoRegisterCoalescingCallback_k8@16 PROC		; COMDAT

; 2710 : {	

	npad	2
	push	ebp
	mov	ebp, esp

; 2711 : 	*Handle = NULL;

	mov	eax, DWORD PTR _Handle$[ebp]
	and	DWORD PTR [eax], 0

; 2712 : 	return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H

; 2713 : }

	pop	ebp
	ret	16					; 00000010H
_PoRegisterCoalescingCallback_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_PoUnregisterCoalescingCallback_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PoUnregisterCoalescingCallback_k8@4
_TEXT	SEGMENT
_Handle$ = 8						; size = 4
_PoUnregisterCoalescingCallback_k8@4 PROC		; COMDAT

; 2719 : 	;
; 2720 : }	

	ret	4
_PoUnregisterCoalescingCallback_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetGenericIrpExtension_k8@12
; Function compile flags: /Ogsp
;	COMDAT _IoGetGenericIrpExtension_k8@12
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_GenericExtensionData$ = 12				; size = 4
_GenericExtensionDataSize$ = 16				; size = 2
_IoGetGenericIrpExtension_k8@12 PROC			; COMDAT

; 2728 : 	return STATUS_UNSUCCESSFUL;

	mov	eax, -1073741823			; c0000001H

; 2729 : }	

	ret	12					; 0000000cH
_IoGetGenericIrpExtension_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_KeQueryNodeMaximumProcessorCount_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeQueryNodeMaximumProcessorCount_k8@4
_TEXT	SEGMENT
_NodeNumber$ = 8					; size = 2
_KeQueryNodeMaximumProcessorCount_k8@4 PROC		; COMDAT

; 2734 : 	UNREFERENCED_PARAMETER(NodeNumber);
; 2735 :     return KeNumberProcessors;

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]

; 2736 : }

	ret	4
_KeQueryNodeMaximumProcessorCount_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_IoGetDeviceNumaNode_k8@8
; Function compile flags: /Ogsp
;	COMDAT _IoGetDeviceNumaNode_k8@8
_TEXT	SEGMENT
_Pdo$ = 8						; size = 4
_NodeNumber$ = 12					; size = 4
_IoGetDeviceNumaNode_k8@8 PROC				; COMDAT

; 2744 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2745 : 	//Maybe need implementation
; 2746 : 	*NodeNumber = 1;

	mov	ecx, DWORD PTR _NodeNumber$[ebp]
	xor	eax, eax
	inc	eax
	mov	WORD PTR [ecx], ax

; 2747 : 	return STATUS_SUCCESS;

	xor	eax, eax

; 2748 : }

	pop	ebp
	ret	8
_IoGetDeviceNumaNode_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_MmRotatePhysicalView_k8@24
; Function compile flags: /Ogsp
;	COMDAT _MmRotatePhysicalView_k8@24
_TEXT	SEGMENT
_VirtualAddress$ = 8					; size = 4
_NumberOfBytes$ = 12					; size = 4
_NewMdl$ = 16						; size = 4
_Direction$ = 20					; size = 4
_CopyFunction$ = 24					; size = 4
_Context$ = 28						; size = 4
_MmRotatePhysicalView_k8@24 PROC			; COMDAT

; 2759 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2760 : 	*NumberOfBytes = 0;

	mov	eax, DWORD PTR _NumberOfBytes$[ebp]
	and	DWORD PTR [eax], 0

; 2761 : 	return STATUS_SUCCESS;

	xor	eax, eax

; 2762 : }

	pop	ebp
	ret	24					; 00000018H
_MmRotatePhysicalView_k8@24 ENDP
_TEXT	ENDS
PUBLIC	_RtlCmDecodeMemIoResource_k8@8
; Function compile flags: /Ogsp
;	COMDAT _RtlCmDecodeMemIoResource_k8@8
_TEXT	SEGMENT
_Descriptor$ = 8					; size = 4
_Start$ = 12						; size = 4
_RtlCmDecodeMemIoResource_k8@8 PROC			; COMDAT

; 2765 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2766 :   ULONGLONG result; // qax@1
; 2767 :   ULONG length; // esi@1
; 2768 :   USHORT localFlags; // dx@3
; 2769 : 
; 2770 :   result = 0;
; 2771 :   length = 0;
; 2772 :   if ( Descriptor->Type == 3 || Descriptor->Type == 1 )

	mov	eax, DWORD PTR _Descriptor$[ebp]
	mov	cl, BYTE PTR [eax]
	push	esi
	xor	esi, esi
	cmp	cl, 3
	je	SHORT $LN8@RtlCmDecod
	cmp	cl, 1
	je	SHORT $LN8@RtlCmDecod

; 2776 :   }
; 2777 :   else
; 2778 :   {
; 2779 :     localFlags = Descriptor->Flags;

	movzx	ecx, WORD PTR [eax+2]

; 2780 :     if ( localFlags & 0x200 )

	test	ecx, 512				; 00000200H
	je	SHORT $LN6@RtlCmDecod

; 2781 :     {
; 2782 :       length = Descriptor->u.Generic.Length >> 24;

	movzx	esi, BYTE PTR [eax+15]

; 2783 :       result = Descriptor->u.Generic.Length << 8;
; 2784 :     }
; 2785 :     else

	jmp	SHORT $LN2@RtlCmDecod
$LN6@RtlCmDecod:

; 2786 :     {
; 2787 :       if ( localFlags & 0x400 )

	test	ecx, 1024				; 00000400H
	je	SHORT $LN4@RtlCmDecod

; 2788 :       {
; 2789 :         length = Descriptor->u.Generic.Length >> 16;

	movzx	esi, WORD PTR [eax+14]

; 2790 :         result = Descriptor->u.Generic.Length << 16;
; 2791 :       }
; 2792 :       else

	jmp	SHORT $LN2@RtlCmDecod
$LN4@RtlCmDecod:

; 2793 :       {
; 2794 :         if ( localFlags & 0x800 )

	test	ecx, 2048				; 00000800H
	je	SHORT $LN2@RtlCmDecod

; 2795 :         {
; 2796 :           length = Descriptor->u.Generic.Length;

	mov	esi, DWORD PTR [eax+12]

; 2797 :           result = 0;

	jmp	SHORT $LN2@RtlCmDecod
$LN8@RtlCmDecod:

; 2773 :   {
; 2774 :     result = Descriptor->u.Generic.Length;
; 2775 :     length = 0;

	xor	esi, esi
$LN2@RtlCmDecod:

; 2798 :         }
; 2799 :       }
; 2800 :     }
; 2801 :   }
; 2802 :   if ( Start )

	mov	ecx, DWORD PTR _Start$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@RtlCmDecod

; 2803 :     *Start = (ULONGLONG)&Descriptor->u.Generic.Start.HighPart;

	add	eax, 8
	cdq
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
$LN1@RtlCmDecod:

; 2804 :   result = length;
; 2805 :   return result;

	mov	eax, esi
	xor	edx, edx
	pop	esi

; 2806 : }

	pop	ebp
	ret	8
_RtlCmDecodeMemIoResource_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_RtlRunOnceInitialize_k8@4
; Function compile flags: /Ogsp
;	COMDAT _RtlRunOnceInitialize_k8@4
_TEXT	SEGMENT
_once$ = 8						; size = 4
_RtlRunOnceInitialize_k8@4 PROC				; COMDAT

; 2813 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2814 :     once->Ptr = NULL;

	mov	eax, DWORD PTR _once$[ebp]
	and	DWORD PTR [eax], 0

; 2815 : }

	pop	ebp
	ret	4
_RtlRunOnceInitialize_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_DriverEntry@8
; Function compile flags: /Ogsp
;	COMDAT _DriverEntry@8
_TEXT	SEGMENT
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 2822 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2823 : }

	ret	8
_DriverEntry@8 ENDP
_TEXT	ENDS
PUBLIC	_DllInitialize@4
EXTRN	_WRK2003_Init@0:PROC
EXTRN	__imp__PsSetCreateProcessNotifyRoutine@8:PROC
EXTRN	_CREATE_PROCESS_NOTIFY_ROUTINE_asm:DWORD
; Function compile flags: /Ogsp
;	COMDAT _DllInitialize@4
_TEXT	SEGMENT
_RegistryPath$ = 8					; size = 4
_DllInitialize@4 PROC					; COMDAT

; 2834 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2835 :     /*     // debug loop
; 2836 :     __asm {
; 2837 :         L1:
; 2838 :         jmp L1
; 2839 :     }
; 2840 :     */
; 2841 : 
; 2842 :     Initialize(RegistryPath);

	push	DWORD PTR _RegistryPath$[ebp]
	call	_Initialize@4

; 2843 :     PsSetCreateProcessNotifyRoutine((PCREATE_PROCESS_NOTIFY_ROUTINE)&CREATE_PROCESS_NOTIFY_ROUTINE_asm, FALSE);

	push	0
	push	OFFSET _CREATE_PROCESS_NOTIFY_ROUTINE_asm
	call	DWORD PTR __imp__PsSetCreateProcessNotifyRoutine@8

; 2844 :     WRK2003_Init();

	call	_WRK2003_Init@0

; 2845 :     //InitTramplineArray();
; 2846 : 
; 2847 : 
; 2848 : #ifdef DEBUG_TESTS
; 2849 :     RunTests();
; 2850 : #endif
; 2851 : 
; 2852 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2853 : }

	pop	ebp
	ret	4
_DllInitialize@4 ENDP
_TEXT	ENDS
PUBLIC	_DllUnload@0
; Function compile flags: /Ogsp
;	COMDAT _DllUnload@0
_TEXT	SEGMENT
_DllUnload@0 PROC					; COMDAT

; 2859 :     PsSetCreateProcessNotifyRoutine((PCREATE_PROCESS_NOTIFY_ROUTINE)&CREATE_PROCESS_NOTIFY_ROUTINE_asm, TRUE);

	push	1
	push	OFFSET _CREATE_PROCESS_NOTIFY_ROUTINE_asm
	call	DWORD PTR __imp__PsSetCreateProcessNotifyRoutine@8

; 2860 : 
; 2861 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2862 : }

	ret	0
_DllUnload@0 ENDP
_TEXT	ENDS
END
