; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	d:\develop\3drprojects\ntoskrnl_emu\common.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_KeSetCoalescableTimer_k8@24
EXTRN	__imp__KeSetTimerEx@20:PROC
; Function compile flags: /Ogsp
; File d:\develop\3drprojects\ntoskrnl_emu\common.c
;	COMDAT _KeSetCoalescableTimer_k8@24
_TEXT	SEGMENT
_Timer$ = 8						; size = 4
_DueTime$ = 12						; size = 8
_Period$ = 20						; size = 4
_TolerableDelay$ = 24					; size = 4
_Dpc$ = 28						; size = 4
_KeSetCoalescableTimer_k8@24 PROC			; COMDAT

; 21   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 22   :    return KeSetTimerEx(
; 23   :             Timer,
; 24   :             DueTime,
; 25   :             Period,
; 26   :             Dpc );     

	push	DWORD PTR _Dpc$[ebp]
	push	DWORD PTR _Period$[ebp]
	push	DWORD PTR _DueTime$[ebp+4]
	push	DWORD PTR _DueTime$[ebp]
	push	DWORD PTR _Timer$[ebp]
	call	DWORD PTR __imp__KeSetTimerEx@20

; 27   : }

	pop	ebp
	ret	24					; 00000018H
_KeSetCoalescableTimer_k8@24 ENDP
_TEXT	ENDS
PUBLIC	_RtlGetIntegerAtom_k8@8
EXTRN	__imp__RtlUnicodeStringToInteger@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _RtlGetIntegerAtom_k8@8
_TEXT	SEGMENT
_UnicodeString$ = -8					; size = 8
_n$ = 8							; size = 4
_Name$ = 8						; size = 4
_Atom$ = 12						; size = 4
_RtlGetIntegerAtom_k8@8 PROC				; COMDAT

; 34   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx

; 35   :     NTSTATUS Status;
; 36   :     UNICODE_STRING UnicodeString;
; 37   :     PWSTR s;
; 38   :     ULONG n;
; 39   :     RTL_ATOM Temp;
; 40   : 
; 41   :     if (((ULONG_PTR)Name & -0x10000) == 0) {

	mov	ecx, DWORD PTR _Name$[ebp]
	test	ecx, -65536				; ffff0000H
	jne	SHORT $LN18@RtlGetInte
	push	esi

; 42   :         Temp = (RTL_ATOM)(USHORT)PtrToUlong(Name);
; 43   :         if (Temp >= RTL_ATOM_MAXIMUM_INTEGER_ATOM) {

	mov	eax, 49152				; 0000c000H
	mov	esi, eax
	cmp	cx, si
	movzx	edx, cx
	pop	esi

; 44   :             return FALSE;

	jae	$LN6@RtlGetInte

; 45   :             }
; 46   :         else {
; 47   :             if (Temp == RTL_ATOM_INVALID_ATOM) {

	test	cx, cx
	jne	SHORT $LN15@RtlGetInte

; 48   :                 Temp = RTL_ATOM_MAXIMUM_INTEGER_ATOM;

	mov	edx, eax
$LN15@RtlGetInte:

; 49   :                 }
; 50   : 
; 51   :             if (ARGUMENT_PRESENT( Atom )) {

	mov	eax, DWORD PTR _Atom$[ebp]
	test	eax, eax
	je	SHORT $LN14@RtlGetInte

; 52   :                 *Atom = Temp;

	mov	WORD PTR [eax], dx
$LN14@RtlGetInte:

; 53   :                 }
; 54   : 
; 55   :             return TRUE;

	mov	al, 1
	jmp	SHORT $LN1@RtlGetInte
$LN18@RtlGetInte:

; 56   :             }
; 57   :         }
; 58   :     else
; 59   :     if (*Name != L'#') {

	cmp	WORD PTR [ecx], 35			; 00000023H

; 60   :         return FALSE;

	jne	SHORT $LN6@RtlGetInte

; 61   :         }
; 62   : 
; 63   :     s = ++Name;

	inc	ecx
	inc	ecx

; 64   :     while (*s != UNICODE_NULL) {

	movzx	edx, WORD PTR [ecx]
	mov	eax, ecx
	test	dx, dx
	je	SHORT $LN10@RtlGetInte
	movzx	edx, dx
$LL11@RtlGetInte:

; 65   :         if (*s < L'0' || *s > L'9') {

	cmp	dx, 48					; 00000030H
	jb	SHORT $LN6@RtlGetInte
	cmp	dx, 57					; 00000039H
	ja	SHORT $LN6@RtlGetInte

; 66   :             return FALSE;
; 67   :             }
; 68   :         else {
; 69   :             s++;

	inc	eax
	inc	eax
	movzx	edx, WORD PTR [eax]
	test	dx, dx
	jne	SHORT $LL11@RtlGetInte
$LN10@RtlGetInte:

; 70   :             }
; 71   :         }
; 72   : 
; 73   :     n = 0;

	and	DWORD PTR _n$[ebp], 0

; 74   :     UnicodeString.Buffer = Name;
; 75   :     UnicodeString.Length = (USHORT)((PCHAR)s - (PCHAR)Name);

	sub	eax, ecx
	mov	WORD PTR _UnicodeString$[ebp], ax

; 76   :     UnicodeString.MaximumLength = UnicodeString.Length;

	mov	WORD PTR _UnicodeString$[ebp+2], ax

; 77   :     Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &n );

	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	push	10					; 0000000aH
	lea	eax, DWORD PTR _UnicodeString$[ebp]
	push	eax
	mov	DWORD PTR _UnicodeString$[ebp+4], ecx
	call	DWORD PTR __imp__RtlUnicodeStringToInteger@12

; 78   :     if (NT_SUCCESS( Status )) {

	test	eax, eax
	jl	SHORT $LN6@RtlGetInte

; 79   :         if (ARGUMENT_PRESENT( Atom )) {

	mov	edx, DWORD PTR _Atom$[ebp]
	test	edx, edx
	je	SHORT $LN14@RtlGetInte

; 80   :             if (n == 0 || n > RTL_ATOM_MAXIMUM_INTEGER_ATOM) {

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, 49152				; 0000c000H
	test	ecx, ecx
	je	SHORT $LN3@RtlGetInte
	cmp	ecx, eax
	ja	SHORT $LN3@RtlGetInte

; 82   :                 }
; 83   :             else {
; 84   :                 *Atom = (RTL_ATOM)n;

	mov	WORD PTR [edx], cx
	jmp	SHORT $LN14@RtlGetInte
$LN3@RtlGetInte:

; 81   :                 *Atom = RTL_ATOM_MAXIMUM_INTEGER_ATOM;

	mov	WORD PTR [edx], ax

; 85   :                 }
; 86   :             }
; 87   : 
; 88   :         return TRUE;

	jmp	SHORT $LN14@RtlGetInte
$LN6@RtlGetInte:

; 89   :         }
; 90   :     else {
; 91   :         return FALSE;

	xor	al, al
$LN1@RtlGetInte:

; 92   :         }
; 93   : }

	leave
	ret	8
_RtlGetIntegerAtom_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_RtlGetThreadLangIdByIndex_k8@16
; Function compile flags: /Ogsp
;	COMDAT _RtlGetThreadLangIdByIndex_k8@16
_TEXT	SEGMENT
_a1$ = 8						; size = 4
_a2$ = 12						; size = 4
_PreferredLanguages$ = 16				; size = 4
_Result2$ = 20						; size = 4
_RtlGetThreadLangIdByIndex_k8@16 PROC			; COMDAT

; 102  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 103  :     *PreferredLanguages= 1033; // english

	mov	eax, DWORD PTR _PreferredLanguages$[ebp]
	mov	DWORD PTR [eax], 1033			; 00000409H

; 104  :   
; 105  :     return STATUS_SUCCESS;

	xor	eax, eax

; 106  : }

	pop	ebp
	ret	16					; 00000010H
_RtlGetThreadLangIdByIndex_k8@16 ENDP
_TEXT	ENDS
END
