; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	d:\develop\3drprojects\ntoskrnl_emu\wrk2003.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_TrampKeBugCheckEx@0
PUBLIC	_gGuardedRegion_OldIrql
PUBLIC	_gGuardedRegionCounter
PUBLIC	_MmShortTime
PUBLIC	_gTramp_KeInvalidateAllCaches
PUBLIC	_gTramp_KeAlertThread
PUBLIC	_gTramp_KeTestAlertThread
PUBLIC	_gTramp_LpcRequestWaitReplyPortEx
PUBLIC	_KeTestAlertThread_magic2
PUBLIC	_KeTestAlertThread_magic2mask
PUBLIC	_LpcRequestWaitReplyPortEx_magic2
PUBLIC	_LpcRequestWaitReplyPortEx_magic2mask
_BSS	SEGMENT
_gGuardedRegion_OldIrql DB 01H DUP (?)
	ALIGN	4

_gGuardedRegionCounter DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_gTramp_KeInvalidateAllCaches DD FLAT:_TrampKeBugCheckEx@0
_gTramp_KeAlertThread DD FLAT:_TrampKeBugCheckEx@0
_gTramp_KeTestAlertThread DD FLAT:_TrampKeBugCheckEx@0
_gTramp_LpcRequestWaitReplyPortEx DD FLAT:_TrampKeBugCheckEx@0
_KeTestAlertThread_magic2 DD FLAT:_KeTestAlertThread_magic1
_KeTestAlertThread_magic2mask DD FLAT:_KeTestAlertThread_magic1mask
_LpcRequestWaitReplyPortEx_magic2 DD FLAT:_LpcRequestWaitReplyPortEx_magic1
_LpcRequestWaitReplyPortEx_magic2mask DD FLAT:_LpcRequestWaitReplyPortEx_magic1mask
_DATA	ENDS
CONST	SEGMENT
_MmShortTime DD	0fffe7960H
	DD	0ffffffffH
_KeAlertThread_magic1 DB 055H
	DB	08bH
	DB	0ecH
	DB	083H
	DB	0ecH
	DB	0cH
	DB	053H
	DB	056H
	DB	08bH
	DB	075H
	DB	08H
	DB	057H
	DB	08dH
	DB	04eH
	DB	044H
	DB	08dH
	DB	055H
	DB	0f4H
	DB	0ffH
	DB	015H
	DB	011H
	DB	022H
	DB	033H
	DB	044H
	DB	064H
	DB	08bH
	DB	0dH
	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	0bfH
	DB	018H
	DB	04H
	DB	00H
	DB	00H
_KeAlertThread_magic1mask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
_KeAlertThread_magic1chk DB 055H
	DB	08bH
	DB	0ecH
	DB	083H
	DB	0ecH
	DB	0cH
	DB	053H
	DB	056H
	DB	08bH
	DB	075H
	DB	08H
	DB	080H
	DB	03eH
	DB	06H
	DB	057H
	DB	074H
	DB	016H
	DB	06aH
	DB	00H
	ORG $+1
_KeAlertThread_magic1chkmask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+1
_KeAlertThread_magic2 DB 055H
	DB	08bH
	DB	0ecH
	DB	083H
	DB	0ecH
	DB	0cH
	DB	053H
	DB	056H
	DB	08bH
	DB	075H
	DB	08H
	DB	08dH
	DB	04eH
	DB	044H
	DB	08dH
	DB	055H
	DB	0f4H
	DB	0ffH
	DB	015H
	DB	011H
	DB	022H
	DB	033H
	DB	044H
	DB	08aH
	DB	04dH
	DB	0cH
	DB	0fH
	DB	0beH
	DB	0c1H
	DB	08dH
	DB	044H
	DB	030H
	DB	05eH
	ORG $+3
_KeAlertThread_magic2mask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+3
_KeTestAlertThread_magic1 DB 055H
	DB	08bH
	DB	0ecH
	DB	083H
	DB	0ecH
	DB	0cH
	DB	053H
	DB	056H
	DB	064H
	DB	08bH
	DB	035H
	DB	024H
	DB	01H
	DB	00H
	DB	00H
	DB	08dH
	DB	04eH
	DB	044H
	DB	08dH
	DB	055H
	DB	0f4H
	DB	0ffH
	DB	015H
	DB	011H
	DB	022H
	DB	033H
	DB	044H
	DB	0fH
	DB	0beH
	DB	045H
	DB	08H
	DB	08dH
	DB	044H
	DB	030H
	DB	05eH
	ORG $+1
_KeTestAlertThread_magic1mask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+1
_KeTestAlertThread_magic1chk DB 055H
	DB	08bH
	DB	0ecH
	DB	083H
	DB	0ecH
	DB	0cH
	DB	0ffH
	DB	015H
	DB	011H
	DB	022H
	DB	033H
	DB	044H
	DB	03cH
	DB	02H
	DB	076H
	DB	016H
	DB	06aH
	DB	00H
	ORG $+2
_KeTestAlertThread_magic1chkmask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+2
_LpcRequestWaitReplyPortEx_magic1 DB 055H
	DB	08bH
	DB	0ecH
	DB	064H
	DB	0a1H
	DB	024H
	DB	01H
	DB	00H
	DB	00H
	DB	0fH
	DB	0beH
	DB	080H
	DB	0d7H
	DB	00H
	DB	00H
	DB	00H
	DB	050H
	DB	0ffH
	DB	075H
	DB	010H
	DB	0ffH
	DB	075H
	DB	0cH
	DB	0ffH
	DB	075H
	DB	08H
	DB	0e8H
	DB	011H
	DB	022H
	DB	033H
	DB	044H
	DB	05dH
	DB	0c2H
	DB	0cH
	DB	00H
	ORG $+1
_LpcRequestWaitReplyPortEx_magic1mask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	_KeInitializeSpinLock@4
; Function compile flags: /Ogsp
; File d:\develop\ddk\winddk\7600.16385.1\inc\ddk\wdm.h
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

	npad	2
	push	ebp
	mov	ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

	mov	eax, DWORD PTR _SpinLock$[ebp]
	and	DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

	pop	ebp
	ret	4
_KeInitializeSpinLock@4 ENDP
_TEXT	ENDS
PUBLIC	_ExInitializeFastMutex@4
EXTRN	__imp__KeInitializeEvent@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExInitializeFastMutex@4
_TEXT	SEGMENT
_FastMutex$ = 8						; size = 4
_ExInitializeFastMutex@4 PROC				; COMDAT

; 16362: {

	npad	2
	push	ebp
	mov	ebp, esp

; 16363: 
; 16364:     FastMutex->Count = FM_LOCK_BIT;

	mov	eax, DWORD PTR _FastMutex$[ebp]

; 16365:     FastMutex->Owner = NULL;

	xor	edx, edx
	xor	ecx, ecx
	inc	ecx

; 16366:     FastMutex->Contention = 0;
; 16367:     KeInitializeEvent(&FastMutex->Event, SynchronizationEvent, FALSE);

	push	edx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	push	ecx
	add	eax, 12					; 0000000cH
	push	eax
	call	DWORD PTR __imp__KeInitializeEvent@12

; 16368:     return;
; 16369: }

	pop	ebp
	ret	4
_ExInitializeFastMutex@4 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThread@0
EXTRN	__imp__KeGetCurrentThread@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThread@0
_TEXT	SEGMENT
_PsGetCurrentThread@0 PROC				; COMDAT

; 19989: 
; 19990:     return (PETHREAD)KeGetCurrentThread();

	jmp	DWORD PTR __imp__KeGetCurrentThread@0
_PsGetCurrentThread@0 ENDP
_TEXT	ENDS
PUBLIC	_KeGetCurrentProcessorNumber@0
; Function compile flags: /Ogsp
; File d:\develop\ddk\winddk\7600.16385.1\inc\ddk\ntddk.h
;	COMDAT _KeGetCurrentProcessorNumber@0
_TEXT	SEGMENT
_KeGetCurrentProcessorNumber@0 PROC			; COMDAT

; 6243 : #if (_MSC_FULL_VER >= 13012035)
; 6244 :     return (ULONG) __readfsbyte (FIELD_OFFSET (KPCR, Number));

	mov	al, BYTE PTR fs:81
	movzx	eax, al

; 6245 : #else
; 6246 :     __asm {  movzx eax, _PCR KPCR.Number  }
; 6247 : #endif
; 6248 : }

	ret	0
_KeGetCurrentProcessorNumber@0 ENDP
_TEXT	ENDS
PUBLIC	_KeEnterCriticalRegionThread@4
; Function compile flags: /Ogsp
; File d:\develop\3drprojects\ntoskrnl_emu\wrk2003.h
;	COMDAT _KeEnterCriticalRegionThread@4
_TEXT	SEGMENT
_Thread$ = 8						; size = 4
_KeEnterCriticalRegionThread@4 PROC			; COMDAT

; 257  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 258  :     Thread->KernelApcDisable -= 1;

	mov	eax, DWORD PTR _Thread$[ebp]
	dec	WORD PTR [eax+112]

; 259  :     KeMemoryBarrierWithoutFence();
; 260  : }

	pop	ebp
	ret	4
_KeEnterCriticalRegionThread@4 ENDP
_TEXT	ENDS
PUBLIC	_EXP_GET_CURRENT_RUNDOWN_REF@4
; Function compile flags: /Ogsp
;	COMDAT _EXP_GET_CURRENT_RUNDOWN_REF@4
_TEXT	SEGMENT
_RunRefCacheAware$ = 8					; size = 4
_EXP_GET_CURRENT_RUNDOWN_REF@4 PROC			; COMDAT

; 267  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 268  :     return ((PEX_RUNDOWN_REF) (((PUCHAR) RunRefCacheAware->RunRefs) +
; 269  :                                (KeGetCurrentProcessorNumber() % RunRefCacheAware->Number) * RunRefCacheAware->RunRefSize));

	mov	al, BYTE PTR fs:81
	mov	ecx, DWORD PTR _RunRefCacheAware$[ebp]
	movzx	eax, al
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, edx
	imul	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]

; 270  : }

	pop	ebp
	ret	4
_EXP_GET_CURRENT_RUNDOWN_REF@4 ENDP
_TEXT	ENDS
PUBLIC	_EXP_GET_PROCESSOR_RUNDOWN_REF@8
; Function compile flags: /Ogsp
;	COMDAT _EXP_GET_PROCESSOR_RUNDOWN_REF@8
_TEXT	SEGMENT
_RunRefCacheAware$ = 8					; size = 4
_Index$ = 12						; size = 4
_EXP_GET_PROCESSOR_RUNDOWN_REF@8 PROC			; COMDAT

; 278  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 279  :     return ((PEX_RUNDOWN_REF) (((PUCHAR) RunRefCacheAware->RunRefs) +
; 280  :                                 (Index % RunRefCacheAware->Number) * RunRefCacheAware->RunRefSize));

	mov	ecx, DWORD PTR _RunRefCacheAware$[ebp]
	mov	eax, DWORD PTR _Index$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, edx
	imul	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]

; 281  : }

	pop	ebp
	ret	8
_EXP_GET_PROCESSOR_RUNDOWN_REF@8 ENDP
_TEXT	ENDS
PUBLIC	_KeGetCurrentPrcb@0
; Function compile flags: /Ogsp
;	COMDAT _KeGetCurrentPrcb@0
_TEXT	SEGMENT
_KeGetCurrentPrcb@0 PROC				; COMDAT

; 287  :     #if defined(_X86_)
; 288  :         return (PKPRCB) (ULONG_PTR) __readfsdword (FIELD_OFFSET (KPCR, Prcb));

	mov	eax, DWORD PTR fs:32

; 289  :     #else
; 290  :         return (PKPRCB)__readgsqword(FIELD_OFFSET(KPCR, CurrentPrcb));
; 291  :     #endif
; 292  : }

	ret	0
_KeGetCurrentPrcb@0 ENDP
_TEXT	ENDS
PUBLIC	_ExFreeToPPLookasideList@8
EXTRN	__imp_@InterlockedPushEntrySList@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExFreeToPPLookasideList@8
_TEXT	SEGMENT
_Number$ = 8						; size = 4
_Entry$ = 12						; size = 4
_ExFreeToPPLookasideList@8 PROC				; COMDAT

; 300  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 301  : 
; 302  :     PGENERAL_LOOKASIDE Lookaside;
; 303  :     PKPRCB Prcb;
; 304  : 
; 305  :     Prcb = KeGetCurrentPrcb();

	mov	eax, DWORD PTR fs:32

; 306  :     Lookaside = Prcb->PPLookasideList[Number].P;

	mov	edx, DWORD PTR _Number$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+1504]

; 307  :     Lookaside->TotalFrees += 1;

	inc	DWORD PTR [ecx+20]
	push	esi

; 308  :     if (ExQueryDepthSList(&Lookaside->ListHead) >= Lookaside->Depth) {

	mov	si, WORD PTR [ecx+4]
	cmp	si, WORD PTR [ecx+8]
	pop	esi
	jb	SHORT $LN1@ExFreeToPP

; 309  :         Lookaside->FreeMisses += 1;

	inc	DWORD PTR [ecx+24]

; 310  :         Lookaside = Prcb->PPLookasideList[Number].L;

	mov	ecx, DWORD PTR [eax+edx*8+1508]

; 311  :         Lookaside->TotalFrees += 1;
; 312  :         if (ExQueryDepthSList(&Lookaside->ListHead) >= Lookaside->Depth) {

	mov	ax, WORD PTR [ecx+4]
	inc	DWORD PTR [ecx+20]
	cmp	ax, WORD PTR [ecx+8]
	jb	SHORT $LN1@ExFreeToPP

; 313  :             Lookaside->FreeMisses += 1;
; 314  :             (Lookaside->Free)(Entry);

	push	DWORD PTR _Entry$[ebp]
	inc	DWORD PTR [ecx+24]
	call	DWORD PTR [ecx+44]

; 315  :             return;

	jmp	SHORT $LN3@ExFreeToPP
$LN1@ExFreeToPP:

; 316  :         }
; 317  :     }
; 318  : 
; 319  :     InterlockedPushEntrySList(&Lookaside->ListHead,
; 320  :                               (PSLIST_ENTRY)Entry);

	mov	edx, DWORD PTR _Entry$[ebp]
	call	DWORD PTR __imp_@InterlockedPushEntrySList@8
$LN3@ExFreeToPP:

; 321  : 
; 322  :     return;
; 323  : }

	pop	ebp
	ret	8
_ExFreeToPPLookasideList@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KeBugCheckEx@20:PROC
; Function compile flags: /Ogsp
; File d:\develop\3drprojects\ntoskrnl_emu\wrk2003.c
;	COMDAT _TrampKeBugCheckEx@0
_TEXT	SEGMENT
_TrampKeBugCheckEx@0 PROC				; COMDAT

; 15   :     KeBugCheckEx(0xDEADBEEFL, 5, 0, 0, 1);

	push	1
	push	0
	push	0
	push	5
	push	-559038737				; deadbeefH
	call	DWORD PTR __imp__KeBugCheckEx@20
$LN4@TrampKeBug:
$LN3@TrampKeBug:
	int	3
_TrampKeBugCheckEx@0 ENDP
_TEXT	ENDS
PUBLIC	@ExAcquireRundownProtectionEx_k8@8
; Function compile flags: /Ogsp
;	COMDAT @ExAcquireRundownProtectionEx_k8@8
_TEXT	SEGMENT
@ExAcquireRundownProtectionEx_k8@8 PROC			; COMDAT
; _RunRef$ = ecx
; _Count$ = edx

; 65   : {

	npad	2
	push	ebx

; 66   :     ULONG_PTR Value, NewValue;
; 67   : 
; 68   :     Value = RunRef->Count;

	mov	ebx, DWORD PTR [ecx]
	push	esi
	push	edi

; 69   :     do {
; 70   :         //
; 71   :         // If rundown has started return with an error
; 72   :         //
; 73   :         if (Value & EX_RUNDOWN_ACTIVE) {

	test	bl, 1
	jne	SHORT $LN10@
	add	edx, edx
$LL5@:

; 75   :         }
; 76   : 
; 77   :         //
; 78   :         // Rundown hasn't started yet so attempt to increment the unsage count.
; 79   :         //
; 80   :         NewValue = Value + EX_RUNDOWN_COUNT_INC * Count;

	lea	eax, DWORD PTR [edx+ebx]

; 81   : 
; 82   :         NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
; 83   :                                                                   (PVOID) NewValue,
; 84   :                                                                   (PVOID) Value);

	mov	esi, eax
	mov	edi, ecx
	mov	eax, ebx
	lock	 cmpxchg DWORD PTR [edi], esi

; 85   :         if (NewValue == Value) {

	cmp	eax, ebx
	je	SHORT $LN11@

; 87   :         }
; 88   :         //
; 89   :         // somebody else changed the variable before we did. Either a protection call came and went or rundown was
; 90   :         // initiated. We just repeat the whole loop again.
; 91   :         //
; 92   :         Value = NewValue;

	mov	ebx, eax
	test	al, 1
	je	SHORT $LL5@
$LN10@:

; 74   :             return FALSE;

	xor	al, al
	jmp	SHORT $LN3@
$LN11@:

; 86   :             return TRUE;

	mov	al, 1
$LN3@:
	pop	edi
	pop	esi
	pop	ebx

; 93   :     } while (TRUE);
; 94   : }

	ret	0
@ExAcquireRundownProtectionEx_k8@8 ENDP
_TEXT	ENDS
PUBLIC	@ExReleaseRundownProtectionEx_k8@8
EXTRN	__imp__KeSetEvent@12:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExReleaseRundownProtectionEx_k8@8
_TEXT	SEGMENT
_Count$ = -4						; size = 4
@ExReleaseRundownProtectionEx_k8@8 PROC			; COMDAT
; _RunRef$ = ecx
; _Count$ = edx

; 102  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 103  :     ULONG_PTR Value, NewValue;
; 104  : 
; 105  :     Value = RunRef->Count;

	mov	ebx, DWORD PTR [ecx]
	push	esi
	push	edi
	mov	DWORD PTR _Count$[ebp], edx

; 106  :     do {
; 107  :         //
; 108  :         // If the block is already marked for rundown then decrement the wait block count and wake the
; 109  :         // rundown thread if we are the last
; 110  :         //
; 111  :         if (Value & EX_RUNDOWN_ACTIVE) {

	test	bl, 1
	jne	SHORT $LN12@
	lea	esi, DWORD PTR [edx+edx]
$LL7@:

; 136  :             }
; 137  :             
; 138  :             return;
; 139  :         } else {
; 140  :             //
; 141  :             // Rundown isn't active. Just try and decrement the count. Some other protector thread way come and/or
; 142  :             // go as we do this or rundown might be initiated. We detect this because the exchange will fail and
; 143  :             // we have to retry
; 144  :             //
; 145  : 
; 146  :             //
; 147  :             // For cache-aware rundown protection, it's possible that the value on this processor
; 148  :             // is actually 0 or some integer less than count, so this assert is not applicable.
; 149  :             // 
; 150  : 
; 151  :             NewValue = Value - EX_RUNDOWN_COUNT_INC * Count;

	mov	eax, ebx
	sub	eax, esi

; 152  : 
; 153  :             NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
; 154  :                                                                       (PVOID) NewValue,
; 155  :                                                                       (PVOID) Value);

	mov	edx, eax
	mov	edi, ecx
	mov	eax, ebx
	lock	 cmpxchg DWORD PTR [edi], edx

; 156  :             if (NewValue == Value) {

	cmp	eax, ebx
	je	SHORT $LN5@

; 157  :                 return;
; 158  :             }
; 159  :             Value = NewValue;

	mov	ebx, eax
	test	al, 1
	je	SHORT $LL7@
$LN12@:

; 112  :             PEX_RUNDOWN_WAIT_BLOCK WaitBlock;
; 113  : 
; 114  :             //
; 115  :             // Rundown is active. since we are one of the threads blocking rundown we have the right to follow
; 116  :             // the pointer and decrement the active count. If we are the last thread then we have the right to
; 117  :             // wake up the waiter. After doing this we can't touch the data structures again.
; 118  :             //
; 119  :             WaitBlock = (PEX_RUNDOWN_WAIT_BLOCK) (Value & (~EX_RUNDOWN_ACTIVE));
; 120  : 
; 121  :             //
; 122  :             // For cache-aware rundown protection, it's possible the count in the waitblock
; 123  :             // is actually zero at this point, so this assert is not applicable. We assert weakly
; 124  :             // only for uni-proc. 
; 125  :             //
; 126  : 
; 127  : #if defined (_WIN64) 
; 128  :             if (InterlockedExchangeAdd64((PLONGLONG)&WaitBlock->Count, -(LONGLONG)Count) == (LONGLONG) Count) {
; 129  : #else 
; 130  :             if (InterlockedExchangeAdd((PLONG)&WaitBlock->Count, -(LONG)Count) == (LONG) Count) {

	mov	eax, DWORD PTR _Count$[ebp]
	and	ebx, -2					; fffffffeH
	neg	eax
	mov	ecx, ebx
	lock	 xadd	 DWORD PTR [ecx], eax
	cmp	eax, DWORD PTR _Count$[ebp]
	jne	SHORT $LN5@

; 131  : #endif
; 132  :                 //
; 133  :                 // We are the last thread out. Wake up the waiter.
; 134  :                 //
; 135  :                 KeSetEvent (&WaitBlock->WakeEvent, 0, FALSE);

	push	0
	push	0
	add	ebx, 4
	push	ebx
	call	DWORD PTR __imp__KeSetEvent@12
$LN5@:
	pop	edi
	pop	esi
	pop	ebx

; 160  :         }
; 161  : 
; 162  :     } while (TRUE);
; 163  : }

	leave
	ret	0
@ExReleaseRundownProtectionEx_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_ExAllocateCacheAwareRundownProtection_k8@8
EXTRN	__imp_@ExInitializeRundownProtection@4:PROC
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__KeGetRecommendedSharedDataAlignment@0:PROC
EXTRN	__imp__KeNumberProcessors:BYTE
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExAllocateCacheAwareRundownProtection_k8@8
_TEXT	SEGMENT
_PoolType$ = 8						; size = 4
_PoolTag$ = 12						; size = 4
_ExAllocateCacheAwareRundownProtection_k8@8 PROC	; COMDAT

; 172  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 173  :     PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware;
; 174  :     PEX_RUNDOWN_REF RunRefPool;
; 175  :     PEX_RUNDOWN_REF CurrentRunRef;
; 176  :     ULONG PaddedSize;
; 177  :     ULONG Index;
; 178  : 
; 179  :     RunRefCacheAware = (PEX_RUNDOWN_REF_CACHE_AWARE) ExAllocatePoolWithTag (PoolType,
; 180  :                                               sizeof( EX_RUNDOWN_REF_CACHE_AWARE ),
; 181  :                                               PoolTag
; 182  :                                               );

	push	DWORD PTR _PoolTag$[ebp]
	mov	edi, DWORD PTR __imp__ExAllocatePoolWithTag@12
	push	16					; 00000010H
	push	DWORD PTR _PoolType$[ebp]
	call	edi
	mov	esi, eax

; 183  : 
; 184  :     if (NULL != RunRefCacheAware) {

	test	esi, esi
	je	$LN1@ExAllocate

; 185  : 
; 186  :         //
; 187  :         // Capture number of processors: this will be the # of rundown counts we use
; 188  :         //
; 189  :         RunRefCacheAware->Number = KeNumberProcessors;

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	movsx	eax, BYTE PTR [eax]
	mov	DWORD PTR [esi+12], eax

; 190  : 
; 191  :         //
; 192  :         // Determine size of each ref structure
; 193  :         //
; 194  :         if (RunRefCacheAware->Number > 1) {

	cmp	eax, 1
	jbe	SHORT $LN9@ExAllocate

; 195  :             PaddedSize = KeGetRecommendedSharedDataAlignment ();

	call	DWORD PTR __imp__KeGetRecommendedSharedDataAlignment@0
	mov	ebx, eax

; 196  :         } else {

	jmp	SHORT $LN8@ExAllocate
$LN9@ExAllocate:

; 197  :             PaddedSize = sizeof (EX_RUNDOWN_REF);

	push	4
	pop	ebx
$LN8@ExAllocate:

; 198  :         }
; 199  : 
; 200  : 
; 201  :         //
; 202  :         //  Remember the size
; 203  :         //
; 204  :         RunRefCacheAware->RunRefSize = PaddedSize;
; 205  : 
; 206  :         RunRefPool = (PEX_RUNDOWN_REF) ExAllocatePoolWithTag (PoolType,
; 207  :                                             PaddedSize * RunRefCacheAware->Number,
; 208  :                                             PoolTag);

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR _PoolTag$[ebp]
	imul	eax, ebx
	push	eax
	push	DWORD PTR _PoolType$[ebp]
	mov	DWORD PTR [esi+8], ebx
	call	edi

; 209  : 
; 210  :         if (RunRefPool == NULL) {

	test	eax, eax
	jne	SHORT $LN7@ExAllocate
$LN17@ExAllocate:

; 211  :             ExFreePool (RunRefCacheAware);

	push	0
	push	esi
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 212  :             return NULL;

	xor	eax, eax
	jmp	SHORT $LN11@ExAllocate
$LN7@ExAllocate:

; 213  :         }
; 214  : 
; 215  :         //
; 216  :         // Check if pool is aligned if this is a multi-proc
; 217  :         //
; 218  :         if ((RunRefCacheAware->Number > 1) && 
; 219  :             !EXP_IS_ALIGNED_ON_BOUNDARY (RunRefPool, PaddedSize)) {

	cmp	DWORD PTR [esi+12], 1
	jbe	SHORT $LN6@ExAllocate
	lea	ecx, DWORD PTR [ebx-1]
	test	ecx, eax
	je	SHORT $LN6@ExAllocate

; 220  : 
; 221  :             //
; 222  :             //  We will allocate a padded size, free the old pool
; 223  :             //
; 224  :             ExFreePool (RunRefPool);

	push	0
	push	eax
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 225  : 
; 226  :             //
; 227  :             //  Allocate enough padding so we can start the refs on an aligned boundary
; 228  :             //
; 229  :             RunRefPool = (PEX_RUNDOWN_REF) ExAllocatePoolWithTag (PoolType,
; 230  :                                                 PaddedSize * RunRefCacheAware->Number + PaddedSize,
; 231  :                                                 PoolTag);

	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR _PoolTag$[ebp]
	inc	eax
	imul	eax, ebx
	push	eax
	push	DWORD PTR _PoolType$[ebp]
	call	edi

; 232  : 
; 233  :             if (RunRefPool == NULL) {

	test	eax, eax

; 234  :                 ExFreePool (RunRefCacheAware);
; 235  :                 return NULL;

	je	SHORT $LN17@ExAllocate

; 236  :             }
; 237  : 
; 238  :             CurrentRunRef = (PEX_RUNDOWN_REF) EXP_ALIGN_UP_PTR_ON_BOUNDARY (RunRefPool, PaddedSize);

	lea	ecx, DWORD PTR [eax+ebx-1]
	dec	ebx
	not	ebx
	and	ecx, ebx

; 239  : 
; 240  :         } else {

	jmp	SHORT $LN4@ExAllocate
$LN6@ExAllocate:

; 241  : 
; 242  :             //
; 243  :             //  Already aligned pool
; 244  :             //
; 245  :             CurrentRunRef = RunRefPool;

	mov	ecx, eax
$LN4@ExAllocate:

; 246  :         }
; 247  : 
; 248  :         //
; 249  :         //  Remember the pool block to free
; 250  :         //
; 251  :         RunRefCacheAware->PoolToFree = RunRefPool;
; 252  :         RunRefCacheAware->RunRefs = CurrentRunRef;
; 253  : 
; 254  :         for (Index = 0; Index < RunRefCacheAware->Number; Index++) {

	xor	edi, edi
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	cmp	DWORD PTR [esi+12], edi
	jbe	SHORT $LN1@ExAllocate
$LL3@ExAllocate:

; 255  :             CurrentRunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);

	xor	edx, edx
	mov	eax, edi
	div	DWORD PTR [esi+12]
	mov	ecx, edx
	imul	ecx, DWORD PTR [esi+8]
	add	ecx, DWORD PTR [esi]

; 256  :             ExInitializeRundownProtection (CurrentRunRef);

	call	DWORD PTR __imp_@ExInitializeRundownProtection@4
	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jb	SHORT $LL3@ExAllocate
$LN1@ExAllocate:

; 257  :         }
; 258  :     }
; 259  : 
; 260  :     return RunRefCacheAware;

	mov	eax, esi
$LN11@ExAllocate:
	pop	edi
	pop	esi
	pop	ebx

; 261  : }

	pop	ebp
	ret	8
_ExAllocateCacheAwareRundownProtection_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_ExSizeOfRundownProtectionCacheAware_k8@0
; Function compile flags: /Ogsp
;	COMDAT _ExSizeOfRundownProtectionCacheAware_k8@0
_TEXT	SEGMENT
_ExSizeOfRundownProtectionCacheAware_k8@0 PROC		; COMDAT

; 269  :     SIZE_T RundownSize;
; 270  :     ULONG PaddedSize;
; 271  :     ULONG Number;
; 272  : 
; 273  :     RundownSize = sizeof (EX_RUNDOWN_REF_CACHE_AWARE);
; 274  : 
; 275  :     //
; 276  :     // Determine size of each ref structure
; 277  :     //
; 278  : 
; 279  :     Number = KeNumberProcessors;

	mov	eax, DWORD PTR __imp__KeNumberProcessors
	push	esi
	movsx	esi, BYTE PTR [eax]

; 280  : 
; 281  :     if (Number > 1) {

	cmp	esi, 1
	jbe	SHORT $LN2@ExSizeOfRu

; 282  : 
; 283  :        //
; 284  :        // Allocate more to account for alignment (pessimistic size)
; 285  :        //
; 286  : 
; 287  :        PaddedSize= KeGetRecommendedSharedDataAlignment () * (Number+1);

	call	DWORD PTR __imp__KeGetRecommendedSharedDataAlignment@0
	inc	esi
	imul	eax, esi

; 288  : 
; 289  : 
; 290  :     } else {

	jmp	SHORT $LN1@ExSizeOfRu
$LN2@ExSizeOfRu:

; 291  :         PaddedSize = sizeof (EX_RUNDOWN_REF);

	push	4
	pop	eax
$LN1@ExSizeOfRu:

; 292  :     }
; 293  : 
; 294  :     RundownSize += PaddedSize;

	add	eax, 16					; 00000010H
	pop	esi

; 295  : 
; 296  :     return RundownSize;
; 297  : }

	ret	0
_ExSizeOfRundownProtectionCacheAware_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_ExInitializeRundownProtectionCacheAware_k8@8
; Function compile flags: /Ogsp
;	COMDAT _ExInitializeRundownProtectionCacheAware_k8@8
_TEXT	SEGMENT
_RunRefCacheAware$ = 8					; size = 4
_RunRefSize$ = 12					; size = 4
_ExInitializeRundownProtectionCacheAware_k8@8 PROC	; COMDAT

; 305  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 306  :     PEX_RUNDOWN_REF CurrentRunRef;
; 307  :     ULONG PaddedSize;
; 308  :     LONG Number;
; 309  :     ULONG Index;
; 310  :     ULONG ArraySize;
; 311  : 
; 312  :     //
; 313  :     //  Reverse engineer the size of each rundown structure based on the size
; 314  :     //  that is passed in
; 315  :     //
; 316  : 
; 317  :     CurrentRunRef = (PEX_RUNDOWN_REF) (((ULONG_PTR) RunRefCacheAware) + sizeof (EX_RUNDOWN_REF_CACHE_AWARE));
; 318  : 
; 319  :     ArraySize = (ULONG) (RunRefSize - sizeof( EX_RUNDOWN_REF_CACHE_AWARE )); 

	mov	ebx, DWORD PTR _RunRefSize$[ebp]
	push	esi
	mov	esi, DWORD PTR _RunRefCacheAware$[ebp]
	push	edi

; 320  :     
; 321  :     if (ArraySize == sizeof (EX_RUNDOWN_REF)) {

	push	4
	add	ebx, -16				; fffffff0H
	pop	ecx
	lea	edi, DWORD PTR [esi+16]
	cmp	ebx, ecx
	jne	SHORT $LN5@ExInitiali

; 322  :         Number = 1;

	xor	eax, eax
	inc	eax

; 323  :         PaddedSize = ArraySize;
; 324  :     } else {

	jmp	SHORT $LN4@ExInitiali
$LN5@ExInitiali:

; 325  : 
; 326  :         PaddedSize = KeGetRecommendedSharedDataAlignment();

	call	DWORD PTR __imp__KeGetRecommendedSharedDataAlignment@0
	mov	ecx, eax

; 327  : 
; 328  :         Number =  ArraySize / PaddedSize - 1;

	xor	edx, edx
	mov	eax, ebx
	div	ecx

; 329  : 
; 330  :         CurrentRunRef = (PEX_RUNDOWN_REF) EXP_ALIGN_UP_PTR_ON_BOUNDARY (CurrentRunRef , PaddedSize);

	lea	edx, DWORD PTR [ecx-1]
	lea	edi, DWORD PTR [ecx+edi-1]
	not	edx
	dec	eax
	and	edi, edx
$LN4@ExInitiali:

; 331  :     }
; 332  : 
; 333  :     RunRefCacheAware->RunRefs = CurrentRunRef;

	mov	DWORD PTR [esi], edi

; 334  :     RunRefCacheAware->RunRefSize = PaddedSize;
; 335  :     RunRefCacheAware->Number = Number;
; 336  : 
; 337  :     //
; 338  :     //  This signature will signify that this structure should not be freed
; 339  :     //  via ExFreeCacheAwareRundownProtection: if there's a bugcheck with an attempt
; 340  :     //  to access this address & ExFreeCacheAwareRundownProtection on the stack,
; 341  :     //  the caller of ExFree* is at fault.
; 342  :     //
; 343  : 
; 344  :     RunRefCacheAware->PoolToFree = UintToPtr (0x0BADCA11);
; 345  : 
; 346  :     for (Index = 0; Index < RunRefCacheAware->Number; Index++) {

	xor	edi, edi
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+4], 195938833		; 0badca11H
	test	eax, eax
	jbe	SHORT $LN1@ExInitiali
$LL3@ExInitiali:

; 347  :         CurrentRunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);

	xor	edx, edx
	mov	eax, edi
	div	DWORD PTR [esi+12]
	mov	ecx, edx
	imul	ecx, DWORD PTR [esi+8]
	add	ecx, DWORD PTR [esi]

; 348  :         ExInitializeRundownProtection (CurrentRunRef);

	call	DWORD PTR __imp_@ExInitializeRundownProtection@4
	inc	edi
	cmp	edi, DWORD PTR [esi+12]
	jb	SHORT $LL3@ExInitiali
$LN1@ExInitiali:
	pop	edi
	pop	esi
	pop	ebx

; 349  :     }
; 350  : }

	pop	ebp
	ret	8
_ExInitializeRundownProtectionCacheAware_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_ExFreeCacheAwareRundownProtection_k8@4
; Function compile flags: /Ogsp
;	COMDAT _ExFreeCacheAwareRundownProtection_k8@4
_TEXT	SEGMENT
_RunRefCacheAware$ = 8					; size = 4
_ExFreeCacheAwareRundownProtection_k8@4 PROC		; COMDAT

; 357  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 358  :     ExFreePool (RunRefCacheAware->PoolToFree);

	mov	esi, DWORD PTR __imp__ExFreePoolWithTag@8
	push	edi
	mov	edi, DWORD PTR _RunRefCacheAware$[ebp]
	push	0
	push	DWORD PTR [edi+4]
	call	esi

; 359  :     ExFreePool (RunRefCacheAware);

	push	0
	push	edi
	call	esi
	pop	edi
	pop	esi

; 360  : }

	pop	ebp
	ret	4
_ExFreeCacheAwareRundownProtection_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExAcquireRundownProtectionCacheAware_k8@4
EXTRN	__imp_@ExAcquireRundownProtection@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExAcquireRundownProtectionCacheAware_k8@4
_TEXT	SEGMENT
@ExAcquireRundownProtectionCacheAware_k8@4 PROC		; COMDAT
; _RunRefCacheAware$ = ecx

; 370  :    return ExAcquireRundownProtection (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware));

	mov	al, BYTE PTR fs:81
	movzx	eax, al
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	imul	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR [ecx]
	mov	ecx, edx
	jmp	DWORD PTR __imp_@ExAcquireRundownProtection@4
@ExAcquireRundownProtectionCacheAware_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExReleaseRundownProtectionCacheAware_k8@4
EXTRN	__imp_@ExReleaseRundownProtection@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExReleaseRundownProtectionCacheAware_k8@4
_TEXT	SEGMENT
@ExReleaseRundownProtectionCacheAware_k8@4 PROC		; COMDAT
; _RunRefCacheAware$ = ecx

; 380  :     ExReleaseRundownProtection (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware));

	mov	al, BYTE PTR fs:81
	push	esi
	mov	esi, ecx
	movzx	eax, al
	xor	edx, edx
	div	DWORD PTR [esi+12]
	mov	ecx, edx
	imul	ecx, DWORD PTR [esi+8]
	add	ecx, DWORD PTR [esi]
	pop	esi
	jmp	DWORD PTR __imp_@ExReleaseRundownProtection@4
@ExReleaseRundownProtectionCacheAware_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExAcquireRundownProtectionCacheAwareEx_k8@8
EXTRN	__imp_@ExAcquireRundownProtectionEx@8:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExAcquireRundownProtectionCacheAwareEx_k8@8
_TEXT	SEGMENT
@ExAcquireRundownProtectionCacheAwareEx_k8@8 PROC	; COMDAT
; _RunRefCacheAware$ = ecx
; _Count$ = edx

; 391  :    return ExAcquireRundownProtectionEx (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware), Count);

	mov	al, BYTE PTR fs:81
	movzx	eax, al
	push	esi
	mov	esi, edx
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, edx
	imul	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]
	mov	edx, esi
	mov	ecx, eax
	pop	esi
	jmp	DWORD PTR __imp_@ExAcquireRundownProtectionEx@8
@ExAcquireRundownProtectionCacheAwareEx_k8@8 ENDP
_TEXT	ENDS
PUBLIC	@ExReleaseRundownProtectionCacheAwareEx_k8@8
EXTRN	__imp_@ExReleaseRundownProtectionEx@8:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExReleaseRundownProtectionCacheAwareEx_k8@8
_TEXT	SEGMENT
@ExReleaseRundownProtectionCacheAwareEx_k8@8 PROC	; COMDAT
; _RunRefCacheAware$ = ecx
; _Count$ = edx

; 402  :     ExReleaseRundownProtectionEx (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware), Count);

	mov	al, BYTE PTR fs:81
	push	esi
	push	edi
	mov	edi, edx
	mov	esi, ecx
	movzx	eax, al
	xor	edx, edx
	div	DWORD PTR [esi+12]
	mov	ecx, edx
	imul	ecx, DWORD PTR [esi+8]
	add	ecx, DWORD PTR [esi]
	mov	edx, edi
	pop	edi
	pop	esi
	jmp	DWORD PTR __imp_@ExReleaseRundownProtectionEx@8
@ExReleaseRundownProtectionCacheAwareEx_k8@8 ENDP
_TEXT	ENDS
PUBLIC	@ExWaitForRundownProtectionReleaseCacheAware_k8@4
EXTRN	__imp__KeWaitForSingleObject@20:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExWaitForRundownProtectionReleaseCacheAware_k8@4
_TEXT	SEGMENT
_WaitBlock$ = -32					; size = 20
_TotalCount$ = -12					; size = 4
tv174 = -8						; size = 4
_Index$ = -4						; size = 4
@ExWaitForRundownProtectionReleaseCacheAware_k8@4 PROC	; COMDAT
; _RunRefCacheAware$ = ecx

; 411  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 412  :     PEX_RUNDOWN_REF RunRef;
; 413  :     EX_RUNDOWN_WAIT_BLOCK WaitBlock;
; 414  :     ULONG_PTR Value, NewValue;
; 415  :     ULONG_PTR TotalCount;
; 416  :     ULONG Index;
; 417  : 
; 418  : 
; 419  :     //
; 420  :     // Obtain the outstanding references by totalling up all the
; 421  :     // counts for all the RunRef structures.
; 422  :     //
; 423  :     TotalCount = 0;

	xor	eax, eax
	push	esi

; 424  :     WaitBlock.Count = 0;
; 425  : 
; 426  :     for ( Index = 0; Index < RunRefCacheAware->Number; Index++) {

	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR _TotalCount$[ebp], eax
	mov	DWORD PTR _WaitBlock$[ebp], eax
	mov	DWORD PTR _Index$[ebp], eax
	cmp	esi, eax
	jbe	SHORT $LN1@
	lea	eax, DWORD PTR _WaitBlock$[ebp]
	or	eax, 1
	push	ebx
	mov	DWORD PTR tv174[ebp], eax
	push	edi
$LL19@:

; 427  : 
; 428  :         RunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);

	mov	eax, DWORD PTR _Index$[ebp]
	xor	edx, edx
	div	esi
	imul	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR [ecx]

; 429  : 
; 430  :         //
; 431  :         //  Extract current count &  mark rundown active atomically
; 432  :         //
; 433  :         Value = RunRef->Count;

	mov	esi, DWORD PTR [edx]

; 434  : 
; 435  :         do {
; 436  :             
; 437  :             //
; 438  :             //  Indicate that the on-stack count should be used for callers of release rundown protection
; 439  :             //
; 440  : 
; 441  :             NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;
; 442  : 
; 443  :             NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
; 444  :                                                                       (PVOID) NewValue,
; 445  :                                                                       (PVOID) Value);

	jmp	SHORT $LN22@
$LL6@:

; 447  : 
; 448  :                 //
; 449  :                 //  Succeeded in making rundown active
; 450  :                 //
; 451  : 
; 452  :                 break;
; 453  :             }
; 454  : 
; 455  :             Value = NewValue;

	mov	esi, eax
$LN22@:

; 434  : 
; 435  :         do {
; 436  :             
; 437  :             //
; 438  :             //  Indicate that the on-stack count should be used for callers of release rundown protection
; 439  :             //
; 440  : 
; 441  :             NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;
; 442  : 
; 443  :             NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
; 444  :                                                                       (PVOID) NewValue,
; 445  :                                                                       (PVOID) Value);

	mov	edi, DWORD PTR tv174[ebp]
	mov	eax, esi
	mov	ebx, edx
	lock	 cmpxchg DWORD PTR [ebx], edi

; 446  :             if (NewValue == Value) {

	cmp	eax, esi
	jne	SHORT $LL6@

; 456  : 
; 457  :         } while (TRUE);
; 458  : 
; 459  :         //
; 460  :         // Add outstanding references on this processor to the total
; 461  :         // Ignore overflow: note the rundown active bit will be zero for Value
; 462  :         // so we will not add up those bits
; 463  :         //
; 464  :         TotalCount +=  Value;

	mov	edi, DWORD PTR _TotalCount$[ebp]
	add	edi, esi
	inc	DWORD PTR _Index$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR _TotalCount$[ebp], edi
	cmp	DWORD PTR _Index$[ebp], esi
	jb	SHORT $LL19@

; 465  :     }
; 466  : 
; 467  :     //
; 468  :     // If total count was zero there are no outstanding references
; 469  :     // active at this point - since no refs can creep in after we have
; 470  :     // set the rundown flag on each processor
; 471  :     //
; 472  : 
; 473  :     //
; 474  :     //  If total count was zero there are no outstanding references
; 475  :     //  active at this point - since no refs can creep in after we have
; 476  :     //  set the rundown flag on each processor
; 477  :     //
; 478  :     if (TotalCount != 0) {

	xor	esi, esi
	cmp	edi, esi
	je	SHORT $LN20@

; 479  : 
; 480  :         //
; 481  :         //  Extract actual number of waiters - count is biased by 2
; 482  :         //
; 483  :         TotalCount >>= EX_RUNDOWN_COUNT_SHIFT;
; 484  : 
; 485  :         //
; 486  :         //  Initialize the gate - since the dereferencer can decrement the count as soon
; 487  :         //  as we add the per-processor count to the on-stack count
; 488  :         //
; 489  :         KeInitializeEvent (&WaitBlock.WakeEvent, SynchronizationEvent, FALSE);

	push	esi
	push	1
	lea	eax, DWORD PTR _WaitBlock$[ebp+4]
	push	eax
	shr	edi, 1
	call	DWORD PTR __imp__KeInitializeEvent@12

; 490  : 
; 491  :         //
; 492  :         //  Add the total count to the on-stack count. If the result is zero,
; 493  :         //  there are no more outstanding references. Otherwise wait to be signaled
; 494  :         //
; 495  : #if defined(_WIN64)
; 496  :         if (InterlockedExchangeAdd64 ((PLONGLONG) &WaitBlock.Count,
; 497  :                                        (LONGLONG) TotalCount)  != (-(LONGLONG) TotalCount)) {
; 498  : #else
; 499  :         if (InterlockedExchangeAdd ((PLONG) &WaitBlock.Count,
; 500  :                                     (LONG) TotalCount)  != (-(LONG)TotalCount)) {

	mov	eax, edi
	lea	ecx, DWORD PTR _WaitBlock$[ebp]
	lock	 xadd	 DWORD PTR [ecx], eax
	neg	edi
	cmp	eax, edi
	je	SHORT $LN20@

; 501  : #endif
; 502  :             KeWaitForSingleObject (&WaitBlock.WakeEvent,
; 503  :                                    Executive,
; 504  :                                    KernelMode,
; 505  :                                    FALSE,
; 506  :                                    NULL);

	push	esi
	push	esi
	push	esi
	push	esi
	lea	eax, DWORD PTR _WaitBlock$[ebp+4]
	push	eax
	call	DWORD PTR __imp__KeWaitForSingleObject@20
$LN20@:
	pop	edi
	pop	ebx
$LN1@:
	pop	esi

; 507  : 
; 508  :         }
; 509  :                   
; 510  :     }
; 511  : 
; 512  :     return;
; 513  : }

	leave
	ret	0
@ExWaitForRundownProtectionReleaseCacheAware_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExReInitializeRundownProtectionCacheAware_k8@4
; Function compile flags: /Ogsp
;	COMDAT @ExReInitializeRundownProtectionCacheAware_k8@4
_TEXT	SEGMENT
@ExReInitializeRundownProtectionCacheAware_k8@4 PROC	; COMDAT
; _RunRefCacheAware$ = ecx

; 521  : {

	npad	2
	push	esi

; 522  :     PEX_RUNDOWN_REF RunRef;
; 523  :     ULONG Index;
; 524  : 
; 525  : 
; 526  :     for ( Index = 0; Index < RunRefCacheAware->Number; Index++) {

	mov	esi, DWORD PTR [ecx+12]
	push	edi
	xor	edi, edi
	test	esi, esi
	jbe	SHORT $LN1@
	push	ebx
$LL3@:

; 527  :         RunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);

	xor	edx, edx
	mov	eax, edi
	div	esi

; 528  :         InterlockedExchangePointer (&RunRef->Ptr, NULL);

	xor	ebx, ebx
	imul	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR [ecx]
	xchg	DWORD PTR [edx], ebx
	mov	esi, DWORD PTR [ecx+12]
	inc	edi
	cmp	edi, esi
	jb	SHORT $LL3@
	pop	ebx
$LN1@:
	pop	edi
	pop	esi

; 529  :     }
; 530  : }

	ret	0
@ExReInitializeRundownProtectionCacheAware_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExRundownCompletedCacheAware_k8@4
; Function compile flags: /Ogsp
;	COMDAT @ExRundownCompletedCacheAware_k8@4
_TEXT	SEGMENT
@ExRundownCompletedCacheAware_k8@4 PROC			; COMDAT
; _RunRefCacheAware$ = ecx

; 538  : {

	npad	2
	push	esi

; 539  :     PEX_RUNDOWN_REF RunRef;
; 540  :     ULONG Index;
; 541  : 
; 542  :     for ( Index = 0; Index < RunRefCacheAware->Number; Index++) {

	mov	esi, DWORD PTR [ecx+12]
	push	edi
	xor	edi, edi
	test	esi, esi
	jbe	SHORT $LN1@
	push	ebx
$LL3@:

; 543  :         RunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);

	xor	edx, edx
	mov	eax, edi
	div	esi

; 544  :         InterlockedExchangePointer (&RunRef->Ptr, (PVOID) EX_RUNDOWN_ACTIVE);

	xor	ebx, ebx
	inc	ebx
	imul	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR [ecx]
	xchg	DWORD PTR [edx], ebx
	mov	esi, DWORD PTR [ecx+12]
	inc	edi
	cmp	edi, esi
	jb	SHORT $LL3@
	pop	ebx
$LN1@:
	pop	edi
	pop	esi

; 545  :     }
; 546  : }

	ret	0
@ExRundownCompletedCacheAware_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ExEnterCriticalRegionAndAcquireResourceExclusive_k8@4
EXTRN	__imp__ExAcquireResourceExclusiveLite@8:PROC
EXTRN	__imp__KeEnterCriticalRegion@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExEnterCriticalRegionAndAcquireResourceExclusive_k8@4
_TEXT	SEGMENT
_Resource$ = 8						; size = 4
_ExEnterCriticalRegionAndAcquireResourceExclusive_k8@4 PROC ; COMDAT

; 552  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 553  :     KeEnterCriticalRegion();

	call	DWORD PTR __imp__KeEnterCriticalRegion@0

; 554  :     ExAcquireResourceExclusiveLite(Resource, TRUE);

	push	1
	push	DWORD PTR _Resource$[ebp]
	call	DWORD PTR __imp__ExAcquireResourceExclusiveLite@8

; 555  :     return (PVOID) _PsGetCurrentThread()->Tcb.Win32Thread;

	call	DWORD PTR __imp__KeGetCurrentThread@0
	mov	eax, DWORD PTR [eax+340]

; 556  : }

	pop	ebp
	ret	4
_ExEnterCriticalRegionAndAcquireResourceExclusive_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ExEnterCriticalRegionAndAcquireResourceShared_k8@4
EXTRN	__imp__ExAcquireResourceSharedLite@8:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExEnterCriticalRegionAndAcquireResourceShared_k8@4
_TEXT	SEGMENT
_Resource$ = 8						; size = 4
_ExEnterCriticalRegionAndAcquireResourceShared_k8@4 PROC ; COMDAT

; 562  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 563  :     KeEnterCriticalRegion();

	call	DWORD PTR __imp__KeEnterCriticalRegion@0

; 564  :     ExAcquireResourceSharedLite(Resource, TRUE);

	push	1
	push	DWORD PTR _Resource$[ebp]
	call	DWORD PTR __imp__ExAcquireResourceSharedLite@8

; 565  :     return (PVOID) _PsGetCurrentThread()->Tcb.Win32Thread;

	call	DWORD PTR __imp__KeGetCurrentThread@0
	mov	eax, DWORD PTR [eax+340]

; 566  : }

	pop	ebp
	ret	4
_ExEnterCriticalRegionAndAcquireResourceShared_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExReleaseResourceAndLeaveCriticalRegion_k8@4
EXTRN	__imp__KeLeaveCriticalRegion@0:PROC
EXTRN	__imp_@ExReleaseResourceLite@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExReleaseResourceAndLeaveCriticalRegion_k8@4
_TEXT	SEGMENT
@ExReleaseResourceAndLeaveCriticalRegion_k8@4 PROC	; COMDAT
; _Resource$ = ecx

; 573  :     ExReleaseResourceLite(Resource);

	call	DWORD PTR __imp_@ExReleaseResourceLite@4

; 574  :     KeLeaveCriticalRegion();

	jmp	DWORD PTR __imp__KeLeaveCriticalRegion@0
@ExReleaseResourceAndLeaveCriticalRegion_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlImageNtHeaderEx_k8@20
EXTRN	__imp__MmHighestUserAddress:DWORD
; Function compile flags: /Ogsp
;	COMDAT _RtlImageNtHeaderEx_k8@20
_TEXT	SEGMENT
_Flags$ = 8						; size = 4
_Base$ = 12						; size = 4
_Size$ = 16						; size = 8
_OutHeaders$ = 24					; size = 4
_RtlImageNtHeaderEx_k8@20 PROC				; COMDAT

; 602  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 603  :     PIMAGE_NT_HEADERS NtHeaders = 0;
; 604  :     ULONG e_lfanew = 0;
; 605  :     BOOLEAN RangeCheck = 0;
; 606  :     NTSTATUS Status = 0;
; 607  :     const ULONG ValidFlags = 
; 608  :         RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK;
; 609  : 
; 610  :     if (OutHeaders != NULL) {

	mov	edi, DWORD PTR _OutHeaders$[ebp]
	test	edi, edi
	je	$LN19@RtlImageNt

; 611  :         *OutHeaders = NULL;
; 612  :     }
; 613  :     if (OutHeaders == NULL) {
; 614  :         Status = STATUS_INVALID_PARAMETER;
; 615  :         goto Exit;
; 616  :     }
; 617  :     if ((Flags & ~ValidFlags) != 0) {

	mov	eax, DWORD PTR _Flags$[ebp]
	and	DWORD PTR [edi], 0
	test	eax, -2					; fffffffeH

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jne	$LN19@RtlImageNt
	mov	edx, DWORD PTR _Base$[ebp]
	test	edx, edx
	je	$LN19@RtlImageNt

; 618  :         Status = STATUS_INVALID_PARAMETER;
; 619  :         goto Exit;
; 620  :     }
; 621  :     if (Base == NULL || Base == (PVOID)(LONG_PTR)-1) {

	cmp	edx, -1
	je	$LN19@RtlImageNt

; 623  :         goto Exit;
; 624  :     }
; 625  : 
; 626  :     RangeCheck = ((Flags & RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK) == 0);

	not	al
	and	al, 1
	mov	cl, al

; 627  :     if (RangeCheck) {

	je	SHORT $LN16@RtlImageNt

; 628  :         if (Size < sizeof(IMAGE_DOS_HEADER)) {

	cmp	DWORD PTR _Size$[ebp+4], 0
	ja	SHORT $LN16@RtlImageNt
	jb	SHORT $LN30@RtlImageNt
	cmp	DWORD PTR _Size$[ebp], 64		; 00000040H
	jae	SHORT $LN16@RtlImageNt
$LN30@RtlImageNt:

; 629  :             Status = STATUS_INVALID_IMAGE_FORMAT;

	mov	eax, -1073741701			; c000007bH

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jmp	SHORT $LN1@RtlImageNt
$LN16@RtlImageNt:

; 630  :             goto Exit;
; 631  :         }
; 632  :     }
; 633  : 
; 634  :     //
; 635  :     // Exception handling is not available in the boot loader, and exceptions
; 636  :     // were not historically caught here in kernel mode. Drivers are considered
; 637  :     // trusted, so we can't get an exception here due to a bad file, but we
; 638  :     // could take an inpage error.
; 639  :     //
; 640  : #define EXIT goto Exit
; 641  :     if (((PIMAGE_DOS_HEADER)Base)->e_magic != IMAGE_DOS_SIGNATURE) {

	mov	eax, 23117				; 00005a4dH
	cmp	WORD PTR [edx], ax

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jne	SHORT $LN30@RtlImageNt
	mov	eax, DWORD PTR [edx+60]
	test	cl, cl
	je	SHORT $LN33@RtlImageNt
	xor	ecx, ecx
	cmp	ecx, DWORD PTR _Size$[ebp+4]
	ja	SHORT $LN30@RtlImageNt

; 642  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 643  :         EXIT;
; 644  :     }
; 645  :     e_lfanew = ((PIMAGE_DOS_HEADER)Base)->e_lfanew;
; 646  :     if (RangeCheck) {
; 647  :         if (e_lfanew >= Size
; 648  : #define SIZEOF_PE_SIGNATURE 4
; 649  :             || e_lfanew >= (MAXULONG - SIZEOF_PE_SIGNATURE - sizeof(IMAGE_FILE_HEADER))
; 650  :             || (e_lfanew + SIZEOF_PE_SIGNATURE + sizeof(IMAGE_FILE_HEADER)) >= Size
; 651  :             ) {

	jb	SHORT $LN31@RtlImageNt
	cmp	eax, DWORD PTR _Size$[ebp]
	jae	SHORT $LN30@RtlImageNt
$LN31@RtlImageNt:
	cmp	eax, -25				; ffffffe7H
	jae	SHORT $LN30@RtlImageNt
	push	esi
	xor	esi, esi
	cmp	esi, DWORD PTR _Size$[ebp+4]
	lea	ecx, DWORD PTR [eax+24]
	pop	esi
	jb	SHORT $LN33@RtlImageNt
	ja	SHORT $LN30@RtlImageNt
	cmp	ecx, DWORD PTR _Size$[ebp]

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jae	SHORT $LN30@RtlImageNt
$LN33@RtlImageNt:

; 652  :             Status = STATUS_INVALID_IMAGE_FORMAT;
; 653  :             EXIT;
; 654  :         }
; 655  :     }
; 656  : 
; 657  :     NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + e_lfanew);

	lea	ecx, DWORD PTR [eax+edx]

; 658  : 
; 659  :     //
; 660  :     // In kernelmode, do not cross from usermode address to kernelmode address.
; 661  :     //
; 662  :     if (Base < MM_HIGHEST_USER_ADDRESS) {

	mov	eax, DWORD PTR __imp__MmHighestUserAddress
	mov	eax, DWORD PTR [eax]
	cmp	edx, eax
	jae	SHORT $LN5@RtlImageNt

; 663  :         if ((PVOID)NtHeaders >= MM_HIGHEST_USER_ADDRESS) {

	cmp	ecx, eax

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jae	SHORT $LN30@RtlImageNt
	lea	edx, DWORD PTR [ecx+248]
	cmp	edx, eax
	jae	SHORT $LN30@RtlImageNt
$LN5@RtlImageNt:

; 664  :             Status = STATUS_INVALID_IMAGE_FORMAT;
; 665  :             EXIT;
; 666  :         }
; 667  :         //
; 668  :         // Note that this check is slightly overeager since IMAGE_NT_HEADERS has
; 669  :         // a builtin array of data_directories that may be larger than the image
; 670  :         // actually has. A better check would be to add FileHeader.SizeOfOptionalHeader,
; 671  :         // after ensuring that the FileHeader does not cross the u/k boundary.
; 672  :         //
; 673  :         if ((PVOID)((PCHAR)NtHeaders + sizeof (IMAGE_NT_HEADERS)) >= MM_HIGHEST_USER_ADDRESS) {
; 674  :             Status = STATUS_INVALID_IMAGE_FORMAT;
; 675  :             EXIT;
; 676  :         }
; 677  :     }
; 678  : 
; 679  :     if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {

	cmp	DWORD PTR [ecx], 17744			; 00004550H

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jne	SHORT $LN30@RtlImageNt
	xor	eax, eax

; 687  :         *OutHeaders = NtHeaders;

	mov	DWORD PTR [edi], ecx
$LN1@RtlImageNt:
	pop	edi

; 688  :     }
; 689  :     return Status;
; 690  : }

	pop	ebp
	ret	20					; 00000014H
$LN19@RtlImageNt:

; 622  :         Status = STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
$Exit$26040:

; 686  :     if (NT_SUCCESS(Status)) {

	jmp	SHORT $LN1@RtlImageNt
_RtlImageNtHeaderEx_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_RtlImageNtHeader_k8@4
; Function compile flags: /Ogsp
;	COMDAT _RtlImageNtHeader_k8@4
_TEXT	SEGMENT
_NtHeaders$ = -4					; size = 4
_Base$ = 8						; size = 4
_RtlImageNtHeader_k8@4 PROC				; COMDAT

; 698  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 699  :     PIMAGE_NT_HEADERS NtHeaders = NULL;

	xor	eax, eax

; 700  :     (VOID)RtlImageNtHeaderEx_k8(RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK, Base, 0, &NtHeaders);

	lea	ecx, DWORD PTR _NtHeaders$[ebp]
	push	ecx
	push	eax
	push	eax
	push	DWORD PTR _Base$[ebp]
	mov	DWORD PTR _NtHeaders$[ebp], eax
	push	1
	call	_RtlImageNtHeaderEx_k8@20

; 701  :     return NtHeaders;

	mov	eax, DWORD PTR _NtHeaders$[ebp]

; 702  : }

	leave
	ret	4
_RtlImageNtHeader_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_RtlSectionTableFromVirtualAddress_k8@12
; Function compile flags: /Ogsp
;	COMDAT _RtlSectionTableFromVirtualAddress_k8@12
_TEXT	SEGMENT
_NtHeaders$ = 8						; size = 4
_Base$ = 12						; size = 4
_Address$ = 16						; size = 4
_RtlSectionTableFromVirtualAddress_k8@12 PROC		; COMDAT

; 712  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 713  :     ULONG i;
; 714  :     PIMAGE_SECTION_HEADER NtSection;
; 715  : 
; 716  :     NtSection = IMAGE_FIRST_SECTION( NtHeaders );

	mov	ecx, DWORD PTR _NtHeaders$[ebp]
	movzx	eax, WORD PTR [ecx+20]
	lea	eax, DWORD PTR [eax+ecx+24]

; 717  :     for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {

	movzx	ecx, WORD PTR [ecx+6]
	push	esi
	xor	esi, esi
	push	edi
	test	ecx, ecx
	jbe	SHORT $LN2@RtlSection
$LL4@RtlSection:

; 718  :         if ((ULONG)Address >= NtSection->VirtualAddress &&
; 719  :             (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
; 720  :            ) {

	mov	edx, DWORD PTR [eax+12]
	cmp	DWORD PTR _Address$[ebp], edx
	jb	SHORT $LN1@RtlSection
	mov	edi, DWORD PTR [eax+16]
	add	edi, edx
	cmp	DWORD PTR _Address$[ebp], edi
	jb	SHORT $LN5@RtlSection
$LN1@RtlSection:

; 721  :             return NtSection;
; 722  :             }
; 723  :         ++NtSection;

	add	eax, 40					; 00000028H
	inc	esi
	cmp	esi, ecx
	jb	SHORT $LL4@RtlSection
$LN2@RtlSection:

; 724  :         }
; 725  : 
; 726  :     return NULL;

	xor	eax, eax
$LN5@RtlSection:
	pop	edi
	pop	esi

; 727  : }

	pop	ebp
	ret	12					; 0000000cH
_RtlSectionTableFromVirtualAddress_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_RtlAddressInSectionTable_k8@12
; Function compile flags: /Ogsp
;	COMDAT _RtlAddressInSectionTable_k8@12
_TEXT	SEGMENT
_NtHeaders$ = 8						; size = 4
_Base$ = 12						; size = 4
_Address$ = 16						; size = 4
_RtlAddressInSectionTable_k8@12 PROC			; COMDAT

; 736  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 737  :     PIMAGE_SECTION_HEADER NtSection;
; 738  : 
; 739  :     NtSection = RtlSectionTableFromVirtualAddress_k8( NtHeaders,
; 740  :                                                    Base,
; 741  :                                                    Address
; 742  :                                                  );

	push	DWORD PTR _Address$[ebp]
	push	DWORD PTR _Base$[ebp]
	push	DWORD PTR _NtHeaders$[ebp]
	call	_RtlSectionTableFromVirtualAddress_k8@12
	mov	ecx, eax

; 743  :     if (NtSection != NULL) {

	test	ecx, ecx
	je	SHORT $LN2@RtlAddress

; 744  :         return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );

	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+12]
	add	eax, DWORD PTR _Base$[ebp]
	add	eax, DWORD PTR _Address$[ebp]
	jmp	SHORT $LN1@RtlAddress
$LN2@RtlAddress:

; 745  :         }
; 746  :     else {
; 747  :         return( NULL );

	xor	eax, eax
$LN1@RtlAddress:

; 748  :         }
; 749  : }

	pop	ebp
	ret	12					; 0000000cH
_RtlAddressInSectionTable_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_RtlpImageDirectoryEntryToData32_k8@20
; Function compile flags: /Ogsp
;	COMDAT _RtlpImageDirectoryEntryToData32_k8@20
_TEXT	SEGMENT
_Base$ = 8						; size = 4
_MappedAsImage$ = 12					; size = 1
_DirectoryEntry$ = 16					; size = 2
_Size$ = 20						; size = 4
_NtHeaders$ = 24					; size = 4
_RtlpImageDirectoryEntryToData32_k8@20 PROC		; COMDAT

; 761  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 762  :     ULONG DirectoryAddress;
; 763  : 
; 764  :     if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {

	movzx	edx, WORD PTR _DirectoryEntry$[ebp]
	mov	ecx, DWORD PTR _NtHeaders$[ebp]
	cmp	edx, DWORD PTR [ecx+116]
	jb	SHORT $LN6@RtlpImageD
$LN12@RtlpImageD:

; 765  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN7@RtlpImageD
$LN6@RtlpImageD:

; 766  :     }
; 767  : 
; 768  :     if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {

	mov	eax, DWORD PTR [ecx+edx*8+120]
	test	eax, eax

; 769  :         return( NULL );

	je	SHORT $LN12@RtlpImageD
	push	esi

; 770  :     }
; 771  : 
; 772  :     if (Base < MM_HIGHEST_USER_ADDRESS) {

	mov	esi, DWORD PTR __imp__MmHighestUserAddress
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR _Base$[ebp]
	cmp	esi, edi
	jae	SHORT $LN9@RtlpImageD
	push	ebx

; 773  :         if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {

	lea	ebx, DWORD PTR [eax+esi]
	cmp	ebx, edi
	pop	ebx
	jb	SHORT $LN9@RtlpImageD

; 774  :             return( NULL );

	xor	eax, eax
	jmp	SHORT $LN10@RtlpImageD
$LN9@RtlpImageD:

; 775  :         }
; 776  :     }
; 777  : 
; 778  :     *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
; 779  :     if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {

	cmp	BYTE PTR _MappedAsImage$[ebp], 0
	mov	edx, DWORD PTR [ecx+edx*8+124]
	mov	edi, DWORD PTR _Size$[ebp]
	mov	DWORD PTR [edi], edx
	jne	SHORT $LN1@RtlpImageD
	cmp	eax, DWORD PTR [ecx+84]
	jb	SHORT $LN1@RtlpImageD

; 781  :     }
; 782  : 
; 783  :     return( RtlAddressInSectionTable_k8((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));

	push	eax
	push	esi
	push	ecx
	call	_RtlAddressInSectionTable_k8@12
	jmp	SHORT $LN10@RtlpImageD
$LN1@RtlpImageD:

; 780  :         return( (PVOID)((PCHAR)Base + DirectoryAddress) );

	add	eax, esi
$LN10@RtlpImageD:
	pop	edi
	pop	esi
$LN7@RtlpImageD:

; 784  : }

	pop	ebp
	ret	20					; 00000014H
_RtlpImageDirectoryEntryToData32_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_RtlpImageDirectoryEntryToData64_k8@20
; Function compile flags: /Ogsp
;	COMDAT _RtlpImageDirectoryEntryToData64_k8@20
_TEXT	SEGMENT
_Base$ = 8						; size = 4
_MappedAsImage$ = 12					; size = 1
_DirectoryEntry$ = 16					; size = 2
_Size$ = 20						; size = 4
_NtHeaders$ = 24					; size = 4
_RtlpImageDirectoryEntryToData64_k8@20 PROC		; COMDAT

; 795  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 796  :     ULONG DirectoryAddress;
; 797  : 
; 798  :     if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {

	movzx	edx, WORD PTR _DirectoryEntry$[ebp]
	mov	ecx, DWORD PTR _NtHeaders$[ebp]
	cmp	edx, DWORD PTR [ecx+132]
	jb	SHORT $LN6@RtlpImageD@2
$LN12@RtlpImageD@2:

; 799  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN7@RtlpImageD@2
$LN6@RtlpImageD@2:

; 800  :     }
; 801  : 
; 802  :     if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {

	mov	eax, DWORD PTR [ecx+edx*8+136]
	test	eax, eax

; 803  :         return( NULL );

	je	SHORT $LN12@RtlpImageD@2
	push	esi

; 804  :     }
; 805  : 
; 806  :     if (Base < MM_HIGHEST_USER_ADDRESS) {

	mov	esi, DWORD PTR __imp__MmHighestUserAddress
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR _Base$[ebp]
	cmp	esi, edi
	jae	SHORT $LN9@RtlpImageD@2
	push	ebx

; 807  :         if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {

	lea	ebx, DWORD PTR [eax+esi]
	cmp	ebx, edi
	pop	ebx
	jb	SHORT $LN9@RtlpImageD@2

; 808  :             return( NULL );

	xor	eax, eax
	jmp	SHORT $LN10@RtlpImageD@2
$LN9@RtlpImageD@2:

; 809  :         }
; 810  :     }
; 811  : 
; 812  :     *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
; 813  :     if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {

	cmp	BYTE PTR _MappedAsImage$[ebp], 0
	mov	edx, DWORD PTR [ecx+edx*8+140]
	mov	edi, DWORD PTR _Size$[ebp]
	mov	DWORD PTR [edi], edx
	jne	SHORT $LN1@RtlpImageD@2
	cmp	eax, DWORD PTR [ecx+84]
	jb	SHORT $LN1@RtlpImageD@2

; 815  :     }
; 816  : 
; 817  :     return( RtlAddressInSectionTable_k8((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));

	push	eax
	push	esi
	push	ecx
	call	_RtlAddressInSectionTable_k8@12
	jmp	SHORT $LN10@RtlpImageD@2
$LN1@RtlpImageD@2:

; 814  :         return( (PVOID)((PCHAR)Base + DirectoryAddress) );

	add	eax, esi
$LN10@RtlpImageD@2:
	pop	edi
	pop	esi
$LN7@RtlpImageD@2:

; 818  : }

	pop	ebp
	ret	20					; 00000014H
_RtlpImageDirectoryEntryToData64_k8@20 ENDP
_TEXT	ENDS
PUBLIC	_RtlImageDirectoryEntryToData_k8@16
; Function compile flags: /Ogsp
;	COMDAT _RtlImageDirectoryEntryToData_k8@16
_TEXT	SEGMENT
_Base$ = 8						; size = 4
_MappedAsImage$ = 12					; size = 1
_DirectoryEntry$ = 16					; size = 2
_Size$ = 20						; size = 4
_RtlImageDirectoryEntryToData_k8@16 PROC		; COMDAT

; 828  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 829  :     PIMAGE_NT_HEADERS NtHeaders;
; 830  : 
; 831  :     if (LDR_IS_DATAFILE(Base)) {

	mov	ebx, DWORD PTR _Base$[ebp]
	test	bl, 1
	je	SHORT $LN6@RtlImageDi

; 832  :         Base = LDR_DATAFILE_TO_VIEW(Base);

	and	ebx, -2					; fffffffeH

; 833  :         MappedAsImage = FALSE;

	mov	BYTE PTR _MappedAsImage$[ebp], 0
$LN6@RtlImageDi:

; 834  :         }
; 835  : 
; 836  :     NtHeaders = RtlImageNtHeader_k8(Base);

	push	ebx
	call	_RtlImageNtHeader_k8@4

; 837  : 
; 838  :     if (!NtHeaders)

	test	eax, eax

; 839  :         return NULL;

	je	SHORT $LN2@RtlImageDi

; 840  : 
; 841  :     if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {

	movzx	ecx, WORD PTR [eax+24]
	mov	edx, 267				; 0000010bH
	cmp	cx, dx
	jne	SHORT $LN4@RtlImageDi

; 842  :         return (RtlpImageDirectoryEntryToData32_k8(Base,
; 843  :                                                 MappedAsImage,
; 844  :                                                 DirectoryEntry,
; 845  :                                                 Size,
; 846  :                                                 (PIMAGE_NT_HEADERS32)NtHeaders));

	push	eax
	push	DWORD PTR _Size$[ebp]
	push	DWORD PTR _DirectoryEntry$[ebp]
	push	DWORD PTR _MappedAsImage$[ebp]
	push	ebx
	call	_RtlpImageDirectoryEntryToData32_k8@20
	jmp	SHORT $LN1@RtlImageDi
$LN4@RtlImageDi:

; 847  :     } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {

	mov	edx, 523				; 0000020bH
	cmp	cx, dx
	jne	SHORT $LN2@RtlImageDi

; 848  :         return (RtlpImageDirectoryEntryToData64_k8(Base,
; 849  :                                                 MappedAsImage,
; 850  :                                                 DirectoryEntry,
; 851  :                                                 Size,
; 852  :                                                 (PIMAGE_NT_HEADERS64)NtHeaders));

	push	eax
	push	DWORD PTR _Size$[ebp]
	push	DWORD PTR _DirectoryEntry$[ebp]
	push	DWORD PTR _MappedAsImage$[ebp]
	push	ebx
	call	_RtlpImageDirectoryEntryToData64_k8@20
	jmp	SHORT $LN1@RtlImageDi
$LN2@RtlImageDi:

; 853  :     } else {
; 854  :         return (NULL);

	xor	eax, eax
$LN1@RtlImageDi:
	pop	ebx

; 855  :     }
; 856  : }

	pop	ebp
	ret	16					; 00000010H
_RtlImageDirectoryEntryToData_k8@16 ENDP
_TEXT	ENDS
PUBLIC	_MiFindExportedRoutineByName_k8@8
; Function compile flags: /Ogsp
;	COMDAT _MiFindExportedRoutineByName_k8@8
_TEXT	SEGMENT
_NameOrdinalTableBase$ = -16				; size = 4
_ExportSize$ = -16					; size = 4
tv183 = -12						; size = 4
_Low$ = -8						; size = 4
tv205 = -4						; size = 4
_DllBase$ = 8						; size = 4
_AnsiImageRoutineName$ = 12				; size = 4
tv195 = 15						; size = 1
_MiFindExportedRoutineByName_k8@8 PROC			; COMDAT

; 865  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 866  :     USHORT OrdinalNumber;
; 867  :     PULONG NameTableBase;
; 868  :     PUSHORT NameOrdinalTableBase;
; 869  :     PULONG Addr;
; 870  :     LONG High;
; 871  :     LONG Low;
; 872  :     LONG Middle;
; 873  :     LONG Result;
; 874  :     ULONG ExportSize;
; 875  :     PVOID FunctionAddress;
; 876  :     PIMAGE_EXPORT_DIRECTORY ExportDirectory;
; 877  : 
; 878  :     ExportDirectory = (PIMAGE_EXPORT_DIRECTORY) RtlImageDirectoryEntryToData_k8 (
; 879  :                                 DllBase,
; 880  :                                 TRUE,
; 881  :                                 IMAGE_DIRECTORY_ENTRY_EXPORT,
; 882  :                                 &ExportSize);

	lea	eax, DWORD PTR _ExportSize$[ebp]
	push	eax
	push	0
	push	1
	push	DWORD PTR _DllBase$[ebp]
	call	_RtlImageDirectoryEntryToData_k8@16

; 883  : 
; 884  :     if (ExportDirectory == NULL) {

	test	eax, eax
	je	$LN10@MiFindExpo
$LN9@MiFindExpo:

; 885  :         return NULL;
; 886  :     }
; 887  : 
; 888  :     //
; 889  :     // Initialize the pointer to the array of RVA-based ansi export strings.
; 890  :     //
; 891  : 
; 892  :     NameTableBase = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNames);
; 893  : 
; 894  :     //
; 895  :     // Initialize the pointer to the array of USHORT ordinal numbers.
; 896  :     //
; 897  : 
; 898  :     NameOrdinalTableBase = (PUSHORT)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNameOrdinals);

	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _DllBase$[ebp]

; 899  : 
; 900  :     //
; 901  :     // Lookup the desired namethe name table using a binary search.
; 902  :     //
; 903  : 
; 904  :     Low = 0;

	and	DWORD PTR _Low$[ebp], 0
	push	esi

; 905  :     Middle = 0;
; 906  :     High = ExportDirectory->NumberOfNames - 1;

	mov	esi, DWORD PTR [eax+24]
	push	edi
	mov	edi, DWORD PTR [eax+32]
	add	edi, DWORD PTR _DllBase$[ebp]
	dec	esi
	mov	DWORD PTR _NameOrdinalTableBase$[ebp], ecx

; 907  : 
; 908  :     while (High >= Low) {

	js	SHORT $LN13@MiFindExpo
	mov	ecx, DWORD PTR _AnsiImageRoutineName$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv183[ebp], ecx
	push	ebx
$LL8@MiFindExpo:

; 909  : 
; 910  :         //
; 911  :         // Compute the next probe index and compare the import name
; 912  :         // with the export name entry.
; 913  :         //
; 914  : 
; 915  :         Middle = (Low + High) >> 1;

	mov	ecx, DWORD PTR _Low$[ebp]

; 916  : 
; 917  :         Result = strcmp (AnsiImageRoutineName->Buffer,
; 918  :                          (PCHAR)DllBase + NameTableBase[Middle]);

	mov	ebx, DWORD PTR tv183[ebp]
	add	ecx, esi
	sar	ecx, 1
	mov	edx, DWORD PTR [edi+ecx*4]
	add	edx, DWORD PTR _DllBase$[ebp]
	mov	DWORD PTR tv205[ebp], ebx
$LL19@MiFindExpo:
	mov	ebx, DWORD PTR tv205[ebp]
	mov	bl, BYTE PTR [ebx]
	cmp	bl, BYTE PTR [edx]
	jne	SHORT $LN15@MiFindExpo
	test	bl, bl
	je	SHORT $LN16@MiFindExpo
	mov	ebx, DWORD PTR tv205[ebp]
	mov	bl, BYTE PTR [ebx+1]
	mov	BYTE PTR tv195[ebp], bl
	cmp	bl, BYTE PTR [edx+1]
	jne	SHORT $LN15@MiFindExpo
	add	DWORD PTR tv205[ebp], 2
	inc	edx
	inc	edx
	test	bl, bl
	jne	SHORT $LL19@MiFindExpo
$LN16@MiFindExpo:
	xor	edx, edx
	jmp	SHORT $LN17@MiFindExpo
$LN15@MiFindExpo:
	sbb	edx, edx
	sbb	edx, -1
$LN17@MiFindExpo:

; 919  : 
; 920  :         if (Result < 0) {

	test	edx, edx
	jge	SHORT $LN23@MiFindExpo

; 921  :             High = Middle - 1;

	lea	esi, DWORD PTR [ecx-1]
	jmp	SHORT $LN3@MiFindExpo
$LN23@MiFindExpo:

; 922  :         }
; 923  :         else if (Result > 0) {

	jle	SHORT $LN20@MiFindExpo

; 924  :             Low = Middle + 1;

	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR _Low$[ebp], edx
$LN3@MiFindExpo:

; 907  : 
; 908  :     while (High >= Low) {

	cmp	esi, DWORD PTR _Low$[ebp]
	jge	SHORT $LL8@MiFindExpo
$LN20@MiFindExpo:

; 925  :         }
; 926  :         else {
; 927  :             break;
; 928  :         }
; 929  :     }
; 930  : 
; 931  :     //
; 932  :     // If the high index is less than the low index, then a matching
; 933  :     // table entry was not found. Otherwise, get the ordinal number
; 934  :     // from the ordinal table.
; 935  :     //
; 936  : 
; 937  :     if (High < Low) {

	cmp	esi, DWORD PTR _Low$[ebp]
	pop	ebx

; 938  :         return NULL;

	jl	SHORT $LN13@MiFindExpo

; 939  :     }
; 940  : 
; 941  :     OrdinalNumber = NameOrdinalTableBase[Middle];

	mov	edx, DWORD PTR _NameOrdinalTableBase$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2]

; 942  : 
; 943  :     //
; 944  :     // If the OrdinalNumber is not within the Export Address Table,
; 945  :     // then this image does not implement the function.  Return not found.
; 946  :     //
; 947  : 
; 948  :     if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {

	cmp	ecx, DWORD PTR [eax+20]
	jb	SHORT $LN1@MiFindExpo
$LN13@MiFindExpo:

; 949  :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN21@MiFindExpo
$LN1@MiFindExpo:

; 950  :     }
; 951  : 
; 952  :     //
; 953  :     // Index into the array of RVA export addresses by ordinal number.
; 954  :     //
; 955  : 
; 956  :     Addr = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);
; 957  : 
; 958  :     FunctionAddress = (PVOID)((PCHAR)DllBase + Addr[OrdinalNumber]);

	mov	eax, DWORD PTR [eax+28]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _DllBase$[ebp]
	mov	eax, DWORD PTR [eax+ecx]
	add	eax, ecx
$LN21@MiFindExpo:
	pop	edi
	pop	esi
$LN10@MiFindExpo:

; 959  : 
; 960  :     //
; 961  :     // Forwarders are not used by the kernel and HAL to each other.
; 962  :     //
; 963  : 
; 964  :     return FunctionAddress;
; 965  : }

	leave
	ret	8
_MiFindExportedRoutineByName_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThreadProcessId_k8@0
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThreadProcessId_k8@0
_TEXT	SEGMENT
_PsGetCurrentThreadProcessId_k8@0 PROC			; COMDAT

; 971  :     return _PsGetCurrentThread()->Cid.UniqueProcess;

	call	DWORD PTR __imp__KeGetCurrentThread@0
	mov	eax, DWORD PTR [eax+484]

; 972  : }

	ret	0
_PsGetCurrentThreadProcessId_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeAreAllApcsDisabled_k8@0
EXTRN	__imp__KeGetCurrentIrql@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeAreAllApcsDisabled_k8@0
_TEXT	SEGMENT
_KeAreAllApcsDisabled_k8@0 PROC				; COMDAT

; 978  : #if (NTDDI_VERSION < NTDDI_WS03)    // XP Only
; 979  :     return (BOOLEAN)((KeGetCurrentThread()->KernelApcDisable != 0) ||
; 980  :                      (KeGetCurrentIrql() >= APC_LEVEL));
; 981  : #else
; 982  :     return (BOOLEAN)((KeGetCurrentThread()->SpecialApcDisable != 0) ||
; 983  :                      (KeGetCurrentIrql() >= APC_LEVEL));

	call	DWORD PTR __imp__KeGetCurrentThread@0
	cmp	WORD PTR [eax+114], 0
	jne	SHORT $LN3@KeAreAllAp
	call	DWORD PTR __imp__KeGetCurrentIrql@0
	cmp	al, 1
	jae	SHORT $LN3@KeAreAllAp
	xor	al, al

; 984  : #endif
; 985  : }

	ret	0
$LN3@KeAreAllAp:

; 978  : #if (NTDDI_VERSION < NTDDI_WS03)    // XP Only
; 979  :     return (BOOLEAN)((KeGetCurrentThread()->KernelApcDisable != 0) ||
; 980  :                      (KeGetCurrentIrql() >= APC_LEVEL));
; 981  : #else
; 982  :     return (BOOLEAN)((KeGetCurrentThread()->SpecialApcDisable != 0) ||
; 983  :                      (KeGetCurrentIrql() >= APC_LEVEL));

	mov	al, 1

; 984  : #endif
; 985  : }

	ret	0
_KeAreAllApcsDisabled_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeInvalidateAllCaches_k8@0
; Function compile flags: /Ogsp
;	COMDAT _KeInvalidateAllCaches_k8@0
_TEXT	SEGMENT
_KeInvalidateAllCaches_k8@0 PROC			; COMDAT

; 996  :     return gTramp_KeInvalidateAllCaches();

	jmp	DWORD PTR _gTramp_KeInvalidateAllCaches
_KeInvalidateAllCaches_k8@0 ENDP
_TEXT	ENDS
PUBLIC	@ExEnterCriticalRegionAndAcquireFastMutexUnsafe_k8@4
EXTRN	__imp_@ExAcquireFastMutexUnsafe@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExEnterCriticalRegionAndAcquireFastMutexUnsafe_k8@4
_TEXT	SEGMENT
@ExEnterCriticalRegionAndAcquireFastMutexUnsafe_k8@4 PROC ; COMDAT
; _FastMutex$ = ecx

; 1004 : {

	npad	2
	push	esi
	mov	esi, ecx

; 1005 :     KeEnterCriticalRegion();

	call	DWORD PTR __imp__KeEnterCriticalRegion@0

; 1006 :     ExAcquireFastMutexUnsafe(FastMutex);

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_@ExAcquireFastMutexUnsafe@4
@ExEnterCriticalRegionAndAcquireFastMutexUnsafe_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExReleaseFastMutexUnsafeAndLeaveCriticalRegion_k8@4
EXTRN	__imp_@ExReleaseFastMutexUnsafe@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @ExReleaseFastMutexUnsafeAndLeaveCriticalRegion_k8@4
_TEXT	SEGMENT
@ExReleaseFastMutexUnsafeAndLeaveCriticalRegion_k8@4 PROC ; COMDAT
; _FastMutex$ = ecx

; 1015 :     ExReleaseFastMutexUnsafe(FastMutex);

	call	DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4

; 1016 :     KeLeaveCriticalRegion();

	jmp	DWORD PTR __imp__KeLeaveCriticalRegion@0
@ExReleaseFastMutexUnsafeAndLeaveCriticalRegion_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThreadWin32Thread_k8@0
EXTRN	_PsGetThreadWin32Thread@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThreadWin32Thread_k8@0
_TEXT	SEGMENT
_PsGetCurrentThreadWin32Thread_k8@0 PROC		; COMDAT

; 1025 :     return PsGetThreadWin32Thread(KeGetCurrentThread());

	call	DWORD PTR __imp__KeGetCurrentThread@0
	push	eax
	call	_PsGetThreadWin32Thread@4

; 1026 : }

	ret	0
_PsGetCurrentThreadWin32Thread_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentProcessWin32Process_k8@0
EXTRN	__imp__IoGetCurrentProcess@0:PROC
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentProcessWin32Process_k8@0
_TEXT	SEGMENT
_PsGetCurrentProcessWin32Process_k8@0 PROC		; COMDAT

; 1034 :     return PsGetCurrentProcess()->Win32Process;

	call	DWORD PTR __imp__IoGetCurrentProcess@0
	mov	eax, DWORD PTR [eax+284]

; 1035 : }

	ret	0
_PsGetCurrentProcessWin32Process_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThreadTeb_k8@0
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThreadTeb_k8@0
_TEXT	SEGMENT
_PsGetCurrentThreadTeb_k8@0 PROC			; COMDAT

; 1042 :     return PsGetCurrentThread()->Tcb.Teb;

	call	DWORD PTR __imp__KeGetCurrentThread@0
	mov	eax, DWORD PTR [eax+116]

; 1043 : }

	ret	0
_PsGetCurrentThreadTeb_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_PsIsSystemProcess_k8@4
EXTRN	__imp__PsInitialSystemProcess:DWORD
; Function compile flags: /Ogsp
;	COMDAT _PsIsSystemProcess_k8@4
_TEXT	SEGMENT
_Process$ = 8						; size = 4
_PsIsSystemProcess_k8@4 PROC				; COMDAT

; 1050 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1051 :     return (BOOLEAN)(Process == PsInitialSystemProcess);

	mov	eax, DWORD PTR _Process$[ebp]
	mov	ecx, DWORD PTR __imp__PsInitialSystemProcess
	cmp	eax, DWORD PTR [ecx]
	sete	al

; 1052 : }

	pop	ebp
	ret	4
_PsIsSystemProcess_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_MmGetSessionIdEx_k8@4
; Function compile flags: /Ogsp
;	COMDAT _MmGetSessionIdEx_k8@4
_TEXT	SEGMENT
_Process$ = 8						; size = 4
_MmGetSessionIdEx_k8@4 PROC				; COMDAT

; 1059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1060 :     PMM_SESSION_SPACE SessionGlobal;
; 1061 : 
; 1062 :     if (Process->Vm.Flags.SessionLeader == 1) {

	mov	eax, DWORD PTR _Process$[ebp]
	test	BYTE PTR [eax+504], 4
	je	SHORT $LN2@MmGetSessi
$LN5@MmGetSessi:

; 1063 : 
; 1064 :         //
; 1065 :         // smss may transiently have a session space but that's of no interest
; 1066 :         // to our caller.
; 1067 :         //
; 1068 : 
; 1069 :         return (ULONG)-1;

	or	eax, -1
	jmp	SHORT $LN3@MmGetSessi
$LN2@MmGetSessi:

; 1070 :     }
; 1071 : 
; 1072 :     //
; 1073 :     // The Session field of the EPROCESS is never cleared once set so these
; 1074 :     // checks can be done lock free.
; 1075 :     //
; 1076 : 
; 1077 :     SessionGlobal = (PMM_SESSION_SPACE) Process->Session;

	mov	eax, DWORD PTR [eax+352]

; 1078 : 
; 1079 :     if (SessionGlobal == NULL) {

	test	eax, eax

; 1080 : 
; 1081 :         //
; 1082 :         // The system process has no session space.
; 1083 :         //
; 1084 : 
; 1085 :         return (ULONG)-1;

	je	SHORT $LN5@MmGetSessi

; 1086 :     }
; 1087 : 
; 1088 :     return SessionGlobal->SessionId;

	mov	eax, DWORD PTR [eax+12]
$LN3@MmGetSessi:

; 1089 : }

	pop	ebp
	ret	4
_MmGetSessionIdEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PsGetProcessSessionIdEx_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PsGetProcessSessionIdEx_k8@4
_TEXT	SEGMENT
_Process$ = 8						; size = 4
_PsGetProcessSessionIdEx_k8@4 PROC			; COMDAT

; 1097 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1099 : }

	pop	ebp

; 1098 :     return MmGetSessionIdEx_k8 (Process);

	jmp	_MmGetSessionIdEx_k8@4
_PsGetProcessSessionIdEx_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThreadProcess_k8@0
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThreadProcess_k8@0
_TEXT	SEGMENT
_PsGetCurrentThreadProcess_k8@0 PROC			; COMDAT

; 1107 :     #if (NTDDI_VERSION < NTDDI_VISTA)
; 1108 :         return THREAD_TO_PROCESS(PsGetCurrentThread());

	call	DWORD PTR __imp__KeGetCurrentThread@0
	mov	eax, DWORD PTR [eax+536]

; 1109 :     #else
; 1110 :         return (PEPROCESS) ((_KTHREAD *)PsGetCurrentThread())->Process;
; 1111 :     #endif
; 1112 : }

	ret	0
_PsGetCurrentThreadProcess_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_PsGetCurrentThreadWin32ThreadAndEnterCriticalRegion_k8@4
; Function compile flags: /Ogsp
;	COMDAT _PsGetCurrentThreadWin32ThreadAndEnterCriticalRegion_k8@4
_TEXT	SEGMENT
_ProcessId$ = 8						; size = 4
_PsGetCurrentThreadWin32ThreadAndEnterCriticalRegion_k8@4 PROC ; COMDAT

; 1119 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1120 :     PETHREAD Thread = PsGetCurrentThread();

	call	DWORD PTR __imp__KeGetCurrentThread@0

; 1121 :     *ProcessId = Thread->Cid.UniqueProcess;

	mov	ecx, DWORD PTR [eax+484]
	mov	edx, DWORD PTR _ProcessId$[ebp]
	mov	DWORD PTR [edx], ecx

; 1122 :     KeEnterCriticalRegionThread(&Thread->Tcb);

	dec	WORD PTR [eax+112]

; 1123 :     return (PVOID) Thread->Tcb.Win32Thread;

	mov	eax, DWORD PTR [eax+340]

; 1124 : }

	pop	ebp
	ret	4
_PsGetCurrentThreadWin32ThreadAndEnterCriticalRegion_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_KeAlertThread_k8@8
; Function compile flags: /Ogsp
;	COMDAT _KeAlertThread_k8@8
_TEXT	SEGMENT
_Thread$ = 8						; size = 4
_AlertMode$ = 12					; size = 1
_KeAlertThread_k8@8 PROC				; COMDAT

; 1131 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1133 : }

	pop	ebp

; 1132 :     return gTramp_KeAlertThread(Thread, AlertMode);

	jmp	DWORD PTR _gTramp_KeAlertThread
_KeAlertThread_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_KeTestAlertThread_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeTestAlertThread_k8@4
_TEXT	SEGMENT
_AlertMode$ = 8						; size = 1
_KeTestAlertThread_k8@4 PROC				; COMDAT

; 1140 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1142 : }

	pop	ebp

; 1141 :     return gTramp_KeTestAlertThread(AlertMode);

	jmp	DWORD PTR _gTramp_KeTestAlertThread
_KeTestAlertThread_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ObDeleteCapturedInsertInfo_k8@4
EXTRN	_SeReleaseSecurityDescriptor@12:PROC
; Function compile flags: /Ogsp
;	COMDAT _ObDeleteCapturedInsertInfo_k8@4
_TEXT	SEGMENT
_Object$ = 8						; size = 4
_ObDeleteCapturedInsertInfo_k8@4 PROC			; COMDAT

; 1149 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1150 :     POBJECT_HEADER ObjectHeader;
; 1151 : 
; 1152 :     //
; 1153 :     //  Get the address of the object header and free the object create
; 1154 :     //  information object if the object is being created.
; 1155 :     //
; 1156 : 
; 1157 :     ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

	mov	esi, DWORD PTR _Object$[ebp]

; 1158 : 
; 1159 :     if (ObjectHeader->Flags & OB_FLAG_NEW_OBJECT) {

	test	BYTE PTR [esi-9], 1
	je	SHORT $LN2@ObDeleteCa

; 1160 : 
; 1161 :         if (ObjectHeader->ObjectCreateInfo != NULL) {

	mov	eax, DWORD PTR [esi-8]
	test	eax, eax
	je	SHORT $LN2@ObDeleteCa

; 1162 : 
; 1163 :             ObpFreeObjectCreateInformation(ObjectHeader->ObjectCreateInfo);

	mov	ecx, DWORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN1@ObDeleteCa
	movzx	eax, BYTE PTR [eax+12]
	push	1
	push	eax
	push	ecx
	call	_SeReleaseSecurityDescriptor@12
	mov	eax, DWORD PTR [esi-8]
	and	DWORD PTR [eax+28], 0
$LN1@ObDeleteCa:
	mov	eax, DWORD PTR fs:32
	mov	ecx, DWORD PTR [eax+1528]
	mov	edx, DWORD PTR [esi-8]
	inc	DWORD PTR [ecx+20]
	push	edi
	mov	di, WORD PTR [ecx+4]
	cmp	di, WORD PTR [ecx+8]
	pop	edi
	jb	SHORT $LN6@ObDeleteCa
	inc	DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [eax+1532]
	mov	ax, WORD PTR [ecx+4]
	inc	DWORD PTR [ecx+20]
	cmp	ax, WORD PTR [ecx+8]
	jb	SHORT $LN6@ObDeleteCa
	inc	DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR [ecx+44]
	jmp	SHORT $LN8@ObDeleteCa
$LN6@ObDeleteCa:
	call	DWORD PTR __imp_@InterlockedPushEntrySList@8
$LN8@ObDeleteCa:

; 1164 : 
; 1165 :             ObjectHeader->ObjectCreateInfo = NULL;

	and	DWORD PTR [esi-8], 0
$LN2@ObDeleteCa:
	pop	esi

; 1166 :         }
; 1167 :     }
; 1168 : 
; 1169 :     return;
; 1170 : }

	pop	ebp
	ret	4
_ObDeleteCapturedInsertInfo_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_ExReleasePushLockShared@4
EXTRN	@ExfReleasePushLock@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _ExReleasePushLockShared@4
_TEXT	SEGMENT
_PushLock$ = 8						; size = 4
_ExReleasePushLockShared@4 PROC				; COMDAT

; 1177 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1178 :     EX_PUSH_LOCK OldValue, NewValue;
; 1179 : 
; 1180 :     OldValue = *PushLock;
; 1181 :     OldValue.Value &= ~EX_PUSH_LOCK_WAITING;

	mov	ecx, DWORD PTR _PushLock$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -2					; fffffffeH
	push	esi

; 1182 :     NewValue.Value = OldValue.Value - EX_PUSH_LOCK_SHARE_INC;

	lea	eax, DWORD PTR [edx-4]
	push	edi

; 1183 :     if (InterlockedCompareExchangePointer (&PushLock->Ptr,
; 1184 :                                            NewValue.Ptr,
; 1185 :                                            OldValue.Ptr) != OldValue.Ptr) {

	mov	esi, eax
	mov	edi, ecx
	mov	eax, edx
	lock	 cmpxchg DWORD PTR [edi], esi
	pop	edi
	pop	esi
	cmp	eax, edx
	je	SHORT $LN1@ExReleaseP

; 1186 :         ExfReleasePushLock (PushLock);

	call	@ExfReleasePushLock@4
$LN1@ExReleaseP:

; 1187 :     }
; 1188 : }

	pop	ebp
	ret	4
_ExReleasePushLockShared@4 ENDP
_TEXT	ENDS
PUBLIC	@ExfReleasePushLockShared_k8@4
; Function compile flags: /Ogsp
;	COMDAT @ExfReleasePushLockShared_k8@4
_TEXT	SEGMENT
@ExfReleasePushLockShared_k8@4 PROC			; COMDAT
; _PushLock$ = ecx

; 1196 :     ExReleasePushLockShared(PushLock);

	mov	edx, DWORD PTR [ecx]
	and	edx, -2					; fffffffeH
	push	esi
	lea	eax, DWORD PTR [edx-4]
	push	edi
	mov	esi, eax
	mov	edi, ecx
	mov	eax, edx
	lock	 cmpxchg DWORD PTR [edi], esi
	pop	edi
	pop	esi
	cmp	eax, edx
	je	SHORT $LN3@
	jmp	@ExfReleasePushLock@4
$LN3@:

; 1197 : }

	ret	0
@ExfReleasePushLockShared_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@ExfTryToWakePushLock_k8@4
; Function compile flags: /Ogsp
;	COMDAT @ExfTryToWakePushLock_k8@4
_TEXT	SEGMENT
@ExfTryToWakePushLock_k8@4 PROC				; COMDAT
; _PushLock$ = ecx

; 1205 :     ExfReleasePushLock(PushLock);

	jmp	@ExfReleasePushLock@4
@ExfTryToWakePushLock_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_LpcRequestWaitReplyPortEx_k8@12
; Function compile flags: /Ogsp
;	COMDAT _LpcRequestWaitReplyPortEx_k8@12
_TEXT	SEGMENT
_PortAddress$ = 8					; size = 4
_RequestMessage$ = 12					; size = 4
_ReplyMessage$ = 16					; size = 4
_LpcRequestWaitReplyPortEx_k8@12 PROC			; COMDAT

; 1215 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1217 : }

	pop	ebp

; 1216 :     return gTramp_LpcRequestWaitReplyPortEx(PortAddress, RequestMessage, ReplyMessage);

	jmp	DWORD PTR _gTramp_LpcRequestWaitReplyPortEx
_LpcRequestWaitReplyPortEx_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_KeExpandKernelStackAndCallout_k8@12
EXTRN	__imp__KeBugCheck@4:PROC
EXTRN	_MmGrowKernelStack@4:PROC
EXTRN	_KeGetCurrentStackPointer@0:PROC
EXTRN	__SEH_epilog:PROC
EXTRN	__except_handler3:PROC
EXTRN	__SEH_prolog:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_KeExpandKernelStackAndCallout_k8@12 DD 0ffffffffH
	DD	00H
	DD	FLAT:$LN10@KeExpandKe
	DD	00H
	DD	FLAT:$LN14@KeExpandKe
	DD	FLAT:$LN15@KeExpandKe
; Function compile flags: /Ogsp
xdata$x	ENDS
;	COMDAT _KeExpandKernelStackAndCallout_k8@12
_TEXT	SEGMENT
_InCallout$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Callout$ = 8						; size = 4
_Parameter$ = 12					; size = 4
_Size$ = 16						; size = 4
_KeExpandKernelStackAndCallout_k8@12 PROC		; COMDAT

; 1226 : {

	push	12					; 0000000cH
	push	OFFSET __sehtable$_KeExpandKernelStackAndCallout_k8@12
	call	__SEH_prolog

; 1227 :     ULONG_PTR   ActualLimit;
; 1228 :     ULONG_PTR   CurrentLimit;
; 1229 :     ULONG_PTR   CurrentStack;
; 1230 :     KIRQL       ExitIrql;
; 1231 :     volatile BOOLEAN InCallout;
; 1232 :     PVOID       LargeStack;
; 1233 :     KIRQL       OldIrql;
; 1234 :     NTSTATUS    Status;
; 1235 :     PKTHREAD    Thread;
; 1236 :     
; 1237 :     if (Size > MAXIMUM_EXPANSION_SIZE) {

	cmp	DWORD PTR _Size$[ebp], 59392		; 0000e800H
	jbe	SHORT $LN6@KeExpandKe

; 1238 :         return STATUS_INVALID_PARAMETER_3;

	mov	eax, -1073741583			; c00000f1H
	jmp	SHORT $LN7@KeExpandKe
$LN6@KeExpandKe:

; 1239 :     }
; 1240 :     
; 1241 :     Thread = KeGetCurrentThread();

	call	DWORD PTR __imp__KeGetCurrentThread@0
	mov	esi, eax

; 1242 :     CurrentStack = KeGetCurrentStackPointer();

	call	_KeGetCurrentStackPointer@0

; 1243 :     CurrentLimit = (ULONG_PTR)Thread->StackLimit;

	mov	esi, DWORD PTR [esi+28]

; 1244 :     //ActualLimit = CurrentLimit;
; 1245 :     
; 1246 :     if ((CurrentStack - CurrentLimit) < Size) {

	mov	ecx, eax
	sub	ecx, esi
	cmp	ecx, DWORD PTR _Size$[ebp]
	jae	SHORT $LN4@KeExpandKe

; 1247 :         Status = MmGrowKernelStack((PVOID)CurrentStack);

	push	eax
	call	_MmGrowKernelStack@4

; 1248 :         if (NT_SUCCESS(Status) == FALSE) {

	test	eax, eax
	jge	SHORT $LN4@KeExpandKe

; 1249 :             return STATUS_NO_MEMORY;

	mov	eax, -1073741801			; c0000017H
	jmp	SHORT $LN7@KeExpandKe
$LN4@KeExpandKe:

; 1250 :         }
; 1251 :     }
; 1252 : 
; 1253 :     Status = STATUS_SUCCESS;
; 1254 :     InCallout = TRUE;

	mov	BYTE PTR _InCallout$[ebp], 1

; 1255 :     __try {

	xor	ebx, ebx
	mov	DWORD PTR __$SEHRec$[ebp+20], ebx

; 1256 :         __try {

	mov	DWORD PTR __$SEHRec$[ebp+20], 1

; 1257 :             (Callout)(Parameter);

	push	DWORD PTR _Parameter$[ebp]
	call	DWORD PTR _Callout$[ebp]

; 1258 :             InCallout = FALSE;

	mov	BYTE PTR _InCallout$[ebp], bl

; 1259 : 
; 1260 :         } __except (EXCEPTION_EXECUTE_HANDLER) {

	mov	DWORD PTR __$SEHRec$[ebp+20], ebx

; 1262 :         }
; 1263 : 
; 1264 :     } __finally {

	or	DWORD PTR __$SEHRec$[ebp+20], -1
	call	$LN12@KeExpandKe
$LN13@KeExpandKe:

; 1267 :         }
; 1268 :     }
; 1269 :     
; 1270 :     return STATUS_SUCCESS;

	xor	eax, eax
$LN7@KeExpandKe:

; 1271 : }

	call	__SEH_epilog
	ret	12					; 0000000cH
$LN14@KeExpandKe:
$LN23@KeExpandKe:

; 1259 : 
; 1260 :         } __except (EXCEPTION_EXECUTE_HANDLER) {

	xor	eax, eax
	inc	eax
$LN19@KeExpandKe:
$LN16@KeExpandKe:
	ret	0
$LN15@KeExpandKe:
	mov	esp, DWORD PTR __$SEHRec$[ebp]
$LN22@KeExpandKe:

; 1261 :             KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);

	push	30					; 0000001eH
	call	DWORD PTR __imp__KeBugCheck@4
$LN25@KeExpandKe:
$LN10@KeExpandKe:
$LN24@KeExpandKe:
$LN12@KeExpandKe:

; 1265 :         if (InCallout == TRUE) {

	mov	al, BYTE PTR _InCallout$[ebp]
	cmp	al, 1

; 1266 :             KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);

	je	SHORT $LN22@KeExpandKe
$LN11@KeExpandKe:
$LN20@KeExpandKe:
	ret	0
$LN21@KeExpandKe:
_KeExpandKernelStackAndCallout_k8@12 ENDP
_TEXT	ENDS
PUBLIC	_KeEnterGuardedRegion_k8@0
EXTRN	__imp_@KfRaiseIrql@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeEnterGuardedRegion_k8@0
_TEXT	SEGMENT
_KeEnterGuardedRegion_k8@0 PROC				; COMDAT

; 1278 :     KeEnterCriticalRegion();

	call	DWORD PTR __imp__KeEnterCriticalRegion@0

; 1279 :     
; 1280 :     if (gGuardedRegionCounter < 1 &&
; 1281 :         KeGetCurrentIrql() < gGuardedRegion_OldIrql &&
; 1282 :         KeGetCurrentIrql() < APC_LEVEL) {

	cmp	DWORD PTR _gGuardedRegionCounter, 1
	jge	SHORT $LN1@KeEnterGua
	push	esi
	mov	esi, DWORD PTR __imp__KeGetCurrentIrql@0
	call	esi
	cmp	al, BYTE PTR _gGuardedRegion_OldIrql
	jae	SHORT $LN4@KeEnterGua
	call	esi
	cmp	al, 1
	jae	SHORT $LN4@KeEnterGua

; 1283 :             KeRaiseIrql(APC_LEVEL, &gGuardedRegion_OldIrql);

	mov	cl, 1
	call	DWORD PTR __imp_@KfRaiseIrql@4
	mov	BYTE PTR _gGuardedRegion_OldIrql, al
$LN4@KeEnterGua:
	pop	esi
$LN1@KeEnterGua:

; 1284 :     }
; 1285 :     
; 1286 :     InterlockedIncrement(&gGuardedRegionCounter);

	xor	ecx, ecx
	mov	eax, OFFSET _gGuardedRegionCounter
	inc	ecx
	lock	 xadd	 DWORD PTR [eax], ecx

; 1287 : }

	ret	0
_KeEnterGuardedRegion_k8@0 ENDP
_TEXT	ENDS
PUBLIC	_KeLeaveGuardedRegion_k8@0
EXTRN	__imp_@KfLowerIrql@4:PROC
; Function compile flags: /Ogsp
;	COMDAT _KeLeaveGuardedRegion_k8@0
_TEXT	SEGMENT
_KeLeaveGuardedRegion_k8@0 PROC				; COMDAT

; 1292 : {

	npad	2
	push	esi

; 1293 :     InterlockedDecrement(&gGuardedRegionCounter);

	mov	esi, OFFSET _gGuardedRegionCounter
	mov	eax, esi
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx

; 1294 :     
; 1295 :     if (gGuardedRegionCounter < 1) {

	cmp	DWORD PTR _gGuardedRegionCounter, 1
	jge	SHORT $LN2@KeLeaveGua

; 1296 :         KeLowerIrql(gGuardedRegion_OldIrql);

	mov	cl, BYTE PTR _gGuardedRegion_OldIrql
	call	DWORD PTR __imp_@KfLowerIrql@4
$LN2@KeLeaveGua:

; 1297 :     }
; 1298 : 
; 1299 :     if (gGuardedRegionCounter < 0) {

	cmp	DWORD PTR _gGuardedRegionCounter, 0
	jge	SHORT $LN1@KeLeaveGua

; 1300 :         InterlockedExchange(&gGuardedRegionCounter, 0);

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
$LN1@KeLeaveGua:
	pop	esi

; 1301 :     }
; 1302 :     
; 1303 :     KeLeaveCriticalRegion();

	jmp	DWORD PTR __imp__KeLeaveCriticalRegion@0
_KeLeaveGuardedRegion_k8@0 ENDP
_TEXT	ENDS
PUBLIC	@KeInitializeGuardedMutex_k8@4
; Function compile flags: /Ogsp
;	COMDAT @KeInitializeGuardedMutex_k8@4
_TEXT	SEGMENT
@KeInitializeGuardedMutex_k8@4 PROC			; COMDAT
; _Mutex$ = ecx

; 1311 :     /*
; 1312 :     {
; 1313 :         volatile LONG Count;
; 1314 :         PKTHREAD Owner;
; 1315 :         ULONG Contention;
; 1316 :         KGATE Gate;
; 1317 :         union {
; 1318 :            struct {
; 1319 :             SHORT KernelApcDisable;
; 1320 :             SHORT SpecialApcDisable;
; 1321 :            };
; 1322 :            ULONG CombinedApcDisable;
; 1323 :         };
; 1324 :     } KGUARDED_MUTEX
; 1325 :     
; 1326 :     {
; 1327 :         volatile LONG Count;
; 1328 :         PKTHREAD Owner;
; 1329 :         ULONG Contention;
; 1330 :         KEVENT Event;
; 1331 :         ULONG OldIrql;
; 1332 :     } FAST_MUTEX, */
; 1333 : 
; 1334 :     ExInitializeFastMutex((PFAST_MUTEX)Mutex);

	xor	edx, edx
	xor	eax, eax
	inc	eax
	push	edx
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], edx
	push	eax
	add	ecx, 12					; 0000000cH
	push	ecx
	call	DWORD PTR __imp__KeInitializeEvent@12

; 1335 : 
; 1336 : }

	ret	0
@KeInitializeGuardedMutex_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KeAcquireGuardedMutex_k8@4
EXTRN	__imp_@ExAcquireFastMutex@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @KeAcquireGuardedMutex_k8@4
_TEXT	SEGMENT
@KeAcquireGuardedMutex_k8@4 PROC			; COMDAT
; _Mutex$ = ecx

; 1342 : {

	npad	2
	push	esi
	mov	esi, ecx

; 1343 :     KeEnterGuardedRegion_k8();

	call	_KeEnterGuardedRegion_k8@0

; 1344 :     ExAcquireFastMutex((PFAST_MUTEX)Mutex);

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_@ExAcquireFastMutex@4
@KeAcquireGuardedMutex_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KeTryToAcquireGuardedMutex_k8@4
EXTRN	__imp_@ExTryToAcquireFastMutex@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @KeTryToAcquireGuardedMutex_k8@4
_TEXT	SEGMENT
@KeTryToAcquireGuardedMutex_k8@4 PROC			; COMDAT
; _Mutex$ = ecx

; 1351 : {

	npad	2
	push	ebx
	push	esi
	mov	esi, ecx

; 1352 :     BOOLEAN    status;
; 1353 :     
; 1354 :     KeEnterGuardedRegion_k8();

	call	_KeEnterGuardedRegion_k8@0

; 1355 :     status = ExTryToAcquireFastMutex((PFAST_MUTEX)Mutex);

	mov	ecx, esi
	call	DWORD PTR __imp_@ExTryToAcquireFastMutex@4
	mov	bl, al

; 1356 :     
; 1357 :     if (status == FALSE) {

	test	bl, bl
	jne	SHORT $LN1@

; 1358 :         KeLeaveGuardedRegion_k8();

	call	_KeLeaveGuardedRegion_k8@0

; 1359 :         KeYieldProcessor();

	pause
$LN1@:
	pop	esi

; 1360 :     }
; 1361 : 
; 1362 :     return status;

	mov	al, bl
	pop	ebx

; 1363 : }

	ret	0
@KeTryToAcquireGuardedMutex_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KeReleaseGuardedMutex_k8@4
EXTRN	__imp_@ExReleaseFastMutex@4:PROC
; Function compile flags: /Ogsp
;	COMDAT @KeReleaseGuardedMutex_k8@4
_TEXT	SEGMENT
@KeReleaseGuardedMutex_k8@4 PROC			; COMDAT
; _Mutex$ = ecx

; 1370 :     ExReleaseFastMutex((PFAST_MUTEX)Mutex);

	call	DWORD PTR __imp_@ExReleaseFastMutex@4

; 1371 :     KeLeaveGuardedRegion_k8();

	jmp	_KeLeaveGuardedRegion_k8@0
@KeReleaseGuardedMutex_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KeAcquireGuardedMutexUnsafe_k8@4
; Function compile flags: /Ogsp
;	COMDAT @KeAcquireGuardedMutexUnsafe_k8@4
_TEXT	SEGMENT
@KeAcquireGuardedMutexUnsafe_k8@4 PROC			; COMDAT
; _FastMutex$ = ecx

; 1379 :     ExAcquireFastMutexUnsafe((PFAST_MUTEX)FastMutex);

	jmp	DWORD PTR __imp_@ExAcquireFastMutexUnsafe@4
@KeAcquireGuardedMutexUnsafe_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KeReleaseGuardedMutexUnsafe_k8@4
; Function compile flags: /Ogsp
;	COMDAT @KeReleaseGuardedMutexUnsafe_k8@4
_TEXT	SEGMENT
@KeReleaseGuardedMutexUnsafe_k8@4 PROC			; COMDAT
; _FastMutex$ = ecx

; 1387 :     ExReleaseFastMutexUnsafe((PFAST_MUTEX)FastMutex);

	jmp	DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4
@KeReleaseGuardedMutexUnsafe_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_GetRoutineAddress_k8@8
EXTRN	__imp__RtlFreeAnsiString@4:PROC
EXTRN	_NtQuerySystemInformation@16:PROC
EXTRN	__imp__MmUserProbeAddress:DWORD
EXTRN	__imp__KeDelayExecutionThread@12:PROC
EXTRN	__imp__RtlUnicodeStringToAnsiString@12:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogsp
;	COMDAT _GetRoutineAddress_k8@8
_TEXT	SEGMENT
_AnsiString$ = -12					; size = 8
_ReturnLength$ = -4					; size = 4
_Index$26404 = 8					; size = 4
_ModuleInformation$ = 8					; size = 4
_SystemRoutineName$ = 8					; size = 4
_Modulename$ = 12					; size = 4
_GetRoutineAddress_k8@8 PROC				; COMDAT

; 1396 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 1397 :     NTSTATUS                Status;
; 1398 :     ANSI_STRING             AnsiString;
; 1399 :     PVOID                   FunctionAddress;
; 1400 :     LOGICAL                 Found;
; 1401 :     ULONG                   ReturnLength;
; 1402 :     PRTL_PROCESS_MODULES    ModuleInformation;
; 1403 :     PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
; 1404 :     CHAR                   *FileName;
; 1405 :     ULONG_PTR               OldUserProbeAddress;
; 1406 :     ULONG_PTR              *pUserProbeAddress;
; 1407 : 
; 1408 :     do {
; 1409 :         Status = RtlUnicodeStringToAnsiString(&AnsiString,
; 1410 :                                               SystemRoutineName,
; 1411 :                                               TRUE);

	mov	esi, DWORD PTR __imp__RtlUnicodeStringToAnsiString@12
	push	edi
	jmp	SHORT $LN29@GetRoutine
$LL13@GetRoutine:

; 1412 :         if (NT_SUCCESS(Status))
; 1413 :         {
; 1414 :             break;
; 1415 :         }
; 1416 : 
; 1417 :         KeDelayExecutionThread(KernelMode, FALSE, (PLARGE_INTEGER)&MmShortTime);

	push	OFFSET _MmShortTime
	push	0
	push	0
	call	DWORD PTR __imp__KeDelayExecutionThread@12
$LN29@GetRoutine:
	push	1
	push	DWORD PTR _SystemRoutineName$[ebp]
	lea	eax, DWORD PTR _AnsiString$[ebp]
	push	eax
	call	esi
	test	eax, eax
	jl	SHORT $LL13@GetRoutine

; 1418 : 
; 1419 :     } while (TRUE);
; 1420 : 
; 1421 :     if (KeGetCurrentIrql() >= DISPATCH_LEVEL)

	call	DWORD PTR __imp__KeGetCurrentIrql@0

; 1422 :         ModuleInformation = (PRTL_PROCESS_MODULES) ExAllocatePoolWithTag(NonPagedPool, NtQuery_BUFFERSIZE * sizeof(UCHAR), 'pmuD');

	push	1886221636				; 706d7544H
	mov	esi, 102400				; 00019000H
	push	esi
	cmp	al, 2
	jb	SHORT $LN9@GetRoutine
	push	0

; 1423 :     else    

	jmp	SHORT $LN30@GetRoutine
$LN9@GetRoutine:

; 1424 :         ModuleInformation = (PRTL_PROCESS_MODULES) ExAllocatePoolWithTag(PagedPool,    NtQuery_BUFFERSIZE * sizeof(UCHAR), 'pmuD');

	push	1
$LN30@GetRoutine:
	call	DWORD PTR __imp__ExAllocatePoolWithTag@12

; 1425 : 
; 1426 :     RtlZeroMemory(ModuleInformation, NtQuery_BUFFERSIZE * sizeof(UCHAR));

	push	esi
	push	0
	push	eax
	mov	DWORD PTR _ModuleInformation$[ebp], eax
	call	_memset

; 1427 : 
; 1428 :     pUserProbeAddress = &MmUserProbeAddress;

	mov	edi, DWORD PTR __imp__MmUserProbeAddress

; 1429 :     OldUserProbeAddress = *pUserProbeAddress;

	mov	ebx, DWORD PTR [edi]

; 1430 :     *pUserProbeAddress  = (ULONG_PTR)-1; // hack to allow NtQuerySystemInformation write

	or	DWORD PTR [edi], -1
	add	esp, 12					; 0000000cH

; 1431 :                                          // to Buffer allocated in kernel space > 0x7FFF0000
; 1432 :     Status = NtQuerySystemInformation(  SystemModuleInformation,
; 1433 :                                         ModuleInformation,
; 1434 :                                         NtQuery_BUFFERSIZE * sizeof(UCHAR),
; 1435 :                                         &ReturnLength );

	lea	eax, DWORD PTR _ReturnLength$[ebp]
	push	eax
	push	esi
	mov	esi, DWORD PTR _ModuleInformation$[ebp]
	push	esi
	push	11					; 0000000bH
	call	_NtQuerySystemInformation@16

; 1436 :     *pUserProbeAddress  = OldUserProbeAddress;

	mov	DWORD PTR [edi], ebx

; 1437 : 
; 1438 :     if (Status != STATUS_SUCCESS) {

	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN7@GetRoutine
$LN23@GetRoutine:

; 1439 :         RtlFreeAnsiString (&AnsiString);

	lea	eax, DWORD PTR _AnsiString$[ebp]
	push	eax
	call	DWORD PTR __imp__RtlFreeAnsiString@4

; 1440 :         ExFreePoolWithTag(ModuleInformation, 'pmuD');

	push	1886221636				; 706d7544H
	push	esi
	call	DWORD PTR __imp__ExFreePoolWithTag@8

; 1441 :         return NULL;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1462 :         
; 1463 :     RtlFreeAnsiString (&AnsiString);
; 1464 :     ExFreePoolWithTag(ModuleInformation, 'pmuD');
; 1465 :     return FunctionAddress;
; 1466 : }

	leave
	ret	8
$LN7@GetRoutine:

; 1442 :     }
; 1443 : 
; 1444 :     Found = FALSE;
; 1445 :     for (ULONG Index = 0; Index < ModuleInformation->NumberOfModules; Index++)

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _Index$26404[ebp], edi
	cmp	ebx, edi
	jbe	SHORT $LN2@GetRoutine
	lea	edi, DWORD PTR [esi+4]
$LL6@GetRoutine:

; 1446 :     {
; 1447 :         ModuleInfo = &ModuleInformation->Modules[Index];
; 1448 :         FileName = (CHAR *)ModuleInfo->FullPathName + ModuleInfo->OffsetToFileName;
; 1449 : 
; 1450 :             if (strcmp(FileName, Modulename) == 0)

	movzx	eax, WORD PTR [edi+26]
	mov	ecx, DWORD PTR _Modulename$[ebp]
	lea	eax, DWORD PTR [eax+edi+28]
$LL24@GetRoutine:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN25@GetRoutine
	test	dl, dl
	je	SHORT $LN26@GetRoutine
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN25@GetRoutine
	inc	eax
	inc	eax
	inc	ecx
	inc	ecx
	test	dl, dl
	jne	SHORT $LL24@GetRoutine
$LN26@GetRoutine:
	xor	eax, eax
	jmp	SHORT $LN27@GetRoutine
$LN25@GetRoutine:
	sbb	eax, eax
	sbb	eax, -1
$LN27@GetRoutine:
	test	eax, eax
	je	SHORT $LN20@GetRoutine
	inc	DWORD PTR _Index$26404[ebp]
	add	edi, 284				; 0000011cH
	cmp	DWORD PTR _Index$26404[ebp], ebx
	jb	SHORT $LL6@GetRoutine
$LN2@GetRoutine:

; 1461 :         FunctionAddress = NULL;

	xor	eax, eax
$LN1@GetRoutine:
	mov	edi, eax
	jmp	SHORT $LN23@GetRoutine
$LN20@GetRoutine:

; 1451 :             {
; 1452 :                 Found = TRUE;
; 1453 :                 break;
; 1454 :             }
; 1455 :     }
; 1456 :     
; 1457 :     if (Found == TRUE)
; 1458 :         FunctionAddress = MiFindExportedRoutineByName_k8( ModuleInfo->ImageBase,
; 1459 :                                                        &AnsiString );

	lea	eax, DWORD PTR _AnsiString$[ebp]
	push	eax
	push	DWORD PTR [edi+8]
	call	_MiFindExportedRoutineByName_k8@8

; 1460 :     else

	jmp	SHORT $LN1@GetRoutine
_GetRoutineAddress_k8@8 ENDP
_TEXT	ENDS
PUBLIC	_GetModuleBaseAddress_k8@16
; Function compile flags: /Ogsp
;	COMDAT _GetModuleBaseAddress_k8@16
_TEXT	SEGMENT
_ReturnLength$ = -8					; size = 4
_Index$26438 = -4					; size = 4
_ModuleInformation$ = -4				; size = 4
_Modulename$ = 8					; size = 4
_ModuleSize$ = 12					; size = 4
_ByOrderMode$ = 16					; size = 4
_OrderNum$ = 20						; size = 4
_GetModuleBaseAddress_k8@16 PROC			; COMDAT

; 1475 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi

; 1476 :     NTSTATUS                Status;
; 1477 :     PVOID                   FunctionAddress;
; 1478 :     LOGICAL                 Found;
; 1479 :     ULONG                   ReturnLength;
; 1480 :     PRTL_PROCESS_MODULES    ModuleInformation;
; 1481 :     PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
; 1482 :     CHAR                   *FileName;
; 1483 :     ULONG_PTR               OldUserProbeAddress;
; 1484 :     ULONG_PTR              *pUserProbeAddress;
; 1485 : 
; 1486 :     if (KeGetCurrentIrql() >= DISPATCH_LEVEL)

	call	DWORD PTR __imp__KeGetCurrentIrql@0

; 1487 :         ModuleInformation = (PRTL_PROCESS_MODULES) ExAllocatePoolWithTag(NonPagedPool, NtQuery_BUFFERSIZE * sizeof(UCHAR), 'pmuD');

	push	1886221636				; 706d7544H
	mov	edi, 102400				; 00019000H
	push	edi
	cmp	al, 2
	jb	SHORT $LN12@GetModuleB
	push	0

; 1488 :     else    

	jmp	SHORT $LN27@GetModuleB
$LN12@GetModuleB:

; 1489 :         ModuleInformation = (PRTL_PROCESS_MODULES) ExAllocatePoolWithTag(PagedPool,    NtQuery_BUFFERSIZE * sizeof(UCHAR), 'pmuD');

	push	1
$LN27@GetModuleB:
	call	DWORD PTR __imp__ExAllocatePoolWithTag@12

; 1490 : 
; 1491 :     RtlZeroMemory(ModuleInformation, NtQuery_BUFFERSIZE * sizeof(UCHAR));

	push	edi
	push	0
	push	eax
	mov	DWORD PTR _ModuleInformation$[ebp], eax
	call	_memset

; 1492 : 
; 1493 :     pUserProbeAddress = &MmUserProbeAddress;

	mov	esi, DWORD PTR __imp__MmUserProbeAddress

; 1494 :     OldUserProbeAddress = *pUserProbeAddress;

	mov	ebx, DWORD PTR [esi]

; 1495 :     *pUserProbeAddress  = (ULONG_PTR)-1; // hack to allow NtQuerySystemInformation write

	or	DWORD PTR [esi], -1
	add	esp, 12					; 0000000cH

; 1496 :                                          // to Buffer allocated in kernel space > 0x7FFF0000
; 1497 :     Status = NtQuerySystemInformation(  SystemModuleInformation,
; 1498 :                                         ModuleInformation,
; 1499 :                                         NtQuery_BUFFERSIZE * sizeof(UCHAR),
; 1500 :                                         &ReturnLength );

	lea	eax, DWORD PTR _ReturnLength$[ebp]
	push	eax
	push	edi
	mov	edi, DWORD PTR _ModuleInformation$[ebp]
	push	edi
	push	11					; 0000000bH
	call	_NtQuerySystemInformation@16

; 1501 :     *pUserProbeAddress  = OldUserProbeAddress;

	mov	DWORD PTR [esi], ebx

; 1502 : 
; 1503 :     if (Status != STATUS_SUCCESS) {

	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN10@GetModuleB
$LN20@GetModuleB:

; 1504 :         ExFreePoolWithTag(ModuleInformation, 'pmuD');

	push	1886221636				; 706d7544H
	push	edi
	call	DWORD PTR __imp__ExFreePoolWithTag@8
	pop	edi

; 1505 :         return NULL;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1534 :         }
; 1535 :     }
; 1536 : 
; 1537 :     ExFreePoolWithTag(ModuleInformation, 'pmuD');
; 1538 :     return FunctionAddress;
; 1539 : }

	leave
	ret	16					; 00000010H
$LN10@GetModuleB:

; 1506 :     }
; 1507 : 
; 1508 :     Found = FALSE;
; 1509 :     for (ULONG Index = 0; Index < ModuleInformation->NumberOfModules; Index++)

	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR _Index$26438[ebp], esi
	cmp	ebx, esi
	jbe	SHORT $LN4@GetModuleB
	lea	esi, DWORD PTR [edi+4]
$LL25@GetModuleB:

; 1510 :     {
; 1511 :         ModuleInfo = &ModuleInformation->Modules[Index];
; 1512 :         FileName = (CHAR *)ModuleInfo->FullPathName + ModuleInfo->OffsetToFileName;
; 1513 : 
; 1514 :         if (ByOrderMode && Index == OrderNum) {

	cmp	DWORD PTR _ByOrderMode$[ebp], 0
	movzx	eax, WORD PTR [esi+26]
	lea	eax, DWORD PTR [eax+esi+28]
	je	SHORT $LN6@GetModuleB
	mov	ecx, DWORD PTR _Index$26438[ebp]
	cmp	ecx, DWORD PTR _OrderNum$[ebp]
	je	SHORT $LN26@GetModuleB
$LN6@GetModuleB:

; 1515 :             Found = TRUE;
; 1516 :             break;
; 1517 :         }
; 1518 : 
; 1519 :         if (strcmp(FileName, Modulename) == 0) {

	mov	ecx, DWORD PTR _Modulename$[ebp]
$LL21@GetModuleB:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN22@GetModuleB
	test	dl, dl
	je	SHORT $LN23@GetModuleB
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN22@GetModuleB
	inc	eax
	inc	eax
	inc	ecx
	inc	ecx
	test	dl, dl
	jne	SHORT $LL21@GetModuleB
$LN23@GetModuleB:
	xor	eax, eax
	jmp	SHORT $LN24@GetModuleB
$LN22@GetModuleB:
	sbb	eax, eax
	sbb	eax, -1
$LN24@GetModuleB:
	test	eax, eax
	je	SHORT $LN26@GetModuleB
	inc	DWORD PTR _Index$26438[ebp]
	add	esi, 284				; 0000011cH
	cmp	DWORD PTR _Index$26438[ebp], ebx
	jb	SHORT $LL25@GetModuleB
$LN4@GetModuleB:

; 1531 :         FunctionAddress = NULL;
; 1532 :         if (ModuleSize) {

	mov	ecx, DWORD PTR _ModuleSize$[ebp]
	xor	eax, eax
	cmp	ecx, eax
	je	SHORT $LN1@GetModuleB

; 1533 :             *ModuleSize = 0;

	mov	DWORD PTR [ecx], eax
$LN1@GetModuleB:
	mov	esi, eax
	jmp	SHORT $LN20@GetModuleB
$LN26@GetModuleB:

; 1520 :             Found = TRUE;
; 1521 :             break;
; 1522 :         }
; 1523 :     }
; 1524 :     
; 1525 :     if (Found == TRUE) {
; 1526 :         FunctionAddress = ModuleInfo->ImageBase;
; 1527 :         if (ModuleSize) {

	mov	ecx, DWORD PTR _ModuleSize$[ebp]
	mov	eax, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN1@GetModuleB

; 1528 :             *ModuleSize = ModuleInfo->ImageSize;

	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx], edx

; 1529 :         }
; 1530 :     } else {

	jmp	SHORT $LN1@GetModuleB
_GetModuleBaseAddress_k8@16 ENDP
_TEXT	ENDS
PUBLIC	@KiAcquireQueuedLock_k8@4
; Function compile flags: /Ogsp
;	COMDAT @KiAcquireQueuedLock_k8@4
_TEXT	SEGMENT
@KiAcquireQueuedLock_k8@4 PROC				; COMDAT
; _QueuedLock$ = ecx

; 1547 :     PKSPIN_LOCK_QUEUE Previous;
; 1548 :     PKSPIN_LOCK Lock;
; 1549 :     volatile ULONG_PTR * LockPointer;
; 1550 : 
; 1551 :     LockPointer = (volatile ULONG_PTR *)&QueuedLock->Lock;
; 1552 : 
; 1553 :     Previous = (PKSPIN_LOCK_QUEUE) InterlockedExchangePointer((volatile PVOID *)QueuedLock->Lock, QueuedLock);

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, ecx
	xchg	DWORD PTR [edx], eax

; 1554 : 
; 1555 :     if (Previous == NULL) {

	test	eax, eax
	jne	SHORT $LN4@

; 1556 : 
; 1557 :         //
; 1558 :         // This processor now owns this lock.
; 1559 :         //
; 1560 : 
; 1561 :         *LockPointer |= LOCK_QUEUE_OWNER;

	or	DWORD PTR [ecx+4], 2

; 1576 :         }
; 1577 :     }
; 1578 : 
; 1579 :     //
; 1580 :     // Lock has been acquired.
; 1581 :     //
; 1582 : }

	ret	0
$LN4@:

; 1562 : 
; 1563 :     } else {
; 1564 : 
; 1565 :         //
; 1566 :         // Lock is already held, update thew next pointer in the
; 1567 :         // previous queue entry to point to this new waiter and 
; 1568 :         // wait until the lock is granted.
; 1569 :         //
; 1570 : 
; 1571 :         *LockPointer |= LOCK_QUEUE_WAIT;

	or	DWORD PTR [ecx+4], 1

; 1572 :         Previous->Next = QueuedLock;

	mov	DWORD PTR [eax], ecx

; 1573 : 
; 1574 :         while (*LockPointer & LOCK_QUEUE_WAIT) {

	jmp	SHORT $LN10@
$LL2@:

; 1575 :             KeYieldProcessor();

	pause
$LN10@:

; 1573 : 
; 1574 :         while (*LockPointer & LOCK_QUEUE_WAIT) {

	mov	eax, DWORD PTR [ecx+4]
	test	al, 1
	jne	SHORT $LL2@

; 1576 :         }
; 1577 :     }
; 1578 : 
; 1579 :     //
; 1580 :     // Lock has been acquired.
; 1581 :     //
; 1582 : }

	ret	0
@KiAcquireQueuedLock_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KiReleaseQueuedLock_k8@4
; Function compile flags: /Ogsp
;	COMDAT @KiReleaseQueuedLock_k8@4
_TEXT	SEGMENT
@KiReleaseQueuedLock_k8@4 PROC				; COMDAT
; _QueuedLock$ = ecx

; 1590 :     PKSPIN_LOCK_QUEUE Waiter;
; 1591 : 
; 1592 :     //
; 1593 :     // Get the address of the actual lock and strip out the bottom
; 1594 :     // two bits which are used for status.
; 1595 :     //
; 1596 : 
; 1597 :     QueuedLock->Lock = (PKSPIN_LOCK)((ULONG_PTR)QueuedLock->Lock & ~3);

	and	DWORD PTR [ecx+4], -4			; fffffffcH

; 1598 : 
; 1599 :     Waiter = (PKSPIN_LOCK_QUEUE)*QueuedLock->Lock;

	mov	eax, DWORD PTR [ecx+4]

; 1600 : 
; 1601 :     if (Waiter == QueuedLock) {

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN9@
	push	esi

; 1602 : 
; 1603 :         //
; 1604 :         // Good chance noone is queued on this lock, to be sure
; 1605 :         // we need to do an interlocked operation on it.
; 1606 :         // Note: This is just an optimization, there is no point
; 1607 :         // in doing the interlocked compare exchange if someone
; 1608 :         // else has already joined the queue.
; 1609 :         //
; 1610 : 
; 1611 :         Waiter = (PKSPIN_LOCK_QUEUE) InterlockedCompareExchangePointer((volatile PVOID *) QueuedLock->Lock,
; 1612 :                                                    NULL,
; 1613 :                                                    QueuedLock);

	mov	esi, DWORD PTR [ecx+4]
	xor	edx, edx
	mov	eax, ecx
	lock	 cmpxchg DWORD PTR [esi], edx
	pop	esi

; 1614 :     }
; 1615 :     if (Waiter != QueuedLock) {

	cmp	eax, ecx
	je	SHORT $LN3@

; 1616 : 
; 1617 :         //
; 1618 :         // There is another waiter.  It is possible for the waiter
; 1619 :         // to have only just performed the exchange that put its 
; 1620 :         // context in the lock and to have not yet updated the
; 1621 :         // 'next' pointer in the previous context (which could be 
; 1622 :         // this context), so we wait for our next pointer to be
; 1623 :         // non-null before continuing.
; 1624 :         //
; 1625 : 
; 1626 :         volatile PKSPIN_LOCK_QUEUE * NextQueuedLock = &QueuedLock->Next;
; 1627 : 
; 1628 :         while ((Waiter = *NextQueuedLock) == NULL) {

	jmp	SHORT $LN9@
$LL2@:

; 1629 :             KeYieldProcessor();

	pause
$LN9@:

; 1616 : 
; 1617 :         //
; 1618 :         // There is another waiter.  It is possible for the waiter
; 1619 :         // to have only just performed the exchange that put its 
; 1620 :         // context in the lock and to have not yet updated the
; 1621 :         // 'next' pointer in the previous context (which could be 
; 1622 :         // this context), so we wait for our next pointer to be
; 1623 :         // non-null before continuing.
; 1624 :         //
; 1625 : 
; 1626 :         volatile PKSPIN_LOCK_QUEUE * NextQueuedLock = &QueuedLock->Next;
; 1627 : 
; 1628 :         while ((Waiter = *NextQueuedLock) == NULL) {

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LL2@

; 1630 :         }
; 1631 : 
; 1632 :         //
; 1633 :         // Pass the lock on to the next in line.
; 1634 :         //
; 1635 : 
; 1636 :         *((PULONG_PTR)&Waiter->Lock) ^= (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER);

	xor	DWORD PTR [eax+4], 3

; 1637 :         QueuedLock->Next = NULL;

	mov	DWORD PTR [ecx], 0
$LN3@:

; 1638 :     }
; 1639 : }

	ret	0
@KiReleaseQueuedLock_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KeAcquireQueuedSpinLockAtDpcLevel_k8@4
; Function compile flags: /Ogsp
;	COMDAT @KeAcquireQueuedSpinLockAtDpcLevel_k8@4
_TEXT	SEGMENT
@KeAcquireQueuedSpinLockAtDpcLevel_k8@4 PROC		; COMDAT
; _QueuedLock$ = ecx

; 1648 :     KiAcquireQueuedLock_k8(QueuedLock);

	jmp	@KiAcquireQueuedLock_k8@4
@KeAcquireQueuedSpinLockAtDpcLevel_k8@4 ENDP
_TEXT	ENDS
PUBLIC	@KeReleaseQueuedSpinLockFromDpcLevel_k8@4
; Function compile flags: /Ogsp
;	COMDAT @KeReleaseQueuedSpinLockFromDpcLevel_k8@4
_TEXT	SEGMENT
@KeReleaseQueuedSpinLockFromDpcLevel_k8@4 PROC		; COMDAT
; _QueuedLock$ = ecx

; 1657 :     KiReleaseQueuedLock_k8(QueuedLock);

	jmp	@KiReleaseQueuedLock_k8@4
@KeReleaseQueuedSpinLockFromDpcLevel_k8@4 ENDP
_TEXT	ENDS
PUBLIC	_memcmpHexSearch@16
; Function compile flags: /Ogsp
;	COMDAT _memcmpHexSearch@16
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_n$ = 16						; size = 4
_patternmask$ = 20					; size = 4
_memcmpHexSearch@16 PROC				; COMDAT

; 1663 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1664 :     if (n != 0) {

	cmp	DWORD PTR _n$[ebp], 0
	push	esi
	je	SHORT $LN3@memcmpHexS

; 1665 :         const unsigned char *p1 = s1, *p2 = s2, *p3 = patternmask;

	mov	eax, DWORD PTR _patternmask$[ebp]

; 1671 :             }
; 1672 : 
; 1673 :         } while (--n != 0);

	mov	ecx, DWORD PTR _s1$[ebp]
	mov	esi, DWORD PTR _s2$[ebp]
	sub	ecx, eax
	sub	esi, eax
$LL5@memcmpHexS:
	mov	dl, BYTE PTR [ecx+eax]
	cmp	dl, BYTE PTR [esi+eax]
	je	SHORT $LN2@memcmpHexS

; 1666 :         do {
; 1667 :             if ( (*p1 != *p2) && (*p3 != 0x00) ) // 0x00 - ignore byte

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN10@memcmpHexS
$LN2@memcmpHexS:

; 1669 :             else {
; 1670 :                 p1++; p2++; p3++;

	inc	eax

; 1671 :             }
; 1672 : 
; 1673 :         } while (--n != 0);

	dec	DWORD PTR _n$[ebp]
	jne	SHORT $LL5@memcmpHexS
$LN3@memcmpHexS:

; 1674 :     }
; 1675 :     return 0;

	xor	eax, eax
$LN7@memcmpHexS:
	pop	esi

; 1676 : }

	pop	ebp
	ret	16					; 00000010H
$LN10@memcmpHexS:

; 1668 :                 return (1); // not match

	xor	eax, eax
	inc	eax
	jmp	SHORT $LN7@memcmpHexS
_memcmpHexSearch@16 ENDP
_TEXT	ENDS
PUBLIC	_MemHexSearch@20
; Function compile flags: /Ogsp
;	COMDAT _MemHexSearch@20
_TEXT	SEGMENT
_s$ = 8							; size = 4
_module_size$ = 12					; size = 4
_pattern$ = 16						; size = 4
_pattern_size$ = 20					; size = 4
_patternmask$ = 24					; size = 4
_MemHexSearch@20 PROC					; COMDAT

; 1682 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 1683 :   unsigned char first_c = pattern[0];
; 1684 :   size_t i = 0;

	mov	ebx, DWORD PTR _pattern_size$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _s$[ebp]
	xor	esi, esi
$LL9@MemHexSear:

; 1685 : 
; 1686 :   do {
; 1687 :     if (i) { i++; }; // increment if i > 0

	test	esi, esi
	je	SHORT $LN17@MemHexSear

; 1690 :     {
; 1691 :      i++;

	jmp	SHORT $LN18@MemHexSear
$LL5@MemHexSear:

; 1688 : 
; 1689 :     while (i < module_size && s[i] != first_c )

	mov	eax, DWORD PTR _pattern$[ebp]
	mov	al, BYTE PTR [eax]
	cmp	BYTE PTR [esi+edi], al
	je	SHORT $LN8@MemHexSear
$LN18@MemHexSear:

; 1690 :     {
; 1691 :      i++;

	inc	esi
$LN17@MemHexSear:

; 1688 : 
; 1689 :     while (i < module_size && s[i] != first_c )

	cmp	esi, DWORD PTR _module_size$[ebp]
	jb	SHORT $LL5@MemHexSear
$LN8@MemHexSear:

; 1692 :     }
; 1693 :   }
; 1694 :   while ((i + pattern_size) < module_size && memcmpHexSearch(&s[i], pattern, pattern_size, patternmask) != 0);

	lea	eax, DWORD PTR [esi+ebx]
	cmp	eax, DWORD PTR _module_size$[ebp]
	jae	SHORT $LN3@MemHexSear
	push	DWORD PTR _patternmask$[ebp]
	lea	eax, DWORD PTR [esi+edi]
	push	ebx
	push	DWORD PTR _pattern$[ebp]
	push	eax
	call	_memcmpHexSearch@16
	test	eax, eax
	jne	SHORT $LL9@MemHexSear
$LN3@MemHexSear:

; 1695 : 
; 1696 :   if ((i + pattern_size) >= module_size)

	lea	eax, DWORD PTR [esi+ebx]
	cmp	eax, DWORD PTR _module_size$[ebp]
	jb	SHORT $LN2@MemHexSear

; 1697 :       return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@MemHexSear
$LN2@MemHexSear:

; 1698 :   else
; 1699 :       return (char *) &s[i];

	lea	eax, DWORD PTR [esi+edi]
$LN1@MemHexSear:
	pop	edi
	pop	esi
	pop	ebx

; 1700 : }

	pop	ebp
	ret	20					; 00000014H
_MemHexSearch@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@FNODOBFM@			;  ?? ::FNODOBFM::`string'
PUBLIC	_ModuleHexSearch@16
;	COMDAT ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@FNODOBFM@ DB 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _ModuleHexSearch@16
_TEXT	SEGMENT
_mod_size$ = 8						; size = 4
_ModuleNum$ = 8						; size = 4
_pattern$ = 12						; size = 4
_pattern_size$ = 16					; size = 4
_patternmask$ = 20					; size = 4
_ModuleHexSearch@16 PROC				; COMDAT

; 1706 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1707 :     unsigned char* ptr;
; 1708 :     int   mod_size;
; 1709 :     char* found_adr;
; 1710 : 
; 1711 :     ptr = (unsigned char*) GetModuleBaseAddress_k8("", &mod_size, 1, ModuleNum);

	push	DWORD PTR _ModuleNum$[ebp]
	lea	eax, DWORD PTR _mod_size$[ebp]
	push	1
	push	eax
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
	call	_GetModuleBaseAddress_k8@16

; 1712 : 
; 1713 :     if (ptr) {

	test	eax, eax
	je	SHORT $LN2@ModuleHexS

; 1714 :         return MemHexSearch(ptr, mod_size, pattern, pattern_size, patternmask);

	push	DWORD PTR _patternmask$[ebp]
	push	DWORD PTR _pattern_size$[ebp]
	push	DWORD PTR _pattern$[ebp]
	push	DWORD PTR _mod_size$[ebp]
	push	eax
	call	_MemHexSearch@20
	jmp	SHORT $LN1@ModuleHexS
$LN2@ModuleHexS:

; 1715 :     } else {
; 1716 :         return NULL;

	xor	eax, eax
$LN1@ModuleHexS:

; 1717 :     }
; 1718 : }

	pop	ebp
	ret	16					; 00000010H
_ModuleHexSearch@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@FCNJBIBJ@?$AAL?$AAp?$AAc?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAW?$AAa?$AAi?$AAt?$AAR?$AAe?$AAp?$AAl?$AAy?$AAP?$AAo?$AAr?$AAt?$AAE?$AAx?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CE@LDBIOGGN@?$AAK?$AAe?$AAT?$AAe?$AAs?$AAt?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BM@FFAKGFCC@?$AAK?$AAe?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_WRK2003_Init@0
EXTRN	__imp__MmGetSystemRoutineAddress@4:PROC
;	COMDAT ??_C@_1DE@FCNJBIBJ@?$AAL?$AAp?$AAc?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAW?$AAa?$AAi?$AAt?$AAR?$AAe?$AAp?$AAl?$AAy?$AAP?$AAo?$AAr?$AAt?$AAE?$AAx?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1DE@FCNJBIBJ@?$AAL?$AAp?$AAc?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAW?$AAa?$AAi?$AAt?$AAR?$AAe?$AAp?$AAl?$AAy?$AAP?$AAo?$AAr?$AAt?$AAE?$AAx?$AA?$AA@FNODOBFM@ DB 'L'
	DB	00H, 'p', 00H, 'c', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H
	DB	'e', 00H, 's', 00H, 't', 00H, 'W', 00H, 'a', 00H, 'i', 00H, 't'
	DB	00H, 'R', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'y', 00H, 'P', 00H
	DB	'o', 00H, 'r', 00H, 't', 00H, 'E', 00H, 'x', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CE@LDBIOGGN@?$AAK?$AAe?$AAT?$AAe?$AAs?$AAt?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CE@LDBIOGGN@?$AAK?$AAe?$AAT?$AAe?$AAs?$AAt?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@ DB 'K'
	DB	00H, 'e', 00H, 'T', 00H, 'e', 00H, 's', 00H, 't', 00H, 'A', 00H
	DB	'l', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'T', 00H, 'h', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BM@FFAKGFCC@?$AAK?$AAe?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BM@FFAKGFCC@?$AAK?$AAe?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@ DB 'K'
	DB	00H, 'e', 00H, 'A', 00H, 'l', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 00H
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Ogsp
text$s	ENDS
;	COMDAT _WRK2003_Init@0
_TEXT	SEGMENT
_LpcRequestWaitReplyPortExName$ = -24			; size = 8
_KeTestAlertThreadName$ = -16				; size = 8
_KeAlertThreadName$ = -8				; size = 8
_WRK2003_Init@0 PROC					; COMDAT

; 1905 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi

; 1906 : UNICODE_STRING KeInvalidateAllCachesName       = RTL_CONSTANT_STRING(L"KeInvalidateAllCaches");
; 1907 : UNICODE_STRING KeAlertThreadName     = RTL_CONSTANT_STRING(L"KeAlertThread");

	push	26					; 0000001aH
	pop	eax
	push	28					; 0000001cH

; 1908 : UNICODE_STRING KeTestAlertThreadName = RTL_CONSTANT_STRING(L"KeTestAlertThread");
; 1909 : UNICODE_STRING LpcRequestWaitReplyPortExName = RTL_CONSTANT_STRING(L"LpcRequestWaitReplyPortEx");	
; 1910 : #if (NTDDI_VERSION < NTDDI_VISTA) && defined(_X86_)
; 1911 : 
; 1912 : #if (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION <= NTDDI_WINXPSP4)
; 1913 : ////////////////////////////////////////////////////// 
; 1914 : //  KeInvalidateAllCaches
; 1915 : gTramp_KeInvalidateAllCaches = (PFN_BOOLEAN)MmGetSystemRoutineAddress(&KeInvalidateAllCachesName);
; 1916 : if(gTramp_KeInvalidateAllCaches == NULL){
; 1917 : 	gTramp_KeInvalidateAllCaches = (PFN_BOOLEAN) ModuleHexSearch(MODULE_NTOSKRNL, KeInvalidateAllCaches_magic1, sizeof(KeInvalidateAllCaches_magic1), KeInvalidateAllCaches_magic1mask);
; 1918 : 	if (!gTramp_KeInvalidateAllCaches)
; 1919 : 		gTramp_KeInvalidateAllCaches = (PFN_BOOLEAN) ModuleHexSearch(MODULE_NTOSKRNL, KeInvalidateAllCaches_magic2, sizeof(KeInvalidateAllCaches_magic2), KeInvalidateAllCaches_magic2mask);
; 1920 : 		if (!gTramp_KeInvalidateAllCaches)
; 1921 : 			gTramp_KeInvalidateAllCaches = (PFN_BOOLEAN) ModuleHexSearch(MODULE_NTOSKRNL, KeInvalidateAllCaches_magic3, sizeof(KeInvalidateAllCaches_magic3), KeInvalidateAllCaches_magic3mask);
; 1922 : 				if (!gTramp_KeInvalidateAllCaches)
; 1923 : 				gTramp_KeInvalidateAllCaches = (PFN_BOOLEAN) ModuleHexSearch(MODULE_NTOSKRNL, KeInvalidateAllCaches_magic4, sizeof(KeInvalidateAllCaches_magic4), KeInvalidateAllCaches_magic4mask);
; 1924 : 					if (!gTramp_KeInvalidateAllCaches)
; 1925 : 						KeBugCheckEx(0xDEADBEEFL, 5, 0, 0, 2);
; 1926 : }
; 1927 : //////////////////////////////////////////////////////
; 1928 : #endif // WinXP RTM <> SP4
; 1929 : 
; 1930 : 
; 1931 : //////////////////////////////////////////////////////   
; 1932 : //  KeAlertThread
; 1933 : gTramp_KeAlertThread = (PFN_BOOLEAN_PKTHREAD_KPROCESSOR_MODE)MmGetSystemRoutineAddress(&KeAlertThreadName);

	mov	esi, DWORD PTR __imp__MmGetSystemRoutineAddress@4
	mov	WORD PTR _KeAlertThreadName$[ebp], ax
	pop	eax
	push	34					; 00000022H
	mov	WORD PTR _KeAlertThreadName$[ebp+2], ax
	pop	eax
	push	36					; 00000024H
	mov	WORD PTR _KeTestAlertThreadName$[ebp], ax
	pop	eax
	push	50					; 00000032H
	mov	WORD PTR _KeTestAlertThreadName$[ebp+2], ax
	pop	eax
	push	52					; 00000034H
	mov	WORD PTR _LpcRequestWaitReplyPortExName$[ebp], ax
	pop	eax
	mov	WORD PTR _LpcRequestWaitReplyPortExName$[ebp+2], ax
	lea	eax, DWORD PTR _KeAlertThreadName$[ebp]
	push	eax
	mov	DWORD PTR _KeAlertThreadName$[ebp+4], OFFSET ??_C@_1BM@FFAKGFCC@?$AAK?$AAe?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@
	mov	DWORD PTR _KeTestAlertThreadName$[ebp+4], OFFSET ??_C@_1CE@LDBIOGGN@?$AAK?$AAe?$AAT?$AAe?$AAs?$AAt?$AAA?$AAl?$AAe?$AAr?$AAt?$AAT?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?$AA@FNODOBFM@
	mov	DWORD PTR _LpcRequestWaitReplyPortExName$[ebp+4], OFFSET ??_C@_1DE@FCNJBIBJ@?$AAL?$AAp?$AAc?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAW?$AAa?$AAi?$AAt?$AAR?$AAe?$AAp?$AAl?$AAy?$AAP?$AAo?$AAr?$AAt?$AAE?$AAx?$AA?$AA@FNODOBFM@
	call	esi

; 1934 : if(gTramp_KeAlertThread == NULL){

	xor	edi, edi
	mov	DWORD PTR _gTramp_KeAlertThread, eax
	cmp	eax, edi
	jne	SHORT $LN8@WRK2003_In

; 1935 : 	gTramp_KeAlertThread = (PFN_BOOLEAN_PKTHREAD_KPROCESSOR_MODE) ModuleHexSearch(MODULE_NTOSKRNL, KeAlertThread_magic1, sizeof(KeAlertThread_magic1), KeAlertThread_magic1mask);

	push	OFFSET _KeAlertThread_magic1mask
	push	36					; 00000024H
	push	OFFSET _KeAlertThread_magic1
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_KeAlertThread, eax

; 1936 : 	if (!gTramp_KeAlertThread)

	cmp	eax, edi
	jne	SHORT $LN8@WRK2003_In

; 1937 : 		gTramp_KeAlertThread = (PFN_BOOLEAN_PKTHREAD_KPROCESSOR_MODE) ModuleHexSearch(MODULE_NTOSKRNL, KeAlertThread_magic2, sizeof(KeAlertThread_magic2), KeAlertThread_magic2mask);

	push	OFFSET _KeAlertThread_magic2mask
	push	33					; 00000021H
	push	OFFSET _KeAlertThread_magic2
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_KeAlertThread, eax

; 1938 : 		if (!gTramp_KeAlertThread)

	cmp	eax, edi
	jne	SHORT $LN8@WRK2003_In

; 1939 : 			gTramp_KeAlertThread = (PFN_BOOLEAN_PKTHREAD_KPROCESSOR_MODE) ModuleHexSearch(MODULE_NTOSKRNL, KeAlertThread_magic1chk, sizeof(KeAlertThread_magic1chk), KeAlertThread_magic1chkmask);

	push	OFFSET _KeAlertThread_magic1chkmask
	push	19					; 00000013H
	push	OFFSET _KeAlertThread_magic1chk
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_KeAlertThread, eax

; 1940 : 			if (!gTramp_KeAlertThread)

	cmp	eax, edi
	jne	SHORT $LN8@WRK2003_In

; 1941 : 				KeBugCheckEx(0xDEADBEEFL, 5, 0, 0, 3);

	push	3
$LN15@WRK2003_In:
	push	edi
	push	edi
	push	5
	push	-559038737				; deadbeefH
	call	DWORD PTR __imp__KeBugCheckEx@20
$LN16@WRK2003_In:
$LN8@WRK2003_In:

; 1942 : }
; 1943 : //////////////////////////////////////////////////////
; 1944 : 
; 1945 : 
; 1946 : //////////////////////////////////////////////////////   
; 1947 : //  KeTestAlertThread
; 1948 : gTramp_KeTestAlertThread = (PFN_BOOLEAN_KPROCESSOR_MODE)MmGetSystemRoutineAddress(&KeTestAlertThreadName);

	lea	eax, DWORD PTR _KeTestAlertThreadName$[ebp]
	push	eax
	call	esi
	mov	DWORD PTR _gTramp_KeTestAlertThread, eax

; 1949 : if(gTramp_KeTestAlertThread == NULL){

	cmp	eax, edi
	jne	SHORT $LN4@WRK2003_In

; 1950 : 	gTramp_KeTestAlertThread = (PFN_BOOLEAN_KPROCESSOR_MODE) ModuleHexSearch(MODULE_NTOSKRNL, KeTestAlertThread_magic1, sizeof(KeTestAlertThread_magic1), KeTestAlertThread_magic1mask);

	push	OFFSET _KeTestAlertThread_magic1mask
	push	35					; 00000023H
	push	OFFSET _KeTestAlertThread_magic1
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_KeTestAlertThread, eax

; 1951 : 	if (!gTramp_KeTestAlertThread)

	cmp	eax, edi
	jne	SHORT $LN4@WRK2003_In

; 1952 : 		gTramp_KeTestAlertThread = (PFN_BOOLEAN_KPROCESSOR_MODE) ModuleHexSearch(MODULE_NTOSKRNL, KeTestAlertThread_magic2, sizeof(KeTestAlertThread_magic2), KeTestAlertThread_magic2mask);

	push	DWORD PTR _KeTestAlertThread_magic2mask
	push	4
	push	DWORD PTR _KeTestAlertThread_magic2
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_KeTestAlertThread, eax

; 1953 : 		if (!gTramp_KeTestAlertThread)

	cmp	eax, edi
	jne	SHORT $LN4@WRK2003_In

; 1954 : 			gTramp_KeTestAlertThread = (PFN_BOOLEAN_KPROCESSOR_MODE) ModuleHexSearch(MODULE_NTOSKRNL, KeTestAlertThread_magic1chk, sizeof(KeTestAlertThread_magic1chk), KeTestAlertThread_magic1chkmask);

	push	OFFSET _KeTestAlertThread_magic1chkmask
	push	18					; 00000012H
	push	OFFSET _KeTestAlertThread_magic1chk
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_KeTestAlertThread, eax

; 1955 : 			if (!gTramp_KeTestAlertThread)

	cmp	eax, edi
	jne	SHORT $LN4@WRK2003_In

; 1956 : 				KeBugCheckEx(0xDEADBEEFL, 5, 0, 0, 4);

	push	4
	jmp	SHORT $LN15@WRK2003_In
$LN4@WRK2003_In:

; 1957 : }
; 1958 : //////////////////////////////////////////////////////
; 1959 : 
; 1960 : 
; 1961 : //////////////////////////////////////////////////////   
; 1962 : //  LpcRequestWaitReplyPortEx
; 1963 : gTramp_LpcRequestWaitReplyPortEx = (PFN_NTSTATUS_PVOID_PPORT_MESSAGE_PPORT_MESSAGE)MmGetSystemRoutineAddress(&LpcRequestWaitReplyPortExName);

	lea	eax, DWORD PTR _LpcRequestWaitReplyPortExName$[ebp]
	push	eax
	call	esi
	mov	DWORD PTR _gTramp_LpcRequestWaitReplyPortEx, eax

; 1964 : if(gTramp_LpcRequestWaitReplyPortEx == NULL){

	cmp	eax, edi
	jne	SHORT $LN1@WRK2003_In

; 1965 : 	gTramp_LpcRequestWaitReplyPortEx = (PFN_NTSTATUS_PVOID_PPORT_MESSAGE_PPORT_MESSAGE) ModuleHexSearch(MODULE_NTOSKRNL, LpcRequestWaitReplyPortEx_magic1, sizeof(LpcRequestWaitReplyPortEx_magic1), LpcRequestWaitReplyPortEx_magic1mask);

	push	OFFSET _LpcRequestWaitReplyPortEx_magic1mask
	push	35					; 00000023H
	push	OFFSET _LpcRequestWaitReplyPortEx_magic1
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_LpcRequestWaitReplyPortEx, eax

; 1966 : 	if (!gTramp_LpcRequestWaitReplyPortEx)

	cmp	eax, edi
	jne	SHORT $LN1@WRK2003_In

; 1967 : 		gTramp_LpcRequestWaitReplyPortEx = (PFN_NTSTATUS_PVOID_PPORT_MESSAGE_PPORT_MESSAGE) ModuleHexSearch(MODULE_NTOSKRNL, LpcRequestWaitReplyPortEx_magic2, sizeof(LpcRequestWaitReplyPortEx_magic2), LpcRequestWaitReplyPortEx_magic2mask);

	push	DWORD PTR _LpcRequestWaitReplyPortEx_magic2mask
	push	4
	push	DWORD PTR _LpcRequestWaitReplyPortEx_magic2
	push	edi
	call	_ModuleHexSearch@16
	mov	DWORD PTR _gTramp_LpcRequestWaitReplyPortEx, eax

; 1968 : 		if (!gTramp_LpcRequestWaitReplyPortEx)

	cmp	eax, edi
	jne	SHORT $LN1@WRK2003_In

; 1969 : 			KeBugCheckEx(0xDEADBEEFL, 5, 0, 0, 5);

	push	5
	jmp	$LN15@WRK2003_In
$LN1@WRK2003_In:
	pop	edi
	pop	esi

; 1970 : }
; 1971 : //////////////////////////////////////////////////////
; 1972 : 
; 1973 : 
; 1974 : #endif //  < Vista && x32
; 1975 : }

	leave
	ret	0
$LN14@WRK2003_In:
_WRK2003_Init@0 ENDP
_TEXT	ENDS
PUBLIC	_ZwQueryVirtualMemory_k8@24
EXTRN	_NtQueryVirtualMemory_0xB2:PROC
EXTRN	_NtQueryVirtualMemory_0xBA:PROC
EXTRN	__imp__ZwQueryVolumeInformationFile@20:PROC
; Function compile flags: /Ogsp
;	COMDAT _ZwQueryVirtualMemory_k8@24
_TEXT	SEGMENT
_JumpAddr$ = -4						; size = 4
_Handle$ = 8						; size = 4
_Ptr$ = 12						; size = 4
_Class$ = 16						; size = 4
_Ptr2$ = 20						; size = 4
_Size$ = 24						; size = 4
_Size2$ = 28						; size = 4
_ZwQueryVirtualMemory_k8@24 PROC			; COMDAT

; 2013 : {    

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2014 :     PFNNTQUERYVIRTUALMEMORY JumpAddr;
; 2015 : 
; 2016 : #if defined(_X86_)
; 2017 :     uint8_t const *pbCode  = (uint8_t const *)(uintptr_t)ZwQueryVolumeInformationFile;
; 2018 :         
; 2019 :     if (*pbCode == 0xb8) /* mov eax, dword */

	mov	eax, DWORD PTR __imp__ZwQueryVolumeInformationFile@20
	cmp	BYTE PTR [eax], 184			; 000000b8H
	jne	SHORT $LN3@ZwQueryVir

; 2020 :      switch (*(uint32_t const *)&pbCode[1]) {

	mov	eax, DWORD PTR [eax+1]
	sub	eax, 179				; 000000b3H
	je	SHORT $LN2@ZwQueryVir
	sub	eax, 8
	jne	SHORT $LN3@ZwQueryVir

; 2022 :         case 0xbb: JumpAddr= (PFNNTQUERYVIRTUALMEMORY)NtQueryVirtualMemory_0xBA; break; /* W2K3 R2 SP2 */

	mov	DWORD PTR _JumpAddr$[ebp], OFFSET _NtQueryVirtualMemory_0xBA
	jmp	SHORT $LN3@ZwQueryVir
$LN2@ZwQueryVir:

; 2021 :         case 0xb3: JumpAddr= (PFNNTQUERYVIRTUALMEMORY)NtQueryVirtualMemory_0xB2; break; /* XP SP1/2/3 */

	mov	DWORD PTR _JumpAddr$[ebp], OFFSET _NtQueryVirtualMemory_0xB2
$LN3@ZwQueryVir:

; 2023 :      }
; 2024 : #else // x64
; 2025 :      uint8_t const *pbCode = (uint8_t const *)(uintptr_t)ZwRequestWaitReplyPort;
; 2026 :      if (  pbCode[ 0] == 0x48   /* mov rax, rsp */
; 2027 :         && pbCode[ 1] == 0x8b
; 2028 :         && pbCode[ 2] == 0xc4
; 2029 :         && pbCode[ 3] == 0xfa   /* cli */
; 2030 :         && pbCode[ 4] == 0x48   /* sub rsp, 10h */
; 2031 :         && pbCode[ 5] == 0x83
; 2032 :         && pbCode[ 6] == 0xec
; 2033 :         && pbCode[ 7] == 0x10
; 2034 :         && pbCode[ 8] == 0x50   /* push rax */
; 2035 :         && pbCode[ 9] == 0x9c   /* pushfq */
; 2036 :         && pbCode[10] == 0x6a   /* push 10 */
; 2037 :         && pbCode[11] == 0x10
; 2038 :         && pbCode[12] == 0x48   /* lea rax, [nt!KiServiceLinkage] */
; 2039 :         && pbCode[13] == 0x8d
; 2040 :         && pbCode[14] == 0x05
; 2041 :         && pbCode[19] == 0x50   /* push rax */
; 2042 :         && pbCode[20] == 0xb8   /* mov eax,1fh <- the syscall no. */
; 2043 :         /*&& pbCode[21] == 0x1f*/
; 2044 :         && pbCode[22] == 0x00
; 2045 :         && pbCode[23] == 0x00
; 2046 :         && pbCode[24] == 0x00
; 2047 :         && pbCode[25] == 0xe9   /* jmp KiServiceInternal */ )
; 2048 :      {
; 2049 :         uint8_t const *pbKiServiceInternal = &pbCode[30] + *(int32_t const *)&pbCode[26];
; 2050 :         uint8_t const *pbKiServiceLinkage  = &pbCode[19] + *(int32_t const *)&pbCode[15];
; 2051 :         if (*pbKiServiceLinkage == 0xc3)
; 2052 :         {
; 2053 :             g_pfnKiServiceInternal = (PFNRT)pbKiServiceInternal;
; 2054 :             g_pfnKiServiceLinkage  = (PFNRT)pbKiServiceLinkage;
; 2055 :             switch (pbCode[21])
; 2056 :             {
; 2057 :                 case 0x1e: JumpAddr = (PFNNTQUERYVIRTUALMEMORY)NtQueryVirtualMemory_0x1F; break;
; 2058 :                 case 0x1f: JumpAddr = (PFNNTQUERYVIRTUALMEMORY)NtQueryVirtualMemory_0x20; break;
; 2059 :                 //case 0x20: JumpAddr = (PFNNTQUERYVIRTUALMEMORY)NtQueryVirtualMemory_0x21; break;
; 2060 :                 //case 0x21: JumpAddr = (PFNNTQUERYVIRTUALMEMORY)NtQueryVirtualMemory_0x22; break;
; 2061 :                 //case 0x22: JumpAddr = (PFNNTQUERYVIRTUALMEMORY)NtQueryVirtualMemory_0x23; break;
; 2062 :             }
; 2063 :         }
; 2064 :         }
; 2065 : # endif
; 2066 : 
; 2067 :     return JumpAddr(
; 2068 :         Handle,
; 2069 :         Ptr,
; 2070 :         Class,
; 2071 :         Ptr2,
; 2072 :         Size,
; 2073 :         Size2);

	push	DWORD PTR _Size2$[ebp]
	push	DWORD PTR _Size$[ebp]
	push	DWORD PTR _Ptr2$[ebp]
	push	DWORD PTR _Class$[ebp]
	push	DWORD PTR _Ptr$[ebp]
	push	DWORD PTR _Handle$[ebp]
	call	DWORD PTR _JumpAddr$[ebp]

; 2074 : }

	leave
	ret	24					; 00000018H
_ZwQueryVirtualMemory_k8@24 ENDP
_TEXT	ENDS
PUBLIC	_KeInitializeSpinLock_k8@4
; Function compile flags: /Ogsp
;	COMDAT _KeInitializeSpinLock_k8@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock_k8@4 PROC				; COMDAT

; 2081 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2082 :     KeInitializeSpinLock(SpinLock); // wdm.h for x64

	mov	eax, DWORD PTR _SpinLock$[ebp]
	and	DWORD PTR [eax], 0

; 2083 : }

	pop	ebp
	ret	4
_KeInitializeSpinLock_k8@4 ENDP
_TEXT	ENDS
END
