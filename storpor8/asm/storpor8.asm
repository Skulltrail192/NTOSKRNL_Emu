; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04GGLOKIEE@dump?$AA@			; `string'
PUBLIC	KeGetCurrentIrql
PUBLIC	GetAdapter
PUBLIC	gStorPortSynchronizeAccess
PUBLIC	gStorPortSetDeviceQueueDepth
PUBLIC	gStorPortGetVirtualAddress
PUBLIC	gStorPortAllocateRegistryBuffer
PUBLIC	gStorPortWriteRegisterUshort
PUBLIC	gStorPortRegistryRead
PUBLIC	gStorPortReadPortUchar
PUBLIC	gStorPortReadRegisterBufferUchar
PUBLIC	gStorPortReadPortUlong
PUBLIC	gStorPortBusy
PUBLIC	gStorPortGetPhysicalAddress
PUBLIC	gStorPortReadRegisterBufferUshort
PUBLIC	gStorPortPause
PUBLIC	gStorPortGetUncachedExtension
PUBLIC	gStorPortFreeRegistryBuffer
PUBLIC	gStorPortWritePortBufferUlong
PUBLIC	gStorPortWriteRegisterBufferUshort
PUBLIC	gStorPortWritePortUchar
PUBLIC	gStorPortValidateRange
PUBLIC	gStorPortDeviceReady
PUBLIC	gStorPortRegistryWrite
PUBLIC	gStorPortReadPortBufferUchar
PUBLIC	gStorPortQuerySystemTime
PUBLIC	gStorPortGetSrb
PUBLIC	gStorPortReadRegisterUchar
PUBLIC	gStorPortSetBusDataByOffset
PUBLIC	gStorPortReadPortBufferUshort
PUBLIC	gStorPortReadRegisterBufferUlong
PUBLIC	gStorPortReadRegisterUshort
PUBLIC	gStorPortDeviceBusy
PUBLIC	gStorPortResume
PUBLIC	gStorPortCompleteRequest
PUBLIC	gStorPortWritePortBufferUshort
PUBLIC	gStorPortWritePortUlong
PUBLIC	gStorPortWriteRegisterUchar
PUBLIC	gStorPortGetBusData
PUBLIC	gStorPortGetLogicalUnit
PUBLIC	gScsiPortNotification
PUBLIC	gStorPortInitialize
PUBLIC	gStorPortWritePortUshort
PUBLIC	gScsiPortMoveMemory
PUBLIC	gStorPortExtendedFunction
PUBLIC	gStorPortGetScatterGatherList
PUBLIC	gStorPortPauseDevice
PUBLIC	gStorPortGetDeviceBase
PUBLIC	gStorPortLogError
PUBLIC	gStorPortFreeDeviceBase
PUBLIC	gStorPortResumeDevice
PUBLIC	gStorPortDebugPrint
PUBLIC	gStorPortMoveMemory
PUBLIC	gStorPortStallExecution
PUBLIC	gStorPortWritePortBufferUchar
PUBLIC	gStorPortReadPortUshort
PUBLIC	gStorPortWriteRegisterUlong
PUBLIC	gStorPortWriteRegisterBufferUlong
PUBLIC	gStorPortReadRegisterUlong
PUBLIC	gStorPortReady
PUBLIC	gDumpMode
PUBLIC	gStorPortWriteRegisterBufferUchar
PUBLIC	gStorPortReadPortBufferUlong
PUBLIC	gStorPortConvertUlongToPhysicalAddress
PUBLIC	gStorPortNotification
PUBLIC	??_C@_0BC@MKBGMCGD@dump_diskdump?4sys?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@FPIOHHMD@ScsiPortMoveMemory?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@ILLOHBAK@ScsiPortNotification?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BP@PAEBDHOF@StorPortAllocateRegistryBuffer?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0N@BEFCFNJH@StorPortBusy?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@HEHKBONA@StorPortCompleteRequest?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CG@BMCEFJNP@StorPortConvertUlongToPhysicalAd@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@BHHNMCLA@StorPortDebugPrint?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@HHADFJGL@StorPortDeviceBusy?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@KJDCEDBI@StorPortDeviceReady?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@NBKIKGJP@StorPortExtendedFunction?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@MGAINBKN@StorPortFreeDeviceBase?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@DHIABHBB@StorPortFreeRegistryBuffer?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@GCOFJKCK@StorPortGetBusData?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@JNDIICBO@StorPortGetDeviceBase?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@KLCPFFIK@StorPortGetLogicalUnit?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@BINBEEMP@StorPortGetPhysicalAddress?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@MKNFKDMF@StorPortGetScatterGatherList?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@HCFCOKL@StorPortGetSrb?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@HMBNJKCA@StorPortGetUncachedExtension?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@BHMOCJOF@StorPortGetVirtualAddress?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BB@PJCEKPO@StorPortLogError?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@GCMJEEAJ@StorPortInitialize?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@KOLGMFLA@StorPortMoveMemory?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@KKMDHIKH@StorPortNotification?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0O@IFHHIDIA@StorPortPause?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@HDDKBHCK@StorPortPauseDevice?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@KDMOFKKG@StorPortQuerySystemTime?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@HOGMPIOG@StorPortReadPortBufferUchar?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@FNACPGKH@StorPortReadPortBufferUlong?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@OBENOCOP@StorPortReadPortBufferUshort?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@PPONEKFE@StorPortReadPortUchar?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@NMIDEEBF@StorPortReadPortUlong?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@MEKDLBPN@StorPortReadPortUshort?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@IPEIFNOH@StorPortReadRegisterBufferUchar?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@KMCGFDKG@StorPortReadRegisterBufferUlong?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@JGLLPGNM@StorPortReadRegisterBufferUshort@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@PMDMNBFF@StorPortReadRegisterUchar?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@NPFCNPBE@StorPortReadRegisterUlong?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@LDKHFAPA@StorPortReadRegisterUshort?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0O@BNFKKMCL@StorPortReady?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@ICLOLJPJ@StorPortRegistryRead?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@IHPGDKFN@StorPortRegistryWrite?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@FNIBMDLK@StorPortResume?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@KOLPEGFL@StorPortResumeDevice?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@DJHNLPFD@StorPortSetBusDataByOffset?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@KPMDOALK@StorPortSetDeviceQueueDepth?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@OGJLKMMK@StorPortStallExecution?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BK@FMFLKMCG@StorPortSynchronizeAccess?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@JOHPEADN@StorPortValidateRange?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@HOPGPDLM@StorPortWritePortBufferUchar?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BN@FNJIPNPN@StorPortWritePortBufferUlong?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BO@GKPDMAAO@StorPortWritePortBufferUshort?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@ODGHFCAF@StorPortWritePortUchar?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BH@MAAJFMEE@StorPortWritePortUlong?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BI@NINDFKIH@StorPortWritePortUshort?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@KMADDPFA@StorPortWriteRegisterBufferUchar@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CB@IPGNDBBB@StorPortWriteRegisterBufferUlong@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CC@MDJNJLJB@StorPortWriteRegisterBufferUshor@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@EINFGHNE@StorPortWriteRegisterUchar?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BL@GLLLGJJF@StorPortWriteRegisterUlong?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BM@CJKMAKPA@StorPortWriteRegisterUshort?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_strstr:PROC
EXTRN	__imp_RtlUnicodeStringToAnsiString:PROC
EXTRN	__imp_KeDelayExecutionThread:PROC
EXTRN	__imp_RtlInitAnsiString:PROC
EXTRN	__imp_KeInitializeEvent:PROC
EXTRN	__imp_KeWaitForSingleObject:PROC
EXTRN	__imp_IoBuildDeviceIoControlRequest:PROC
EXTRN	__imp_IofCallDriver:PROC
EXTRN	__imp_IoGetAttachedDeviceReference:PROC
EXTRN	__imp_ObfDereferenceObject:PROC
EXTRN	__imp_KeAcquireInterruptSpinLock:PROC
EXTRN	__imp_KeReleaseInterruptSpinLock:PROC
EXTRN	__imp_KeAcquireInStackQueuedSpinLock:PROC
EXTRN	__imp_KeReleaseInStackQueuedSpinLock:PROC
EXTRN	__imp_IoFreeWorkItem:PROC
EXTRN	StorPortInitialize:PROC
EXTRN	StorPortRegistryRead:PROC
EXTRN	__imp_RtlCheckRegistryKey:PROC
EXTRN	__imp_KeInitializeDpc:PROC
EXTRN	__imp_KeRemoveQueueDpc:PROC
EXTRN	__imp_KeFlushQueuedDpcs:PROC
EXTRN	__imp_KeInitializeTimer:PROC
EXTRN	__imp_KeCancelTimer:PROC
EXTRN	__imp_ExAllocatePoolWithTag:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_IoAllocateWorkItem:PROC
EXTRN	__imp_IoQueueWorkItem:PROC
EXTRN	__imp_KeQueryPerformanceCounter:PROC
EXTRN	StorPortExtendedFunction:PROC
gStorPortSynchronizeAccess DQ 01H DUP (?)
gStorPortSetDeviceQueueDepth DQ 01H DUP (?)
gStorPortGetVirtualAddress DQ 01H DUP (?)
gStorPortAllocateRegistryBuffer DQ 01H DUP (?)
gStorPortWriteRegisterUshort DQ 01H DUP (?)
gStorPortRegistryRead DQ 01H DUP (?)
gStorPortReadPortUchar DQ 01H DUP (?)
gStorPortReadRegisterBufferUchar DQ 01H DUP (?)
gStorPortReadPortUlong DQ 01H DUP (?)
gStorPortBusy DQ 01H DUP (?)
gStorPortGetPhysicalAddress DQ 01H DUP (?)
gStorPortReadRegisterBufferUshort DQ 01H DUP (?)
gStorPortPause DQ 01H DUP (?)
gStorPortGetUncachedExtension DQ 01H DUP (?)
gStorPortFreeRegistryBuffer DQ 01H DUP (?)
gStorPortWritePortBufferUlong DQ 01H DUP (?)
gStorPortWriteRegisterBufferUshort DQ 01H DUP (?)
gStorPortWritePortUchar DQ 01H DUP (?)
gStorPortValidateRange DQ 01H DUP (?)
gStorPortDeviceReady DQ 01H DUP (?)
gStorPortRegistryWrite DQ 01H DUP (?)
gStorPortReadPortBufferUchar DQ 01H DUP (?)
gStorPortQuerySystemTime DQ 01H DUP (?)
gStorPortGetSrb DQ 01H DUP (?)
gStorPortReadRegisterUchar DQ 01H DUP (?)
gStorPortSetBusDataByOffset DQ 01H DUP (?)
gStorPortReadPortBufferUshort DQ 01H DUP (?)
gStorPortReadRegisterBufferUlong DQ 01H DUP (?)
gStorPortReadRegisterUshort DQ 01H DUP (?)
gStorPortDeviceBusy DQ 01H DUP (?)
gStorPortResume DQ 01H DUP (?)
gStorPortCompleteRequest DQ 01H DUP (?)
gStorPortWritePortBufferUshort DQ 01H DUP (?)
gStorPortWritePortUlong DQ 01H DUP (?)
gStorPortWriteRegisterUchar DQ 01H DUP (?)
gStorPortGetBusData DQ 01H DUP (?)
gStorPortGetLogicalUnit DQ 01H DUP (?)
gScsiPortNotification DQ 01H DUP (?)
gStorPortInitialize DQ 01H DUP (?)
gStorPortWritePortUshort DQ 01H DUP (?)
gScsiPortMoveMemory DQ 01H DUP (?)
gStorPortExtendedFunction DQ 01H DUP (?)
gStorPortGetScatterGatherList DQ 01H DUP (?)
gStorPortPauseDevice DQ 01H DUP (?)
gStorPortGetDeviceBase DQ 01H DUP (?)
gStorPortLogError DQ 01H DUP (?)
gStorPortFreeDeviceBase DQ 01H DUP (?)
gStorPortResumeDevice DQ 01H DUP (?)
gStorPortDebugPrint DQ 01H DUP (?)
gStorPortMoveMemory DQ 01H DUP (?)
gStorPortStallExecution DQ 01H DUP (?)
gStorPortWritePortBufferUchar DQ 01H DUP (?)
gStorPortReadPortUshort DQ 01H DUP (?)
gStorPortWriteRegisterUlong DQ 01H DUP (?)
gStorPortWriteRegisterBufferUlong DQ 01H DUP (?)
gStorPortReadRegisterUlong DQ 01H DUP (?)
gStorPortReady DQ 01H DUP (?)
gDumpMode DB	01H DUP (?)
	ALIGN	8

gStorPortWriteRegisterBufferUchar DQ 01H DUP (?)
gStorPortReadPortBufferUlong DQ 01H DUP (?)
gStorPortConvertUlongToPhysicalAddress DQ 01H DUP (?)
gStorPortNotification DQ 01H DUP (?)
gIsWeInitialized DB 01H DUP (?)
;	COMDAT ??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@ DB 'M', 00H
	DB	'i', 00H, 'n', 00H, 'i', 00H, 'N', 00H, 'T', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ?STORPORT_DEVICEOPERATION_SECURE_REPROVISION_GUID@?FE@??StorPortExtendedFunction_k8@@9@4U_GUID@@B
CONST	SEGMENT
?STORPORT_DEVICEOPERATION_SECURE_REPROVISION_GUID@?FE@??StorPortExtendedFunction_k8@@9@4U_GUID@@B DD 0dcaf9c10H ; `StorPortExtendedFunction_k8'::`84'::STORPORT_DEVICEOPERATION_SECURE_REPROVISION_GUID
	DW	0895fH
	DW	0481fH
	DB	0a4H
	DB	092H
	DB	0d4H
	DB	0ceH
	DB	0d2H
	DB	0f5H
	DB	056H
	DB	033H
CONST	ENDS
;	COMDAT ??_C@_0BM@CJKMAKPA@StorPortWriteRegisterUshort?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@CJKMAKPA@StorPortWriteRegisterUshort?$AA@FNODOBFM@ DB 'StorPort'
	DB	'WriteRegisterUshort', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@GLLLGJJF@StorPortWriteRegisterUlong?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@GLLLGJJF@StorPortWriteRegisterUlong?$AA@FNODOBFM@ DB 'StorPortW'
	DB	'riteRegisterUlong', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@EINFGHNE@StorPortWriteRegisterUchar?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@EINFGHNE@StorPortWriteRegisterUchar?$AA@FNODOBFM@ DB 'StorPortW'
	DB	'riteRegisterUchar', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CC@MDJNJLJB@StorPortWriteRegisterBufferUshor@FNODOBFM@
text$s	SEGMENT
??_C@_0CC@MDJNJLJB@StorPortWriteRegisterBufferUshor@FNODOBFM@ DB 'StorPor'
	DB	'tWriteRegisterBufferUshort', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@IPGNDBBB@StorPortWriteRegisterBufferUlong@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@IPGNDBBB@StorPortWriteRegisterBufferUlong@FNODOBFM@ DB 'StorPor'
	DB	'tWriteRegisterBufferUlong', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@KMADDPFA@StorPortWriteRegisterBufferUchar@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@KMADDPFA@StorPortWriteRegisterBufferUchar@FNODOBFM@ DB 'StorPor'
	DB	'tWriteRegisterBufferUchar', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@NINDFKIH@StorPortWritePortUshort?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@NINDFKIH@StorPortWritePortUshort?$AA@FNODOBFM@ DB 'StorPortWrit'
	DB	'ePortUshort', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@MAAJFMEE@StorPortWritePortUlong?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@MAAJFMEE@StorPortWritePortUlong?$AA@FNODOBFM@ DB 'StorPortWrite'
	DB	'PortUlong', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@ODGHFCAF@StorPortWritePortUchar?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@ODGHFCAF@StorPortWritePortUchar?$AA@FNODOBFM@ DB 'StorPortWrite'
	DB	'PortUchar', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BO@GKPDMAAO@StorPortWritePortBufferUshort?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BO@GKPDMAAO@StorPortWritePortBufferUshort?$AA@FNODOBFM@ DB 'StorPo'
	DB	'rtWritePortBufferUshort', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@FNJIPNPN@StorPortWritePortBufferUlong?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@FNJIPNPN@StorPortWritePortBufferUlong?$AA@FNODOBFM@ DB 'StorPor'
	DB	'tWritePortBufferUlong', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@HOPGPDLM@StorPortWritePortBufferUchar?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@HOPGPDLM@StorPortWritePortBufferUchar?$AA@FNODOBFM@ DB 'StorPor'
	DB	'tWritePortBufferUchar', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@JOHPEADN@StorPortValidateRange?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@JOHPEADN@StorPortValidateRange?$AA@FNODOBFM@ DB 'StorPortValida'
	DB	'teRange', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@FMFLKMCG@StorPortSynchronizeAccess?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@FMFLKMCG@StorPortSynchronizeAccess?$AA@FNODOBFM@ DB 'StorPortSy'
	DB	'nchronizeAccess', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@OGJLKMMK@StorPortStallExecution?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@OGJLKMMK@StorPortStallExecution?$AA@FNODOBFM@ DB 'StorPortStall'
	DB	'Execution', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@KPMDOALK@StorPortSetDeviceQueueDepth?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@KPMDOALK@StorPortSetDeviceQueueDepth?$AA@FNODOBFM@ DB 'StorPort'
	DB	'SetDeviceQueueDepth', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@DJHNLPFD@StorPortSetBusDataByOffset?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@DJHNLPFD@StorPortSetBusDataByOffset?$AA@FNODOBFM@ DB 'StorPortS'
	DB	'etBusDataByOffset', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@KOLPEGFL@StorPortResumeDevice?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@KOLPEGFL@StorPortResumeDevice?$AA@FNODOBFM@ DB 'StorPortResumeD'
	DB	'evice', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@FNIBMDLK@StorPortResume?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@FNIBMDLK@StorPortResume?$AA@FNODOBFM@ DB 'StorPortResume', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@IHPGDKFN@StorPortRegistryWrite?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@IHPGDKFN@StorPortRegistryWrite?$AA@FNODOBFM@ DB 'StorPortRegist'
	DB	'ryWrite', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@ICLOLJPJ@StorPortRegistryRead?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@ICLOLJPJ@StorPortRegistryRead?$AA@FNODOBFM@ DB 'StorPortRegistr'
	DB	'yRead', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0O@BNFKKMCL@StorPortReady?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0O@BNFKKMCL@StorPortReady?$AA@FNODOBFM@ DB 'StorPortReady', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@LDKHFAPA@StorPortReadRegisterUshort?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@LDKHFAPA@StorPortReadRegisterUshort?$AA@FNODOBFM@ DB 'StorPortR'
	DB	'eadRegisterUshort', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@NPFCNPBE@StorPortReadRegisterUlong?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@NPFCNPBE@StorPortReadRegisterUlong?$AA@FNODOBFM@ DB 'StorPortRe'
	DB	'adRegisterUlong', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@PMDMNBFF@StorPortReadRegisterUchar?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@PMDMNBFF@StorPortReadRegisterUchar?$AA@FNODOBFM@ DB 'StorPortRe'
	DB	'adRegisterUchar', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CB@JGLLPGNM@StorPortReadRegisterBufferUshort@FNODOBFM@
text$s	SEGMENT
??_C@_0CB@JGLLPGNM@StorPortReadRegisterBufferUshort@FNODOBFM@ DB 'StorPor'
	DB	'tReadRegisterBufferUshort', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@KMCGFDKG@StorPortReadRegisterBufferUlong?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@KMCGFDKG@StorPortReadRegisterBufferUlong?$AA@FNODOBFM@ DB 'Stor'
	DB	'PortReadRegisterBufferUlong', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@IPEIFNOH@StorPortReadRegisterBufferUchar?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@IPEIFNOH@StorPortReadRegisterBufferUchar?$AA@FNODOBFM@ DB 'Stor'
	DB	'PortReadRegisterBufferUchar', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@MEKDLBPN@StorPortReadPortUshort?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@MEKDLBPN@StorPortReadPortUshort?$AA@FNODOBFM@ DB 'StorPortReadP'
	DB	'ortUshort', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@NMIDEEBF@StorPortReadPortUlong?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@NMIDEEBF@StorPortReadPortUlong?$AA@FNODOBFM@ DB 'StorPortReadPo'
	DB	'rtUlong', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@PPONEKFE@StorPortReadPortUchar?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@PPONEKFE@StorPortReadPortUchar?$AA@FNODOBFM@ DB 'StorPortReadPo'
	DB	'rtUchar', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@OBENOCOP@StorPortReadPortBufferUshort?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@OBENOCOP@StorPortReadPortBufferUshort?$AA@FNODOBFM@ DB 'StorPor'
	DB	'tReadPortBufferUshort', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@FNACPGKH@StorPortReadPortBufferUlong?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@FNACPGKH@StorPortReadPortBufferUlong?$AA@FNODOBFM@ DB 'StorPort'
	DB	'ReadPortBufferUlong', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BM@HOGMPIOG@StorPortReadPortBufferUchar?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BM@HOGMPIOG@StorPortReadPortBufferUchar?$AA@FNODOBFM@ DB 'StorPort'
	DB	'ReadPortBufferUchar', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@KDMOFKKG@StorPortQuerySystemTime?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@KDMOFKKG@StorPortQuerySystemTime?$AA@FNODOBFM@ DB 'StorPortQuer'
	DB	'ySystemTime', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@HDDKBHCK@StorPortPauseDevice?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@HDDKBHCK@StorPortPauseDevice?$AA@FNODOBFM@ DB 'StorPortPauseDev'
	DB	'ice', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0O@IFHHIDIA@StorPortPause?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0O@IFHHIDIA@StorPortPause?$AA@FNODOBFM@ DB 'StorPortPause', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@KKMDHIKH@StorPortNotification?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@KKMDHIKH@StorPortNotification?$AA@FNODOBFM@ DB 'StorPortNotific'
	DB	'ation', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@KOLGMFLA@StorPortMoveMemory?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@KOLGMFLA@StorPortMoveMemory?$AA@FNODOBFM@ DB 'StorPortMoveMemor'
	DB	'y', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@GCMJEEAJ@StorPortInitialize?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@GCMJEEAJ@StorPortInitialize?$AA@FNODOBFM@ DB 'StorPortInitializ'
	DB	'e', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BB@PJCEKPO@StorPortLogError?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BB@PJCEKPO@StorPortLogError?$AA@FNODOBFM@ DB 'StorPortLogError', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BK@BHMOCJOF@StorPortGetVirtualAddress?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BK@BHMOCJOF@StorPortGetVirtualAddress?$AA@FNODOBFM@ DB 'StorPortGe'
	DB	'tVirtualAddress', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@HMBNJKCA@StorPortGetUncachedExtension?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@HMBNJKCA@StorPortGetUncachedExtension?$AA@FNODOBFM@ DB 'StorPor'
	DB	'tGetUncachedExtension', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@HCFCOKL@StorPortGetSrb?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@HCFCOKL@StorPortGetSrb?$AA@FNODOBFM@ DB 'StorPortGetSrb', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BN@MKNFKDMF@StorPortGetScatterGatherList?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BN@MKNFKDMF@StorPortGetScatterGatherList?$AA@FNODOBFM@ DB 'StorPor'
	DB	'tGetScatterGatherList', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@BINBEEMP@StorPortGetPhysicalAddress?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@BINBEEMP@StorPortGetPhysicalAddress?$AA@FNODOBFM@ DB 'StorPortG'
	DB	'etPhysicalAddress', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@KLCPFFIK@StorPortGetLogicalUnit?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@KLCPFFIK@StorPortGetLogicalUnit?$AA@FNODOBFM@ DB 'StorPortGetLo'
	DB	'gicalUnit', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@JNDIICBO@StorPortGetDeviceBase?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@JNDIICBO@StorPortGetDeviceBase?$AA@FNODOBFM@ DB 'StorPortGetDev'
	DB	'iceBase', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@GCOFJKCK@StorPortGetBusData?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@GCOFJKCK@StorPortGetBusData?$AA@FNODOBFM@ DB 'StorPortGetBusDat'
	DB	'a', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BL@DHIABHBB@StorPortFreeRegistryBuffer?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BL@DHIABHBB@StorPortFreeRegistryBuffer?$AA@FNODOBFM@ DB 'StorPortF'
	DB	'reeRegistryBuffer', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BH@MGAINBKN@StorPortFreeDeviceBase?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BH@MGAINBKN@StorPortFreeDeviceBase?$AA@FNODOBFM@ DB 'StorPortFreeD'
	DB	'eviceBase', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@NBKIKGJP@StorPortExtendedFunction?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@NBKIKGJP@StorPortExtendedFunction?$AA@FNODOBFM@ DB 'StorPortExt'
	DB	'endedFunction', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@KJDCEDBI@StorPortDeviceReady?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@KJDCEDBI@StorPortDeviceReady?$AA@FNODOBFM@ DB 'StorPortDeviceRe'
	DB	'ady', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@HHADFJGL@StorPortDeviceBusy?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@HHADFJGL@StorPortDeviceBusy?$AA@FNODOBFM@ DB 'StorPortDeviceBus'
	DB	'y', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@BHHNMCLA@StorPortDebugPrint?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@BHHNMCLA@StorPortDebugPrint?$AA@FNODOBFM@ DB 'StorPortDebugPrin'
	DB	't', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CG@BMCEFJNP@StorPortConvertUlongToPhysicalAd@FNODOBFM@
text$s	SEGMENT
??_C@_0CG@BMCEFJNP@StorPortConvertUlongToPhysicalAd@FNODOBFM@ DB 'StorPor'
	DB	'tConvertUlongToPhysicalAddress', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BI@HEHKBONA@StorPortCompleteRequest?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BI@HEHKBONA@StorPortCompleteRequest?$AA@FNODOBFM@ DB 'StorPortComp'
	DB	'leteRequest', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@BEFCFNJH@StorPortBusy?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@BEFCFNJH@StorPortBusy?$AA@FNODOBFM@ DB 'StorPortBusy', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BP@PAEBDHOF@StorPortAllocateRegistryBuffer?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BP@PAEBDHOF@StorPortAllocateRegistryBuffer?$AA@FNODOBFM@ DB 'StorP'
	DB	'ortAllocateRegistryBuffer', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@ILLOHBAK@ScsiPortNotification?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@ILLOHBAK@ScsiPortNotification?$AA@FNODOBFM@ DB 'ScsiPortNotific'
	DB	'ation', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@FPIOHHMD@ScsiPortMoveMemory?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@FPIOHHMD@ScsiPortMoveMemory?$AA@FNODOBFM@ DB 'ScsiPortMoveMemor'
	DB	'y', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BC@MKBGMCGD@dump_diskdump?4sys?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BC@MKBGMCGD@dump_diskdump?4sys?$AA@FNODOBFM@ DB 'dump_diskdump.sys'
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_04GGLOKIEE@dump?$AA@
CONST	SEGMENT
??_C@_04GGLOKIEE@dump?$AA@ DB 'dump', 00H		; `string'
DUMPPREFIX DQ	FLAT:??_C@_04GGLOKIEE@dump?$AA@
	ORG $+5
gPattern DB	'InTheHeatOfTheNightILooseControl', 00H
PUBLIC	DllUnload
; Function compile flags: /Ogspy
; File d:\develop\mods\ntoskrnl_emu\storpor8.c
;	COMDAT DllUnload
_TEXT	SEGMENT
DllUnload PROC						; COMDAT

; 2038 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2039 : }

	ret	0
DllUnload ENDP
_TEXT	ENDS
PUBLIC	DriverEntry
; Function compile flags: /Ogspy
;	COMDAT DriverEntry
_TEXT	SEGMENT
DriverObject$ = 8
RegistryPath$ = 16
DriverEntry PROC					; COMDAT

; 2014 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2015 : }

	ret	0
DriverEntry ENDP
_TEXT	ENDS
PUBLIC	isPatternMatch
; Function compile flags: /Ogspy
;	COMDAT isPatternMatch
_TEXT	SEGMENT
Buffer$ = 8
BufferLength$ = 16
isPatternMatch PROC					; COMDAT

; 1452 :     ULONG Rotor = 0;

	xor	r8d, r8d

; 1453 : 
; 1454 :     for (ULONG Index = 0; Index < BufferLength; Index ++) {

	xor	r9d, r9d
	xor	r10d, r10d
	mov	r11, rcx
	test	edx, edx
	je	SHORT $LN3@isPatternM
$LL5@isPatternM:

; 1455 :         if (Buffer[Index] != (gPattern[Rotor] XOR (UCHAR)(0xA1 - Index)))

	mov	eax, 161				; 000000a1H
	lea	rcx, OFFSET FLAT:gPattern
	mov	cl, BYTE PTR [r10+rcx]
	sub	al, r9b
	xor	cl, al
	mov	eax, r9d
	cmp	BYTE PTR [r9+r11], cl
	jne	SHORT $LN9@isPatternM

; 1457 : 
; 1458 :         Rotor ++;

	inc	r8d
	inc	r10

; 1459 :         if (Rotor == PATTERN_SIZE) {

	cmp	r8d, 32					; 00000020H
	jne	SHORT $LN4@isPatternM

; 1460 :             Rotor = 0;

	xor	r8d, r8d
	xor	r10d, r10d
$LN4@isPatternM:
	inc	r9d
	cmp	r9d, edx
	jb	SHORT $LL5@isPatternM
$LN3@isPatternM:

; 1461 :         }    
; 1462 :     }
; 1463 : 
; 1464 :     return TRUE;

	mov	al, 1

; 1465 : }

	ret	0
$LN9@isPatternM:

; 1456 :             return FALSE;

	xor	al, al

; 1465 : }

	ret	0
isPatternMatch ENDP
_TEXT	ENDS
PUBLIC	FillBufferWithPattern
; Function compile flags: /Ogspy
;	COMDAT FillBufferWithPattern
_TEXT	SEGMENT
Buffer$ = 8
BufferLength$ = 16
FillBufferWithPattern PROC				; COMDAT

; 1437 :     ULONG Rotor = 0;

	xor	r10d, r10d

; 1438 : 
; 1439 :     for (ULONG Index = 0; Index < BufferLength; Index ++) {

	xor	r8d, r8d
	xor	r11d, r11d
	mov	r9, rcx
	test	edx, edx
	je	SHORT $LN2@FillBuffer
$LL4@FillBuffer:

; 1440 :         Buffer[Index] = gPattern[Rotor] XOR (UCHAR)(0xA1 - Index);

	lea	rax, OFFSET FLAT:gPattern
	mov	ecx, 161				; 000000a1H

; 1441 :         Rotor ++;

	inc	r10d
	mov	al, BYTE PTR [r11+rax]
	sub	cl, r8b
	inc	r11
	xor	al, cl
	mov	BYTE PTR [r9], al

; 1442 :         if (Rotor == PATTERN_SIZE) {

	cmp	r10d, 32				; 00000020H
	jne	SHORT $LN3@FillBuffer

; 1443 :             Rotor = 0;

	xor	r10d, r10d
	xor	r11d, r11d
$LN3@FillBuffer:
	inc	r8d
	inc	r9
	cmp	r8d, edx
	jb	SHORT $LL4@FillBuffer
$LN2@FillBuffer:

; 1444 :         }
; 1445 :     }
; 1446 : }

	fatret	0
FillBufferWithPattern ENDP
_TEXT	ENDS
PUBLIC	StorpFreeTimerWorkItemCallback
;	COMDAT pdata
pdata	SEGMENT
$pdata$StorpFreeTimerWorkItemCallback DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$StorpFreeTimerWorkItemCallback
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorpFreeTimerWorkItemCallback DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT StorpFreeTimerWorkItemCallback
_TEXT	SEGMENT
DeviceObject$ = 48
Timer$ = 56
StorpFreeTimerWorkItemCallback PROC			; COMDAT

; 1412 : {

$LN3:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 1413 :   KeFlushQueuedDpcs();

	call	QWORD PTR __imp_KeFlushQueuedDpcs

; 1414 :   IoFreeWorkItem(Timer->FreeTimerWorkItem);

	mov	rcx, QWORD PTR [rbx+152]
	call	QWORD PTR __imp_IoFreeWorkItem

; 1415 :   ExFreePoolWithTag(Timer, 'TAaR');

	mov	edx, 1413570898				; 54416152H
	mov	rcx, rbx

; 1416 :   //InterlockedDecrement(&gAllocatedTimers);
; 1417 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR __imp_ExFreePoolWithTag
StorpFreeTimerWorkItemCallback ENDP
_TEXT	ENDS
PUBLIC	StorFindDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$StorFindDictionary DD imagerel $LN15
	DD	imagerel $LN15+167
	DD	imagerel $unwind$StorFindDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorFindDictionary DD 0c1d01H
	DD	0b741dH
	DD	0a641dH
	DD	09541dH
	DD	08341dH
	DD	0e019321dH
	DD	0c015d017H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT StorFindDictionary
_TEXT	SEGMENT
UnitDictionary$ = 64
AddressToLong$ = 72
ResultPtr$ = 80
StorFindDictionary PROC					; COMDAT

; 1276 : {

$LN15:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 32					; 00000020H

; 1277 :     void * ( *GetKeyRoutine)     (struct _LIST_ENTRY *);
; 1278 :     long   ( *CompareKeyRoutine) (void *, void *);
; 1279 :     ULONG  ( *HashKeyRoutine)    (void *);
; 1280 : 
; 1281 :     LIST_ENTRY  *Entries;
; 1282 :     LIST_ENTRY  *ListHead;
; 1283 :     NTSTATUS     status;
; 1284 : 
; 1285 :     Entries             = UnitDictionary->Entries;
; 1286 :     GetKeyRoutine       = UnitDictionary->GetKeyRoutine;
; 1287 :     CompareKeyRoutine   = UnitDictionary->CompareKeyRoutine;
; 1288 :     HashKeyRoutine      = UnitDictionary->HashKeyRoutine;

	mov	rax, QWORD PTR [rcx+40]
	mov	rdi, QWORD PTR [rcx+16]
	mov	r13, QWORD PTR [rcx+24]
	mov	r14, QWORD PTR [rcx+32]
	mov	rbx, rcx

; 1289 :     
; 1290 :     ListHead = (LIST_ENTRY  *) ((UCHAR *)Entries +
; 1291 :                  sizeof(LIST_ENTRY) *
; 1292 :                  (HashKeyRoutine((void *)AddressToLong) % UnitDictionary->MaxEntryCount));

	mov	rcx, rdx
	mov	rsi, r8
	mov	r12, rdx
	call	rax
	xor	edx, edx
	div	DWORD PTR [rbx+4]
	mov	ebp, edx
	shl	rbp, 4
	add	rbp, rdi

; 1293 : 
; 1294 :     for (LIST_ENTRY* List = ListHead->Flink; List != ListHead; List = List->Flink)

	mov	rbx, QWORD PTR [rbp]
	jmp	SHORT $LN14@StorFindDi
$LL7@StorFindDi:

; 1295 :     {
; 1296 :         
; 1297 :         status = CompareKeyRoutine(GetKeyRoutine(List), (void *)AddressToLong);

	mov	rcx, rbx
	call	r13
	mov	rdx, r12
	mov	rcx, rax
	call	r14

; 1298 :         if (!status)

	test	eax, eax
	je	SHORT $LN11@StorFindDi

; 1303 :         }
; 1304 :         if (status < 0)

	js	SHORT $LN12@StorFindDi

; 1293 : 
; 1294 :     for (LIST_ENTRY* List = ListHead->Flink; List != ListHead; List = List->Flink)

	mov	rbx, QWORD PTR [rbx]
$LN14@StorFindDi:
	cmp	rbx, rbp
	jne	SHORT $LL7@StorFindDi
$LN5@StorFindDi:

; 1309 :         }
; 1310 :     }
; 1311 : 
; 1312 :     return STATUS_NOT_FOUND;

	mov	eax, -1073741275			; ffffffffc0000225H
$LN8@StorFindDi:

; 1313 : }    

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	ret	0
$LN12@StorFindDi:

; 1305 :         {
; 1306 :             if (ResultPtr)

	test	rsi, rsi
	je	SHORT $LN5@StorFindDi

; 1307 :                 *ResultPtr = 0;

	and	QWORD PTR [rsi], 0

; 1308 :             return STATUS_NOT_FOUND;

	jmp	SHORT $LN5@StorFindDi
$LN11@StorFindDi:

; 1299 :         {
; 1300 :             if (ResultPtr)

	test	rsi, rsi
	je	SHORT $LN3@StorFindDi

; 1301 :                 *ResultPtr = List;

	mov	QWORD PTR [rsi], rbx
$LN3@StorFindDi:

; 1302 :             return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN8@StorFindDi
StorFindDictionary ENDP
_TEXT	ENDS
PUBLIC	RaidAdapterReleaseInterruptLock
;	COMDAT pdata
pdata	SEGMENT
$pdata$RaidAdapterReleaseInterruptLock DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$RaidAdapterReleaseInterruptLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RaidAdapterReleaseInterruptLock DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RaidAdapterReleaseInterruptLock
_TEXT	SEGMENT
Adapter$ = 48
OldIrq$ = 56
RaidAdapterReleaseInterruptLock PROC			; COMDAT

; 1239 : {

$LN4:
	sub	rsp, 40					; 00000028H

; 1240 :     if (Adapter->Interrupt)

	mov	rcx, QWORD PTR [rcx+592]
	test	rcx, rcx
	je	SHORT $LN1@RaidAdapte

; 1241 :         KeReleaseInterruptSpinLock(Adapter->Interrupt, OldIrq);

	call	QWORD PTR __imp_KeReleaseInterruptSpinLock
$LN1@RaidAdapte:

; 1242 : }

	add	rsp, 40					; 00000028H
	ret	0
RaidAdapterReleaseInterruptLock ENDP
_TEXT	ENDS
PUBLIC	RaidAdapterAcquireInterruptLock
;	COMDAT pdata
pdata	SEGMENT
$pdata$RaidAdapterAcquireInterruptLock DD imagerel $LN5
	DD	imagerel $LN5+31
	DD	imagerel $unwind$RaidAdapterAcquireInterruptLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RaidAdapterAcquireInterruptLock DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RaidAdapterAcquireInterruptLock
_TEXT	SEGMENT
Adapter$ = 48
RaidAdapterAcquireInterruptLock PROC			; COMDAT

; 1227 : {

$LN5:
	sub	rsp, 40					; 00000028H

; 1228 :     if (Adapter->Interrupt)

	mov	rcx, QWORD PTR [rcx+592]
	test	rcx, rcx
	je	SHORT $LN2@RaidAdapte@2

; 1229 :         return KeAcquireInterruptSpinLock(Adapter->Interrupt);

	call	QWORD PTR __imp_KeAcquireInterruptSpinLock
	jmp	SHORT $LN1@RaidAdapte@2
$LN2@RaidAdapte@2:

; 1230 :     else
; 1231 :         return PASSIVE_LEVEL;

	xor	al, al
$LN1@RaidAdapte@2:

; 1232 : }

	add	rsp, 40					; 00000028H
	ret	0
RaidAdapterAcquireInterruptLock ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT GetAdapter
_TEXT	SEGMENT
HwDeviceExtension$ = 8
GetAdapter PROC						; COMDAT

; 1146 :        return ( CONTAINING_RECORD(
; 1147 :                   HwDeviceExtension,
; 1148 :                   RAID_HW_DEVICE_EXT,                        
; 1149 :                   HwDeviceExtension) )->Miniport->Adapter;

	mov	rax, QWORD PTR [rcx-8]
	mov	rax, QWORD PTR [rax]

; 1150 : }

	ret	0
GetAdapter ENDP
_TEXT	ENDS
PUBLIC	NtStatusToStorStatus
; Function compile flags: /Ogspy
;	COMDAT NtStatusToStorStatus
_TEXT	SEGMENT
NTStatus$ = 8
NtStatusToStorStatus PROC				; COMDAT

; 1127 :     if (NTStatus == STATUS_INVALID_LEVEL)

	cmp	ecx, -1073741496			; ffffffffc0000148H
	jne	SHORT $LN5@NtStatusTo

; 1128 :         return STOR_STATUS_INVALID_IRQL;

	mov	eax, -1056964600			; ffffffffc1000008H

; 1136 :         return STOR_STATUS_SUCCESS;
; 1137 : 
; 1138 :     return STOR_STATUS_UNSUCCESSFUL; // default
; 1139 : }

	ret	0
$LN5@NtStatusTo:

; 1129 :     if (NTStatus == STATUS_INSUFFICIENT_RESOURCES)

	cmp	ecx, -1073741670			; ffffffffc000009aH
	jne	SHORT $LN4@NtStatusTo

; 1130 :         return STOR_STATUS_INSUFFICIENT_RESOURCES;

	mov	eax, -1056964605			; ffffffffc1000003H

; 1136 :         return STOR_STATUS_SUCCESS;
; 1137 : 
; 1138 :     return STOR_STATUS_UNSUCCESSFUL; // default
; 1139 : }

	ret	0
$LN4@NtStatusTo:

; 1131 :     if (NTStatus == STATUS_BUFFER_OVERFLOW)

	cmp	ecx, -2147483643			; ffffffff80000005H
	jne	SHORT $LN3@NtStatusTo

; 1132 :         return STOR_STATUS_BUFFER_TOO_SMALL;

	mov	eax, -1056964604			; ffffffffc1000004H

; 1136 :         return STOR_STATUS_SUCCESS;
; 1137 : 
; 1138 :     return STOR_STATUS_UNSUCCESSFUL; // default
; 1139 : }

	ret	0
$LN3@NtStatusTo:

; 1133 :     if (NTStatus == STATUS_INVALID_PARAMETER)

	cmp	ecx, -1073741811			; ffffffffc000000dH
	jne	SHORT $LN2@NtStatusTo

; 1134 :         return STOR_STATUS_INVALID_PARAMETER;

	mov	eax, -1056964602			; ffffffffc1000006H

; 1136 :         return STOR_STATUS_SUCCESS;
; 1137 : 
; 1138 :     return STOR_STATUS_UNSUCCESSFUL; // default
; 1139 : }

	ret	0
$LN2@NtStatusTo:

; 1135 :     if (NTStatus >= STATUS_SUCCESS)

	xor	edx, edx
	mov	eax, -1056964607			; ffffffffc1000001H
	cmp	ecx, edx
	cmovge	eax, edx

; 1136 :         return STOR_STATUS_SUCCESS;
; 1137 : 
; 1138 :     return STOR_STATUS_UNSUCCESSFUL; // default
; 1139 : }

	ret	0
NtStatusToStorStatus ENDP
_TEXT	ENDS
PUBLIC	isDumpMode
;	COMDAT pdata
pdata	SEGMENT
$pdata$isDumpMode DD imagerel $LN22
	DD	imagerel $LN22+127
	DD	imagerel $unwind$isDumpMode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isDumpMode DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT isDumpMode
_TEXT	SEGMENT
AnsiString$ = 32
RegistryPath$ = 64
isDumpMode PROC						; COMDAT

; 998  : {

$LN22:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 999  :     ANSI_STRING AnsiString;
; 1000 :     PCHAR       s;
; 1001 :     NTSTATUS    Status;
; 1002 : 
; 1003 :     if (RegistryPath == NULL)

	test	rcx, rcx
	jne	SHORT $LN14@isDumpMode

; 1004 :         return TRUE;

	mov	al, 1
	jmp	SHORT $LN2@isDumpMode
$LN14@isDumpMode:

; 1005 : 
; 1006 :     do {
; 1007 :         Status = RtlUnicodeStringToAnsiString(&AnsiString, RegistryPath, TRUE);

	mov	rdx, rcx
	jmp	SHORT $LN20@isDumpMode
$LL9@isDumpMode:

; 1008 : 
; 1009 :         if (NT_SUCCESS (Status)) {
; 1010 :             break;
; 1011 :         }
; 1012 : 
; 1013 :         KeDelayExecutionThread (KernelMode, FALSE, (PLARGE_INTEGER)&MmShortTime);

	lea	r8, OFFSET FLAT:MmShortTime
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_KeDelayExecutionThread
	mov	rdx, rbx
$LN20@isDumpMode:
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	r8b, 1
	call	QWORD PTR __imp_RtlUnicodeStringToAnsiString
	test	eax, eax
	js	SHORT $LL9@isDumpMode

; 1014 : 
; 1015 :     } while (TRUE);
; 1016 : 
; 1017 :     s = AnsiString.Buffer + AnsiString.Length;

	movzx	ebx, WORD PTR AnsiString$[rsp]
	mov	rax, QWORD PTR AnsiString$[rsp+8]
	add	rbx, rax
	jmp	SHORT $LN21@isDumpMode
$LL5@isDumpMode:

; 1018 :     while (s > AnsiString.Buffer && *--s)

	dec	rbx
	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN4@isDumpMode

; 1019 :     {
; 1020 :         if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR)

	cmp	BYTE PTR [rbx], 92			; 0000005cH
	je	SHORT $LN17@isDumpMode
$LN21@isDumpMode:

; 1018 :     while (s > AnsiString.Buffer && *--s)

	cmp	rbx, rax
	ja	SHORT $LL5@isDumpMode

; 1019 :     {
; 1020 :         if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR)

	jmp	SHORT $LN4@isDumpMode
$LN17@isDumpMode:

; 1021 :         {
; 1022 :             s += 1;

	inc	rbx
$LN4@isDumpMode:

; 1023 :             break;
; 1024 :         }
; 1025 :     }
; 1026 : 
; 1027 :     if (strstr(s, DUMPPREFIX) == s)

	lea	rdx, OFFSET FLAT:??_C@_04GGLOKIEE@dump?$AA@
	mov	rcx, rbx
	call	QWORD PTR __imp_strstr
	cmp	rax, rbx
	sete	al
$LN2@isDumpMode:

; 1028 :         return TRUE;
; 1029 :     else
; 1030 :         return FALSE;
; 1031 :     
; 1032 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
isDumpMode ENDP
; Function compile flags: /Ogspy
; File d:\develop\ddk\winddk\7600.16385.1\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT KeGetCurrentIrql
_TEXT	SEGMENT
KeGetCurrentIrql PROC					; COMDAT

; 13365: 
; 13366:     return (KIRQL)ReadCR8();

	mov	rax, cr8

; 13367: }

	ret	0
KeGetCurrentIrql ENDP
PUBLIC	StorPortRegistryRead_k8
;	COMDAT pdata
; File d:\develop\mods\ntoskrnl_emu\storpor8.c
pdata	SEGMENT
$pdata$StorPortRegistryRead_k8 DD imagerel $LN24
	DD	imagerel $LN24+284
	DD	imagerel $unwind$StorPortRegistryRead_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorPortRegistryRead_k8 DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT StorPortRegistryRead_k8
_TEXT	SEGMENT
HwDeviceExtension$ = 80
ValueName$ = 88
Global$ = 96
Type$ = 104
Buffer$ = 112
BufferLength$ = 120
StorPortRegistryRead_k8 PROC				; COMDAT

; 1521 : {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 48					; 00000030H

; 1522 :     BOOLEAN status;
; 1523 :     ULONG OldBufferLength;
; 1524 : 
; 1525 :     if (gDumpMode)           // passthrough

	cmp	BYTE PTR gDumpMode, 0
	mov	r10, rdx
	mov	r11, rcx
	je	SHORT $LN3@StorPortRe

; 1526 :         return gStorPortRegistryRead(
; 1527 :                         HwDeviceExtension,
; 1528 :                         ValueName,
; 1529 :                         Global,
; 1530 :                         Type,
; 1531 :                         Buffer,
; 1532 :                         BufferLength );

	mov	rax, QWORD PTR BufferLength$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR Buffer$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR gStorPortRegistryRead
	jmp	$LN4@StorPortRe
$LN3@StorPortRe:

; 1533 : 
; 1534 : 
; 1535 :     OldBufferLength = *BufferLength;

	mov	rbx, QWORD PTR BufferLength$[rsp]

; 1536 :     FillBufferWithPattern(Buffer, *BufferLength);

	mov	r13, QWORD PTR Buffer$[rsp]
	xor	ebp, ebp
	mov	edi, DWORD PTR [rbx]
	xor	edx, edx
	xor	r12d, r12d
	lea	rsi, OFFSET FLAT:gPattern
	test	edi, edi
	je	SHORT $LN7@StorPortRe
	mov	rsi, r13
	lea	rbx, OFFSET FLAT:gPattern
$LL9@StorPortRe:
	mov	al, BYTE PTR [r12+rbx]
	mov	ecx, 161				; 000000a1H
	inc	ebp
	sub	cl, dl
	inc	r12
	xor	al, cl
	mov	BYTE PTR [rsi], al
	cmp	ebp, 32					; 00000020H
	jne	SHORT $LN8@StorPortRe
	xor	ebp, ebp
	xor	r12d, r12d
$LN8@StorPortRe:
	inc	edx
	inc	rsi
	cmp	edx, edi
	jb	SHORT $LL9@StorPortRe
	mov	rbx, QWORD PTR BufferLength$[rsp]
	lea	rsi, OFFSET FLAT:gPattern
$LN7@StorPortRe:

; 1537 :     status = StorPortRegistryRead (
; 1538 :                         HwDeviceExtension,
; 1539 :                         ValueName,
; 1540 :                         Global,
; 1541 :                         Type,
; 1542 :                         Buffer,
; 1543 :                         BufferLength );

	mov	rdx, r10
	mov	rcx, r11
	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+32], r13
	call	StorPortRegistryRead
	mov	r11b, al

; 1544 : 
; 1545 :     if (status == TRUE) {

	cmp	al, 1
	jne	SHORT $LN1@StorPortRe

; 1546 :          // Detect bug:
; 1547 :          //  Len    not changed AND
; 1548 :          //  Buffer not changed
; 1549 :         if (*BufferLength == OldBufferLength && isPatternMatch(Buffer, *BufferLength)) {

	cmp	DWORD PTR [rbx], edi
	jne	SHORT $LN1@StorPortRe
	xor	edx, edx
	xor	r8d, r8d
	xor	r9d, r9d
	cmp	DWORD PTR [rbx], edx
	jbe	SHORT $LN14@StorPortRe
$LL16@StorPortRe:
	mov	cl, BYTE PTR [r9+rsi]
	mov	eax, 161				; 000000a1H
	sub	al, dl
	xor	cl, al
	mov	eax, edx
	cmp	BYTE PTR [rdx+r13], cl
	jne	SHORT $LN1@StorPortRe
	inc	r8d
	inc	r9
	cmp	r8d, 32					; 00000020H
	jne	SHORT $LN15@StorPortRe
	xor	r8d, r8d
	xor	r9d, r9d
$LN15@StorPortRe:
	inc	edx
	cmp	edx, DWORD PTR [rbx]
	jb	SHORT $LL16@StorPortRe
$LN14@StorPortRe:

; 1550 :                 status        = FALSE;

	xor	r11b, r11b

; 1551 :                 *BufferLength = 0;

	and	DWORD PTR [rbx], 0
$LN1@StorPortRe:

; 1552 :         }
; 1553 :     }
; 1554 : 
; 1555 :     return status;

	mov	al, r11b
$LN4@StorPortRe:

; 1556 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r13
	pop	r12
	pop	rdi
	ret	0
StorPortRegistryRead_k8 ENDP
_TEXT	ENDS
PUBLIC	RaidAdapterFindUnitAtDirql
;	COMDAT pdata
pdata	SEGMENT
$pdata$RaidAdapterFindUnitAtDirql DD imagerel $LN22
	DD	imagerel $LN22+174
	DD	imagerel $unwind$RaidAdapterFindUnitAtDirql
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RaidAdapterFindUnitAtDirql DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0c0153219H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RaidAdapterFindUnitAtDirql
_TEXT	SEGMENT
Adapter$ = 48
Address$ = 56
RaidAdapterFindUnitAtDirql PROC				; COMDAT

; 1320 : {

$LN22:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r12
	sub	rsp, 32					; 00000020H

; 1321 :     PVOID   UnitAsList;
; 1322 :     ULONG   AddressToLong;
; 1323 : 
; 1324 :     AddressToLong = Address.PathId << 16 | Address.TargetId << 8 | Address.Lun ;
; 1325 :     if (StorFindDictionary(&Adapter->UnitDictionary, AddressToLong, &UnitAsList) < 0)

	mov	rbx, QWORD PTR [rcx+160]
	mov	rbp, QWORD PTR [rcx+168]
	mov	r12, QWORD PTR [rcx+176]
	mov	eax, edx
	mov	rdi, rcx
	shr	eax, 8
	movzx	esi, al
	movzx	eax, dl
	shr	edx, 16
	shl	eax, 8
	or	esi, eax
	movzx	eax, dl
	shl	esi, 8
	or	rsi, rax
	mov	rax, QWORD PTR [rcx+184]
	mov	rcx, rsi
	call	rax
	xor	edx, edx
	div	DWORD PTR [rdi+148]
	mov	edi, edx
	shl	rdi, 4
	add	rdi, rbx
	mov	rbx, QWORD PTR [rdi]
	jmp	SHORT $LN21@RaidAdapte@3
$LL11@RaidAdapte@3:
	mov	rcx, rbx
	call	rbp
	mov	rdx, rsi
	mov	rcx, rax
	call	r12
	test	eax, eax
	je	SHORT $LN2@RaidAdapte@3
	js	SHORT $LN19@RaidAdapte@3
	mov	rbx, QWORD PTR [rbx]
$LN21@RaidAdapte@3:
	cmp	rbx, rdi
	jne	SHORT $LL11@RaidAdapte@3
$LN19@RaidAdapte@3:

; 1326 :         return NULL;

	xor	eax, eax
$LN1@RaidAdapte@3:

; 1332 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r12
	ret	0
$LN2@RaidAdapte@3:

; 1327 :     else
; 1328 :         return CONTAINING_RECORD(
; 1329 :                   UnitAsList,
; 1330 :                   RAID_UNIT_EXTENSION,                        
; 1331 :                   UnitTableLink);

	lea	rax, QWORD PTR [rbx-56]
	jmp	SHORT $LN1@RaidAdapte@3
RaidAdapterFindUnitAtDirql ENDP
_TEXT	ENDS
PUBLIC	RaidAdapterReleaseStartIoLock
;	COMDAT pdata
pdata	SEGMENT
$pdata$RaidAdapterReleaseStartIoLock DD imagerel $LN11
	DD	imagerel $LN11+29
	DD	imagerel $unwind$RaidAdapterReleaseStartIoLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RaidAdapterReleaseStartIoLock DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RaidAdapterReleaseStartIoLock
_TEXT	SEGMENT
Adapter$ = 48
LockHandle$ = 56
RaidAdapterReleaseStartIoLock PROC			; COMDAT

; 1262 : {

$LN11:
	sub	rsp, 40					; 00000028H

; 1263 :     KIRQL   *LockHandleAsIRQL = (KIRQL *) LockHandle;
; 1264 :     if (Adapter->IoModel == StorSynchronizeFullDuplex)
; 1265 :         KeReleaseInStackQueuedSpinLock(LockHandle);
; 1266 :     else
; 1267 :         RaidAdapterReleaseInterruptLock(Adapter, *LockHandleAsIRQL);

	mov	rcx, QWORD PTR [rcx+592]
	test	rcx, rcx
	je	SHORT $LN8@RaidAdapte@4
	mov	dl, BYTE PTR [rdx]
	call	QWORD PTR __imp_KeReleaseInterruptSpinLock
$LN8@RaidAdapte@4:

; 1268 : }

	add	rsp, 40					; 00000028H
	ret	0
RaidAdapterReleaseStartIoLock ENDP
_TEXT	ENDS
PUBLIC	RaidAdapterAcquireStartIoLock
;	COMDAT pdata
pdata	SEGMENT
$pdata$RaidAdapterAcquireStartIoLock DD imagerel $LN12
	DD	imagerel $LN12+37
	DD	imagerel $unwind$RaidAdapterAcquireStartIoLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RaidAdapterAcquireStartIoLock DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RaidAdapterAcquireStartIoLock
_TEXT	SEGMENT
Adapter$ = 48
LockHandle$ = 56
RaidAdapterAcquireStartIoLock PROC			; COMDAT

; 1249 : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1250 :     KIRQL   *LockHandleAsIRQL = (KIRQL *) LockHandle;
; 1251 :     if (Adapter->IoModel == StorSynchronizeFullDuplex)
; 1252 :         KeAcquireInStackQueuedSpinLock(&Adapter->StartIoLock , LockHandle);
; 1253 :     else
; 1254 :         *LockHandleAsIRQL = RaidAdapterAcquireInterruptLock(Adapter);

	mov	rcx, QWORD PTR [rcx+592]
	xor	eax, eax
	mov	rbx, rdx
	cmp	rcx, rax
	je	SHORT $LN8@RaidAdapte@5
	call	QWORD PTR __imp_KeAcquireInterruptSpinLock
$LN8@RaidAdapte@5:
	mov	BYTE PTR [rbx], al

; 1255 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
RaidAdapterAcquireStartIoLock ENDP
_TEXT	ENDS
PUBLIC	RaidSyncAcpiEvalMethod
;	COMDAT pdata
pdata	SEGMENT
$pdata$RaidSyncAcpiEvalMethod DD imagerel $LN22
	DD	imagerel $LN22+414
	DD	imagerel $unwind$RaidSyncAcpiEvalMethod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RaidSyncAcpiEvalMethod DD 0c2001H
	DD	0177420H
	DD	0166420H
	DD	0155420H
	DD	0143420H
	DD	0e019f220H
	DD	0c015d017H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RaidSyncAcpiEvalMethod
_TEXT	SEGMENT
IoStatusBlock$ = 80
Event$ = 96
DeviceObject$ = 160
InputBuffer$ = 168
InputBufferLength$ = 176
OutputBuffer$ = 184
OutputBufferLength$ = 192
BytesReturned$ = 200
RaidSyncAcpiEvalMethod PROC				; COMDAT

; 1161 : {

$LN22:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 128				; 00000080H

; 1162 :     KEVENT              Event;
; 1163 :     IO_STATUS_BLOCK     IoStatusBlock;
; 1164 :     PDEVICE_OBJECT      UpperDevice;
; 1165 :     PIRP                Irp;
; 1166 :     NTSTATUS            status;
; 1167 : 
; 1168 :     UpperDevice = NULL;

	xor	r14d, r14d
	mov	rbx, r9
	mov	r12d, r8d
	mov	r13, rdx
	mov	rbp, rcx
	mov	rsi, r14

; 1169 :     IoStatusBlock.Status = 0;

	mov	DWORD PTR [rax-72], r14d

; 1170 :     IoStatusBlock.Information = 0;

	mov	QWORD PTR [rax-64], r14

; 1171 :     TRY {    
; 1172 :         if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

	mov	rax, cr8
	mov	rdi, QWORD PTR BytesReturned$[rsp]
	cmp	al, r14b
	jbe	SHORT $LN10@RaidSyncAc

; 1173 :             status = STATUS_INVALID_LEVEL;

	mov	ebx, -1073741496			; ffffffffc0000148H
	jmp	$__tryLabel$26984
$LN10@RaidSyncAc:

; 1174 :             LEAVE;
; 1175 :         }
; 1176 : 
; 1177 :         KeInitializeEvent(&Event, NotificationEvent, FALSE);

	lea	rcx, QWORD PTR Event$[rsp]
	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp_KeInitializeEvent

; 1178 :         UpperDevice = IoGetAttachedDeviceReference(DeviceObject);

	mov	rcx, rbp
	call	QWORD PTR __imp_IoGetAttachedDeviceReference

; 1179 :         Irp = IoBuildDeviceIoControlRequest(
; 1180 :                 IOCTL_ACPI_ASYNC_EVAL_METHOD,                      // IO Control Code
; 1181 :                 UpperDevice,
; 1182 :                 InputBuffer,
; 1183 :                 InputBufferLength,
; 1184 :                 OutputBuffer,
; 1185 :                 OutputBufferLength,
; 1186 :                 FALSE,
; 1187 :                 &Event,
; 1188 :                 &IoStatusBlock);

	mov	ebp, DWORD PTR OutputBufferLength$[rsp]
	mov	r9d, r12d
	mov	rsi, rax
	lea	rax, QWORD PTR IoStatusBlock$[rsp]
	mov	r8, r13
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR Event$[rsp]
	mov	rdx, rsi
	mov	QWORD PTR [rsp+56], rax
	mov	BYTE PTR [rsp+48], r14b
	mov	ecx, 3325952				; 0032c000H
	mov	DWORD PTR [rsp+40], ebp
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp_IoBuildDeviceIoControlRequest

; 1189 :      
; 1190 :         if  (Irp == NULL) {

	cmp	rax, r14
	jne	SHORT $LN8@RaidSyncAc

; 1191 :                 status = STATUS_INSUFFICIENT_RESOURCES;

	mov	ebx, -1073741670			; ffffffffc000009aH

; 1209 :         }
; 1210 :     }
; 1211 :     FINALLY {

	jmp	SHORT $__tryLabel$26984
$LN8@RaidSyncAc:

; 1192 :                 LEAVE;
; 1193 :         }
; 1194 : 
; 1195 :         Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
; 1196 :         status = IoCallDriver(UpperDevice, Irp);

	mov	rdx, rax
	mov	rcx, rsi
	mov	DWORD PTR [rax+48], -1073741637		; ffffffffc00000bbH
	call	QWORD PTR __imp_IofCallDriver
	mov	ebx, eax

; 1197 : 
; 1198 :         if ( status == STATUS_PENDING ) {

	cmp	eax, 259				; 00000103H
	jne	SHORT $LN6@RaidSyncAc

; 1199 :             KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

	lea	rcx, QWORD PTR Event$[rsp]
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	QWORD PTR [rsp+32], r14
	call	QWORD PTR __imp_KeWaitForSingleObject

; 1200 :             status = IoStatusBlock.Status;

	mov	ebx, DWORD PTR IoStatusBlock$[rsp]
$LN6@RaidSyncAc:

; 1201 :         }
; 1202 :         
; 1203 :         if ( status >= 0 && IoStatusBlock.Information == 0 && OutputBufferLength > 0 )

	cmp	ebx, r14d
	jl	SHORT $LN5@RaidSyncAc
	cmp	QWORD PTR IoStatusBlock$[rsp+8], r14
	jne	SHORT $LN5@RaidSyncAc
	mov	eax, -1073741823			; ffffffffc0000001H
	cmp	ebp, r14d
	cmova	ebx, eax
$LN5@RaidSyncAc:

; 1204 :             status = STATUS_UNSUCCESSFUL;
; 1205 : 
; 1206 :         if (BytesReturned != NULL) {

	cmp	rdi, r14
	je	SHORT $LN2@RaidSyncAc

; 1207 :             if (status >= 0)

	cmp	ebx, r14d
	jl	SHORT $__tryLabel$26984

; 1208 :                 *BytesReturned = (ULONG) IoStatusBlock.Information;

	mov	eax, DWORD PTR IoStatusBlock$[rsp+8]
	mov	DWORD PTR [rdi], eax
$__tryLabel$26984:

; 1212 :         if (BytesReturned != NULL && status < 0)

	cmp	rdi, r14
	je	SHORT $LN2@RaidSyncAc
	cmp	ebx, r14d
	jge	SHORT $LN2@RaidSyncAc

; 1213 :                 *BytesReturned = 0;

	mov	DWORD PTR [rdi], r14d
$LN2@RaidSyncAc:

; 1214 : 
; 1215 :         if (UpperDevice)

	cmp	rsi, r14
	je	SHORT $LN1@RaidSyncAc

; 1216 :             ObDereferenceObject(UpperDevice);

	mov	rcx, rsi
	call	QWORD PTR __imp_ObfDereferenceObject
$LN1@RaidSyncAc:

; 1217 :     }
; 1218 : 
; 1219 :     return NtStatusToStorStatus(status);

	cmp	ebx, -1073741496			; ffffffffc0000148H
	jne	SHORT $LN19@RaidSyncAc
	mov	eax, -1056964600			; ffffffffc1000008H
	jmp	SHORT $LN15@RaidSyncAc
$LN19@RaidSyncAc:
	cmp	ebx, -1073741670			; ffffffffc000009aH
	jne	SHORT $LN18@RaidSyncAc
	mov	eax, -1056964605			; ffffffffc1000003H
	jmp	SHORT $LN15@RaidSyncAc
$LN18@RaidSyncAc:
	cmp	ebx, -2147483643			; ffffffff80000005H
	jne	SHORT $LN17@RaidSyncAc
	mov	eax, -1056964604			; ffffffffc1000004H
	jmp	SHORT $LN15@RaidSyncAc
$LN17@RaidSyncAc:
	cmp	ebx, -1073741811			; ffffffffc000000dH
	jne	SHORT $LN16@RaidSyncAc
	mov	eax, -1056964602			; ffffffffc1000006H
	jmp	SHORT $LN15@RaidSyncAc
$LN16@RaidSyncAc:
	mov	eax, -1056964607			; ffffffffc1000001H
	cmp	ebx, r14d
	cmovge	eax, r14d
$LN15@RaidSyncAc:

; 1220 : 
; 1221 : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	r13
	pop	r12
	ret	0
RaidSyncAcpiEvalMethod ENDP
PUBLIC	StorportTimerDpc
;	COMDAT pdata
pdata	SEGMENT
$pdata$StorportTimerDpc DD imagerel $LN19
	DD	imagerel $LN19+170
	DD	imagerel $unwind$StorportTimerDpc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorportTimerDpc DD 040a01H
	DD	0a340aH
	DD	07006720aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT StorportTimerDpc
_TEXT	SEGMENT
Lock$ = 32
Dpc$ = 80
TIMER_CONTEXT$ = 88
SystemArgument1$ = 96
SystemArgument2$ = 104
StorportTimerDpc PROC					; COMDAT

; 1395 : {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 1396 :     TimerCallback       Callback;
; 1397 :     KLOCK_QUEUE_HANDLE  Lock;
; 1398 : 
; 1399 :     Callback = (TimerCallback) InterlockedExchangePointer((PVOID *)&TIMER_CONTEXT->Callback, NULL);

	xor	edi, edi
	mov	rbx, rdx
	xchg	QWORD PTR [rdx+136], rdi

; 1400 :     if (Callback) {

	test	rdi, rdi
	je	$LN16@StorportTi

; 1401 :         RaidAdapterAcquireStartIoLock(TIMER_CONTEXT->Adapter, &Lock);

	mov	rax, QWORD PTR [rdx]
	cmp	DWORD PTR [rax+616], 1
	jne	SHORT $LN5@StorportTi
	lea	rcx, QWORD PTR [rax+608]
	lea	rdx, QWORD PTR Lock$[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock
	jmp	SHORT $LN4@StorportTi
$LN5@StorportTi:
	mov	rcx, QWORD PTR [rax+592]
	test	rcx, rcx
	je	SHORT $LN9@StorportTi
	call	QWORD PTR __imp_KeAcquireInterruptSpinLock
	jmp	SHORT $LN8@StorportTi
$LN9@StorportTi:
	xor	al, al
$LN8@StorportTi:
	mov	BYTE PTR Lock$[rsp], al
$LN4@StorportTi:

; 1402 :         Callback(TIMER_CONTEXT->Adapter->Miniport.PrivateDeviceExt->HwDeviceExtension, TIMER_CONTEXT->CallbackContext);

	mov	rax, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+144]
	mov	rcx, QWORD PTR [rax+504]
	add	rcx, 8
	call	rdi

; 1403 :         RaidAdapterReleaseStartIoLock(TIMER_CONTEXT->Adapter, &Lock);

	mov	rcx, QWORD PTR [rbx]
	cmp	DWORD PTR [rcx+616], 1
	jne	SHORT $LN13@StorportTi
	lea	rcx, QWORD PTR Lock$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock
	jmp	SHORT $LN16@StorportTi
$LN13@StorportTi:
	mov	rcx, QWORD PTR [rcx+592]
	test	rcx, rcx
	je	SHORT $LN16@StorportTi
	mov	dl, BYTE PTR Lock$[rsp]
	call	QWORD PTR __imp_KeReleaseInterruptSpinLock
$LN16@StorportTi:

; 1404 :     }
; 1405 : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
StorportTimerDpc ENDP
_TEXT	ENDS
PUBLIC	RaidAdapterFindUnit
;	COMDAT pdata
pdata	SEGMENT
$pdata$RaidAdapterFindUnit DD imagerel $LN23
	DD	imagerel $LN23+228
	DD	imagerel $unwind$RaidAdapterFindUnit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RaidAdapterFindUnit DD 081701H
	DD	0d6417H
	DD	0c5417H
	DD	0a3417H
	DD	070137217H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RaidAdapterFindUnit
_TEXT	SEGMENT
LockHandle$ = 32
Adapter$ = 80
Address$ = 88
RaidAdapterFindUnit PROC				; COMDAT

; 1339 : {

$LN23:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	QWORD PTR [rax+32], rsi
	mov	DWORD PTR [rax+16], edx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, rcx

; 1340 :     LIST_ENTRY             *List;
; 1341 :     LIST_ENTRY             *ListHead;
; 1342 :     KLOCK_QUEUE_HANDLE      LockHandle;
; 1343 :     RAID_UNIT_EXTENSION    *result;
; 1344 :     RAID_UNIT_EXTENSION    *UNIT;
; 1345 :     KIRQL                   CurrentIrql;
; 1346 :     KIRQL                   OldIrql;
; 1347 : 
; 1348 :     CurrentIrql = KeGetCurrentIrql();

	mov	rax, cr8

; 1349 : 
; 1350 :     if (CurrentIrql == PASSIVE_LEVEL) {

	xor	ebx, ebx
	cmp	al, bl
	jne	SHORT $LN7@RaidAdapte@6

; 1351 :         KeAcquireInStackQueuedSpinLock(&Adapter->UnitList.Lock, &LockHandle);

	lea	rdx, QWORD PTR LockHandle$[rsp]
	add	rcx, 112				; 00000070H
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 1352 : 
; 1353 :         ListHead = &Adapter->UnitList.List;

	add	rdi, 120				; 00000078H

; 1354 :         List = ListHead->Flink;

	mov	rdx, QWORD PTR [rdi]

; 1355 : 
; 1356 :         result = NULL;
; 1357 :         while (List != ListHead) {

	cmp	rdx, rdi
	je	SHORT $LN22@RaidAdapte@6
	mov	eax, DWORD PTR Address$[rsp]
	mov	r8b, BYTE PTR Address$[rsp+2]
	mov	r9b, BYTE PTR Address$[rsp+1]
$LL6@RaidAdapte@6:

; 1358 :             UNIT = CONTAINING_RECORD(List,
; 1359 :                                      RAID_UNIT_EXTENSION,
; 1360 :                                      NextUnit);
; 1361 : 
; 1362 :             if ( UNIT->Address.PathId   == Address.PathId     &&
; 1363 :                  UNIT->Address.TargetId == Address.TargetId   &&
; 1364 :                  UNIT->Address.Lun      == Address.Lun ) {

	cmp	BYTE PTR [rdx+32], al
	jne	SHORT $LN4@RaidAdapte@6
	cmp	BYTE PTR [rdx+33], r9b
	jne	SHORT $LN4@RaidAdapte@6
	cmp	BYTE PTR [rdx+34], r8b
	je	SHORT $LN20@RaidAdapte@6
$LN4@RaidAdapte@6:

; 1366 :                     break;
; 1367 :             }
; 1368 : 
; 1369 :             List = List->Flink;

	mov	rdx, QWORD PTR [rdx]
	cmp	rdx, rdi
	je	SHORT $LN22@RaidAdapte@6

; 1355 : 
; 1356 :         result = NULL;
; 1357 :         while (List != ListHead) {

	jmp	SHORT $LL6@RaidAdapte@6
$LN20@RaidAdapte@6:

; 1365 :                     result = UNIT;

	lea	rbx, QWORD PTR [rdx-40]
$LN22@RaidAdapte@6:

; 1370 :         }
; 1371 : 
; 1372 :         KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 1373 :         return result;

	mov	rax, rbx
	jmp	SHORT $LN1@RaidAdapte@6
$LN7@RaidAdapte@6:

; 1374 :     } else {
; 1375 :         if (CurrentIrql >= Adapter->InterruptIrql ) {

	movzx	eax, al
	cmp	eax, DWORD PTR [rcx+600]
	jb	SHORT $LN2@RaidAdapte@6

; 1376 :             return RaidAdapterFindUnitAtDirql(Adapter, Address);

	call	RaidAdapterFindUnitAtDirql
	jmp	SHORT $LN1@RaidAdapte@6
$LN2@RaidAdapte@6:

; 1377 :         } else {
; 1378 :             OldIrql = RaidAdapterAcquireInterruptLock(Adapter);

	mov	rcx, QWORD PTR [rcx+592]
	cmp	rcx, rbx
	je	SHORT $LN13@RaidAdapte@6
	call	QWORD PTR __imp_KeAcquireInterruptSpinLock
	mov	edx, DWORD PTR Address$[rsp]
	mov	sil, al
	jmp	SHORT $LN12@RaidAdapte@6
$LN13@RaidAdapte@6:
	mov	sil, bl
$LN12@RaidAdapte@6:

; 1379 :             result = RaidAdapterFindUnitAtDirql(Adapter, Address);

	mov	rcx, rdi
	call	RaidAdapterFindUnitAtDirql

; 1380 :             RaidAdapterReleaseInterruptLock(Adapter, OldIrql);

	mov	rcx, QWORD PTR [rdi+592]
	mov	rbp, rax
	cmp	rcx, rbx
	je	SHORT $LN16@RaidAdapte@6
	mov	dl, sil
	call	QWORD PTR __imp_KeReleaseInterruptSpinLock
$LN16@RaidAdapte@6:

; 1381 :             return result;

	mov	rax, rbp
$LN1@RaidAdapte@6:

; 1382 :         }
; 1383 :     }
; 1384 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
RaidAdapterFindUnit ENDP
PUBLIC	StorPortExtendedFunction_k8
;	COMDAT pdata
; File d:\develop\mods\ntoskrnl_emu\common.c
pdata	SEGMENT
$pdata$StorPortExtendedFunction_k8 DD imagerel $LN93
	DD	imagerel $LN93+1371
	DD	imagerel $unwind$StorPortExtendedFunction_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorPortExtendedFunction_k8 DD 0b1c01H
	DD	017741cH
	DD	016641cH
	DD	015541cH
	DD	014341cH
	DD	012011cH
	DD	0c015H
; Function compile flags: /Ogspy
; File d:\develop\mods\ntoskrnl_emu\storpor8.c
xdata	ENDS
;	COMDAT StorPortExtendedFunction_k8
_TEXT	SEGMENT
DueTime$27277 = 128
PackedAddress$27221 = 128
FunctionCode$ = 160
HwDeviceExtension$ = 168
va1$ = 176
va2$ = 184
va3$ = 192
va4$ = 200
va5$ = 208
va6$ = 216
va7$ = 224
va8$ = 232
va9$ = 240
va10$ = 248
va11$ = 256
va12$ = 264
va13$ = 272
StorPortExtendedFunction_k8 PROC			; COMDAT

; 1570 : {

$LN93:
	mov	r11, rsp
	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rbp
	mov	QWORD PTR [r11+24], rsi
	mov	QWORD PTR [r11+32], rdi
	push	r12
	sub	rsp, 144				; 00000090H

; 1571 : 
; 1572 :     if (gDumpMode)          // passthrough

	xor	ebx, ebx
	mov	rbp, r9
	mov	rdi, r8
	cmp	BYTE PTR gDumpMode, bl
	je	$LN61@StorPortEx

; 1573 :         return gStorPortExtendedFunction(FunctionCode, HwDeviceExtension,
; 1574 :                      va1, va2, va3, va4, va5, va6, va7, va8,
; 1575 :                      va9, va10, va11, va12, va13);

	mov	rax, QWORD PTR va13$[rsp]
	mov	QWORD PTR [r11-40], rax
	mov	rax, QWORD PTR va12$[rsp]
	mov	QWORD PTR [r11-48], rax
	mov	rax, QWORD PTR va11$[rsp]
	mov	QWORD PTR [r11-56], rax
	mov	rax, QWORD PTR va10$[rsp]
	mov	QWORD PTR [r11-64], rax
	mov	rax, QWORD PTR va9$[rsp]
	mov	QWORD PTR [r11-72], rax
	mov	rax, QWORD PTR va8$[rsp]
	mov	QWORD PTR [r11-80], rax
	mov	rax, QWORD PTR va7$[rsp]
	mov	QWORD PTR [r11-88], rax
	mov	rax, QWORD PTR va6$[rsp]
	mov	QWORD PTR [r11-96], rax
	mov	rax, QWORD PTR va5$[rsp]
	mov	QWORD PTR [r11-104], rax
	mov	rax, QWORD PTR va4$[rsp]
	mov	QWORD PTR [r11-112], rax
	mov	rax, QWORD PTR va3$[rsp]
	mov	QWORD PTR [r11-120], rax
	call	QWORD PTR gStorPortExtendedFunction
	jmp	$LN62@StorPortEx
$LN61@StorPortEx:

; 1576 : 
; 1577 :     if (FunctionCode <= ExtFunctionFreeContiguousMemorySpecifyCache ||      // storport_w7 has
; 1578 :         FunctionCode == ExtFunctionGetProcessorIndexFromNumber)             // 1-25, 56 Extended Functions

	cmp	ecx, 25
	jle	$LN59@StorPortEx
	cmp	ecx, 56					; 00000038H
	je	$LN59@StorPortEx

; 1582 : 
; 1583 : 
; 1584 : ///////////////////////////////////////////////////////////////////////////////////////
; 1585 :     if (FunctionCode == ExtFunctionMarkDumpMemory) {

	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN58@StorPortEx
$LN90@StorPortEx:

; 1586 :         /*
; 1587 :         ULONG StorPortMarkDumpMemory(
; 1588 :             PVOID HwDeviceExtension,
; 1589 :             PVOID Address,
; 1590 :             PVOID Length,
; 1591 :             PVOID Flags );
; 1592 :         */
; 1593 :         return STOR_STATUS_SUCCESS;

	xor	eax, eax
	jmp	$LN62@StorPortEx
$LN58@StorPortEx:

; 1594 :     }
; 1595 : 
; 1596 : ///////////////////////////////////////////////////////////////////////////////////////
; 1597 :     if (FunctionCode == ExtFunctionInitializePoFxPower) {

	cmp	ecx, 48					; 00000030H

; 1598 :         /*
; 1599 :         ULONG StorPortInitializePoFxPower(
; 1600 :             PVOID HwDeviceExtension,
; 1601 :             PSTOR_ADDRESS Address,
; 1602 :             PSTOR_POFX_DEVICE Device,
; 1603 :             PBOOLEAN D3ColdEnabled );
; 1604 :         */
; 1605 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1606 :     }
; 1607 : 
; 1608 : ///////////////////////////////////////////////////////////////////////////////////////
; 1609 :     if (FunctionCode == ExtFunctionPoFxActivateComponent) {

	cmp	ecx, 49					; 00000031H

; 1610 :         /*
; 1611 :         ULONG StorPortPoFxActivateComponent(
; 1612 :             PVOID HwDeviceExtension,
; 1613 :             PSTOR_ADDRESS Address,
; 1614 :             PSCSI_REQUEST_BLOCK Srb,
; 1615 :             ULONG Component,
; 1616 :             ULONG Flags);
; 1617 :         */
; 1618 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1619 :     }
; 1620 : 
; 1621 : ///////////////////////////////////////////////////////////////////////////////////////
; 1622 :     if (FunctionCode == ExtFunctionPoFxIdleComponent) {

	cmp	ecx, 50					; 00000032H

; 1623 :         /*
; 1624 :         ULONG StorPortPoFxIdleComponent(
; 1625 :             PVOID HwDeviceExtension,
; 1626 :             PSTOR_ADDRESS Address,
; 1627 :             PSCSI_REQUEST_BLOCK Srb,
; 1628 :             ULONG Component,
; 1629 :             ULONG Flags);
; 1630 :         */
; 1631 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1632 :     }
; 1633 : 
; 1634 : ///////////////////////////////////////////////////////////////////////////////////////
; 1635 :     if (FunctionCode == ExtFunctionGetActivityId) {

	cmp	ecx, 40					; 00000028H

; 1636 :         /*
; 1637 :         ULONG StorPortGetActivityIdSrb(
; 1638 :             PVOID HwDeviceExtension,
; 1639 :             PSCSI_REQUEST_BLOCK Srb,
; 1640 :             LPGUID ActivityId ); 
; 1641 :         */
; 1642 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1643 :     }
; 1644 : 
; 1645 : ///////////////////////////////////////////////////////////////////////////////////////
; 1646 :     if (FunctionCode == ExtFunctionPoFxSetComponentLatency) {

	cmp	ecx, 51					; 00000033H

; 1647 :         /*
; 1648 :         ULONG StorPortPoFxSetComponentLatency(
; 1649 :             PVOID HwDeviceExtension,
; 1650 :             PSTOR_ADDRESS Address,
; 1651 :             ULONG Component,
; 1652 :             ULONGLONG Latency );
; 1653 :         */
; 1654 : 
; 1655 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1656 :     }
; 1657 : 
; 1658 : ///////////////////////////////////////////////////////////////////////////////////////
; 1659 :     if (FunctionCode == ExtFunctionPoFxSetComponentResidency) {

	cmp	ecx, 52					; 00000034H

; 1660 :         /*
; 1661 :         ULONG StorPortPoFxSetComponentResidency(
; 1662 :             PVOID HwDeviceExtension,
; 1663 :             PSTOR_ADDRESS Address,
; 1664 :             ULONG Component,
; 1665 :             ULONGLONG Residency );
; 1666 :         */
; 1667 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1668 :     }
; 1669 : 
; 1670 : ///////////////////////////////////////////////////////////////////////////////////////
; 1671 :     if (FunctionCode == ExtFunctionPoFxPowerControl) {

	cmp	ecx, 53					; 00000035H

; 1672 :         /*
; 1673 :         ULONG StorPortPoFxPowerControl(
; 1674 :             PVOID HwDeviceExtension,
; 1675 :             PSTOR_ADDRESS Address,
; 1676 :             LPCGUID PowerControlCode,
; 1677 :             PVOID InBuffer,
; 1678 :             SIZE_T InBufferSize,
; 1679 :             PVOID OutBuffer,
; 1680 :             SIZE_T OutBufferSize,
; 1681 :             PSIZE_T BytesReturned );
; 1682 :         */
; 1683 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1684 :     }
; 1685 : 
; 1686 : ///////////////////////////////////////////////////////////////////////////////////////
; 1687 :     if (FunctionCode == ExtFunctionSetPowerSettingNotificationGuids) {

	cmp	ecx, 26

; 1688 :         /*
; 1689 :         ULONG StorPortSetPowerSettingNotificationGuids (
; 1690 :             PVOID  HwDeviceExtension,
; 1691 :             ULONG  GuidCount,
; 1692 :             LPGUID Guid );
; 1693 :         */
; 1694 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1695 :     }
; 1696 : 
; 1697 : ///////////////////////////////////////////////////////////////////////////////////////
; 1698 :     if (FunctionCode == ExtFunctionSetUnitAttributes) {

	cmp	ecx, 46					; 0000002eH

; 1699 :         /*
; 1700 :         ULONG StorPortSetUnitAttributes(
; 1701 :             PVOID HwDeviceExtension,
; 1702 :             PSTOR_ADDRESS Address,
; 1703 :             STOR_UNIT_ATTRIBUTES Attributes
; 1704 :         */
; 1705 :         return STOR_STATUS_SUCCESS;

	je	SHORT $LN90@StorPortEx

; 1706 :     }
; 1707 : 
; 1708 :     
; 1709 : 
; 1710 : ///////////////////////////////////////////////////////////////////////////////////////
; 1711 : //                             storahci_w8
; 1712 :    
; 1713 :     if (FunctionCode == ExtFunctionFreeTimer) {

	cmp	ecx, 34					; 00000022H
	jne	$LN48@StorPortEx

; 1714 :         /*
; 1715 :         ULONG StorPortFreeTimer(
; 1716 :             PVOID HwDeviceExtension,
; 1717 :             PVOID TimerHandle );
; 1718 :         */
; 1719 :         STOR_TIMER_CONTEXT      *TimerHandle = (STOR_TIMER_CONTEXT *)   va1;
; 1720 :         RAID_ADAPTER_EXTENSION  *Adapter;
; 1721 :         IO_WORKITEM             *WorkItem;
; 1722 : 
; 1723 :         if (HwDeviceExtension == NULL || TimerHandle == NULL)

	cmp	rdx, rbx
	je	$LN46@StorPortEx
	cmp	r8, rbx
	je	$LN46@StorPortEx

; 1725 : 
; 1726 :         if (KeGetCurrentIrql() > DISPATCH_LEVEL)

	mov	rax, cr8
	cmp	al, 2
	jbe	SHORT $LN45@StorPortEx
$LN91@StorPortEx:

; 1727 :             return STOR_STATUS_INVALID_IRQL;

	mov	eax, -1056964600			; c1000008H
	jmp	$LN62@StorPortEx
$LN45@StorPortEx:

; 1728 : 
; 1729 :         Adapter = GetAdapter(HwDeviceExtension);

	mov	rax, QWORD PTR [rdx-8]

; 1730 :         InterlockedExchangePointer((PVOID *)&TimerHandle->Callback, NULL);
; 1731 : 
; 1732 :         if (KeCancelTimer(&TimerHandle->Timer) ==  FALSE) { // DPC is live

	lea	rcx, QWORD PTR [r8+8]
	mov	rsi, QWORD PTR [rax]
	mov	rax, rbx
	xchg	QWORD PTR [r8+136], rax
	call	QWORD PTR __imp_KeCancelTimer
	cmp	al, bl
	jne	SHORT $LN44@StorPortEx

; 1733 :             KeRemoveQueueDpc(&TimerHandle->TimerDpc);

	lea	rcx, QWORD PTR [rdi+72]
	call	QWORD PTR __imp_KeRemoveQueueDpc

; 1734 : 
; 1735 :             if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

	mov	r11, cr8
	cmp	r11b, bl
	jbe	SHORT $LN43@StorPortEx

; 1736 :                 WorkItem = IoAllocateWorkItem(Adapter->DeviceObject);

	mov	rcx, QWORD PTR [rsi+8]
	call	QWORD PTR __imp_IoAllocateWorkItem

; 1737 :                 TimerHandle->FreeTimerWorkItem = WorkItem;

	mov	QWORD PTR [rdi+152], rax

; 1738 :                 if (WorkItem == NULL)

	cmp	rax, rbx
	jne	SHORT $LN42@StorPortEx
$LN92@StorPortEx:

; 1739 :                     return STOR_STATUS_INSUFFICIENT_RESOURCES;

	mov	eax, -1056964605			; c1000003H
	jmp	$LN62@StorPortEx
$LN42@StorPortEx:

; 1740 :                 IoQueueWorkItem(WorkItem, (PIO_WORKITEM_ROUTINE) StorpFreeTimerWorkItemCallback, DelayedWorkQueue, TimerHandle);

	lea	rdx, OFFSET FLAT:StorpFreeTimerWorkItemCallback
	mov	r9, rdi
	mov	r8d, 1
	mov	rcx, rax
	call	QWORD PTR __imp_IoQueueWorkItem

; 1741 :                 return STOR_STATUS_SUCCESS;

	jmp	$LN90@StorPortEx
$LN43@StorPortEx:

; 1742 :             }
; 1743 : 
; 1744 :             KeFlushQueuedDpcs();

	call	QWORD PTR __imp_KeFlushQueuedDpcs
$LN44@StorPortEx:

; 1745 :          }
; 1746 :          
; 1747 :         ExFreePoolWithTag(TimerHandle, 'TAaR');

	mov	edx, 1413570898				; 54416152H
	mov	rcx, rdi
	call	QWORD PTR __imp_ExFreePoolWithTag

; 1748 :         //InterlockedDecrement(&gAllocatedTimers);
; 1749 :     
; 1750 :         return STOR_STATUS_SUCCESS;

	jmp	$LN90@StorPortEx
$LN46@StorPortEx:

; 1724 :             return STOR_STATUS_INVALID_PARAMETER;

	mov	eax, -1056964602			; c1000006H
	jmp	$LN62@StorPortEx
$LN48@StorPortEx:

; 1751 :     }
; 1752 : 
; 1753 : ///////////////////////////////////////////////////////////////////////////////////////
; 1754 :     if (FunctionCode == ExtFunctionInitializeTimer) {

	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN41@StorPortEx

; 1755 :         /*
; 1756 :         ULONG StorPortInitializeTimer(
; 1757 :             PVOID HwDeviceExtension,
; 1758 :             PVOID *TimerHandle );
; 1759 :         */
; 1760 :         STOR_TIMER_CONTEXT      *Timer;
; 1761 :         RAID_ADAPTER_EXTENSION  *Adapter;
; 1762 :         PVOID                   *TimerHandle = (PVOID *) va1;
; 1763 : 
; 1764 :         if (HwDeviceExtension == NULL || TimerHandle == NULL)

	cmp	rdx, rbx
	je	SHORT $LN46@StorPortEx
	cmp	r8, rbx
	je	SHORT $LN46@StorPortEx

; 1765 :             return STOR_STATUS_INVALID_PARAMETER;
; 1766 : 
; 1767 :         if (KeGetCurrentIrql() > DISPATCH_LEVEL)

	mov	rax, cr8
	cmp	al, 2

; 1768 :             return STOR_STATUS_INVALID_IRQL;

	ja	$LN91@StorPortEx

; 1769 : 
; 1770 :         Adapter = GetAdapter(HwDeviceExtension);    

	mov	rax, QWORD PTR [rdx-8]

; 1771 :         Timer   = (STOR_TIMER_CONTEXT *) ExAllocatePoolWithTag(NonPagedPool, sizeof(STOR_TIMER_CONTEXT), 'TAaR');

	mov	r12d, 160				; 000000a0H
	mov	r8d, 1413570898				; 54416152H
	mov	rbp, QWORD PTR [rax]
	mov	rdx, r12
	xor	ecx, ecx
	call	QWORD PTR __imp_ExAllocatePoolWithTag
	mov	rsi, rax

; 1772 :         if (Timer == NULL)

	cmp	rax, rbx

; 1773 :             return STOR_STATUS_INSUFFICIENT_RESOURCES;

	je	$LN92@StorPortEx

; 1774 : 
; 1775 :         RtlZeroMemory(Timer, sizeof(STOR_TIMER_CONTEXT));

	mov	r8, r12
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 1776 :         Timer->Adapter = Adapter;
; 1777 :         KeInitializeTimer(&Timer->Timer);

	lea	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsi], rbp
	call	QWORD PTR __imp_KeInitializeTimer

; 1778 :         KeInitializeDpc(&Timer->TimerDpc, (PKDEFERRED_ROUTINE) StorportTimerDpc, Timer);

	lea	rcx, QWORD PTR [rsi+72]
	lea	rdx, OFFSET FLAT:StorportTimerDpc
	mov	r8, rsi
	call	QWORD PTR __imp_KeInitializeDpc

; 1779 :         //InterlockedIncrement(&gAllocatedTimers);
; 1780 :         *TimerHandle = Timer;

	mov	QWORD PTR [rdi], rsi

; 1781 : 
; 1782 :         return STOR_STATUS_SUCCESS;

	jmp	$LN90@StorPortEx
$LN41@StorPortEx:

; 1783 :     }
; 1784 : 
; 1785 : ///////////////////////////////////////////////////////////////////////////////////////
; 1786 :     if (FunctionCode == ExtFunctionInvokeAcpiMethod) {

	cmp	ecx, 27
	jne	$LN26@StorPortEx

; 1787 :         /*
; 1788 :         ULONG StorPortInvokeAcpiMethod (
; 1789 :             PVOID HwDeviceExtension,
; 1790 :             PSTOR_ADDRESS Address,
; 1791 :             ULONG MethodName,
; 1792 :             PVOID InputBuffer,
; 1793 :             ULONG InputBufferLength,
; 1794 :             PVOID OutputBuffer,
; 1795 :             ULONG OutputBufferLength,
; 1796 :             PULONG BytesReturned  );
; 1797 :         */
; 1798 : 
; 1799 :         RAID_ADAPTER_EXTENSION  *Adapter;
; 1800 :         RAID_UNIT_EXTENSION     *Unit;
; 1801 :         PDEVICE_OBJECT          DeviceObject;
; 1802 :         STOR_SCSI_ADDRESS       PackedAddress;
; 1803 : 
; 1804 :         PSTOR_ADDRESS Address       = (PSTOR_ADDRESS) va1;
; 1805 :         PVOID  InputBuffer          = (PVOID) va3;
; 1806 :         ULONG  InputBufferLength    = (ULONG) va4;
; 1807 :         PVOID  OutputBuffer         = (PVOID) va5;
; 1808 :         ULONG  OutputBufferLength   = (ULONG) va6;
; 1809 :         PULONG BytesReturned        = (PULONG) va7;
; 1810 : 
; 1811 :         if (KeGetCurrentIrql() > PASSIVE_LEVEL)

	mov	rax, cr8
	cmp	al, bl

; 1812 :             return STOR_STATUS_INVALID_IRQL;

	ja	$LN91@StorPortEx

; 1813 : 
; 1814 :         if (BytesReturned != NULL)

	mov	rbp, QWORD PTR va7$[rsp]
	cmp	rbp, rbx
	je	SHORT $LN34@StorPortEx

; 1815 :                 *BytesReturned = 0;

	mov	DWORD PTR [rbp], ebx
$LN34@StorPortEx:

; 1816 : 
; 1817 :         Adapter = GetAdapter(HwDeviceExtension);

	mov	rax, QWORD PTR [rdx-8]
	mov	rcx, QWORD PTR [rax]

; 1818 :         if (Adapter == NULL)

	cmp	rcx, rbx

; 1819 :                 return STOR_STATUS_INVALID_PARAMETER;

	je	$LN46@StorPortEx

; 1820 : 
; 1821 :         if (Address != NULL) {

	cmp	r8, rbx
	je	SHORT $LN32@StorPortEx

; 1822 :             if (Address->Type != 1 || Address->AddressLength < 4 ) 

	mov	esi, 1
	cmp	WORD PTR [r8], si
	jne	$LN46@StorPortEx
	cmp	DWORD PTR [r8+4], 4
	jb	$LN46@StorPortEx

; 1823 :                 return STOR_STATUS_INVALID_PARAMETER;
; 1824 : 
; 1825 :             PackedAddress.PathId   = Address->AddressData[0];

	mov	al, BYTE PTR [r8+8]
	mov	BYTE PTR PackedAddress$27221[rsp], al

; 1826 :             PackedAddress.TargetId = Address->AddressData[1];

	mov	al, BYTE PTR [r8+9]
	mov	BYTE PTR PackedAddress$27221[rsp+1], al

; 1827 :             PackedAddress.Lun      = Address->AddressData[2];

	mov	al, BYTE PTR [r8+10]
	mov	BYTE PTR PackedAddress$27221[rsp+2], al

; 1828 :             Unit = RaidAdapterFindUnit(Adapter, PackedAddress);

	mov	edx, DWORD PTR PackedAddress$27221[rsp]
	call	RaidAdapterFindUnit

; 1829 :             if (Unit == NULL)

	cmp	rax, rbx

; 1830 :                 return STOR_STATUS_INVALID_PARAMETER;

	je	$LN46@StorPortEx

; 1831 : 
; 1832 :             DeviceObject = Unit->DeviceObject;

	mov	rcx, QWORD PTR [rax+8]

; 1833 :         }
; 1834 :         else {  //  Adapter == 0

	jmp	SHORT $LN28@StorPortEx
$LN32@StorPortEx:

; 1835 :             DeviceObject = Adapter->DeviceObject;

	mov	rcx, QWORD PTR [rcx+8]
$LN28@StorPortEx:

; 1836 :         }
; 1837 : 
; 1838 :         if (DeviceObject != NULL)

	cmp	rcx, rbx
	je	$LN46@StorPortEx

; 1839 :             return RaidSyncAcpiEvalMethod (
; 1840 :                 DeviceObject,
; 1841 :                 InputBuffer,
; 1842 :                 InputBufferLength,
; 1843 :                 OutputBuffer,
; 1844 :                 OutputBufferLength,
; 1845 :                 BytesReturned);

	mov	eax, DWORD PTR va6$[rsp]
	mov	r9, QWORD PTR va5$[rsp]
	mov	r8d, DWORD PTR va4$[rsp]
	mov	rdx, QWORD PTR va3$[rsp]
	mov	QWORD PTR [rsp+40], rbp
	mov	DWORD PTR [rsp+32], eax
	call	RaidSyncAcpiEvalMethod
	jmp	$LN62@StorPortEx
$LN26@StorPortEx:

; 1846 :         else
; 1847 :             return STOR_STATUS_INVALID_PARAMETER;
; 1848 :  
; 1849 :     }
; 1850 : 
; 1851 : ///////////////////////////////////////////////////////////////////////////////////////
; 1852 :     if (FunctionCode == ExtFunctionDeviceOperationAllowed) {

	cmp	ecx, 55					; 00000037H
	jne	$LN25@StorPortEx

; 1853 :         /*
; 1854 :         ULONG StorPortIsDeviceOperationAllowed(
; 1855 :             PVOID           HwDeviceExtension,
; 1856 :             PSTOR_ADDRESS   Address,
; 1857 :             LPCGUID         DeviceOperation,
; 1858 :             ULONG           *AllowedFlag );
; 1859 :         */
; 1860 :         static const GUID STORPORT_DEVICEOPERATION_SECURE_REPROVISION_GUID = { 0xdcaf9c10, 0x895f, 0x481f, { 0xa4, 0x92, 0xd4, 0xce, 0xd2, 0xf5, 0x56, 0x33 } };
; 1861 :         PRAID_ADAPTER_EXTENSION     Adapter;
; 1862 :         STOR_SCSI_ADDRESS           PackedAddress;
; 1863 : 
; 1864 :         PSTOR_ADDRESS   Address         = (PSTOR_ADDRESS) va1;
; 1865 :         LPCGUID         DeviceOperation = (LPCGUID)      va2;
; 1866 :         ULONG           *AllowedFlag    = (ULONG *)      va3;
; 1867 : 
; 1868 :         if (KeGetCurrentIrql() > PASSIVE_LEVEL)

	mov	rax, cr8
	cmp	al, bl

; 1869 :             return STOR_STATUS_INVALID_IRQL;

	ja	$LN91@StorPortEx

; 1870 : 
; 1871 :         if (AllowedFlag == NULL)

	mov	r12, QWORD PTR va3$[rsp]
	cmp	r12, rbx

; 1872 :             return STOR_STATUS_INVALID_PARAMETER;

	je	$LN46@StorPortEx

; 1873 : 
; 1874 :         *AllowedFlag = FALSE;

	mov	DWORD PTR [r12], ebx

; 1875 :         Adapter = GetAdapter(HwDeviceExtension);
; 1876 : 
; 1877 :         if (Address != NULL) 

	lea	esi, QWORD PTR [rcx-54]
	cmp	r8, rbx
	je	SHORT $LN19@StorPortEx

; 1878 :             if (Address->Type != 1 || Address->AddressLength < 4 ) {

	cmp	WORD PTR [r8], si
	jne	$LN46@StorPortEx
	cmp	DWORD PTR [r8+4], 4

; 1879 :                 return STOR_STATUS_INVALID_PARAMETER;

	jb	$LN46@StorPortEx
$LN19@StorPortEx:

; 1880 : 
; 1881 :             PackedAddress.PathId   = Address->AddressData[0];
; 1882 :             PackedAddress.TargetId = Address->AddressData[1];
; 1883 :             PackedAddress.Lun      = Address->AddressData[2];
; 1884 :             if (RaidAdapterFindUnit(Adapter, PackedAddress ) == NULL)
; 1885 :                 return STOR_STATUS_INVALID_PARAMETER;
; 1886 :             }
; 1887 : 
; 1888 :         if (!RtlEqualMemory(DeviceOperation,
; 1889 :                    &STORPORT_DEVICEOPERATION_SECURE_REPROVISION_GUID,
; 1890 :                    sizeof(GUID)))

	mov	rcx, QWORD PTR [r9]
	lea	rax, OFFSET FLAT:?STORPORT_DEVICEOPERATION_SECURE_REPROVISION_GUID@?FE@??StorPortExtendedFunction_k8@@9@4U_GUID@@B
	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN88@StorPortEx
	mov	rcx, QWORD PTR [r9+8]
	cmp	rcx, QWORD PTR [rax+8]
	jne	SHORT $LN88@StorPortEx
	mov	eax, ebx
	jmp	SHORT $LN89@StorPortEx
$LN88@StorPortEx:
	sbb	eax, eax
	sbb	eax, -1
$LN89@StorPortEx:
	cmp	eax, ebx
	je	SHORT $LN18@StorPortEx
$LN13@StorPortEx:

; 1891 :                         return STOR_STATUS_NOT_IMPLEMENTED;

	mov	eax, -1056964606			; c1000002H
	jmp	$LN62@StorPortEx
$LN18@StorPortEx:

; 1892 : 
; 1893 :         if (RtlCheckRegistryKey(RTL_REGISTRY_CONTROL, L"MiniNT") == STATUS_SUCCESS)  // WinPE

	lea	rdx, OFFSET FLAT:??_C@_1O@BMELCLLB@?$AAM?$AAi?$AAn?$AAi?$AAN?$AAT?$AA?$AA@FNODOBFM@
	mov	ecx, 2
	call	QWORD PTR __imp_RtlCheckRegistryKey
	cmp	eax, ebx
	jne	$LN90@StorPortEx

; 1894 :                 *AllowedFlag = TRUE;

	mov	DWORD PTR [r12], esi

; 1895 : 
; 1896 :         return STOR_STATUS_SUCCESS;

	jmp	$LN90@StorPortEx
$LN25@StorPortEx:

; 1897 :     }
; 1898 : 
; 1899 : ///////////////////////////////////////////////////////////////////////////////////////
; 1900 :     if (FunctionCode == ExtFunctionQueryPerformanceCounter) {

	cmp	ecx, 47					; 0000002fH
	jne	SHORT $LN16@StorPortEx

; 1901 :         /*
; 1902 :         ULONG StorPortQueryPerformanceCounter(
; 1903 :             PVOID HwDeviceExtension,
; 1904 :             PLARGE_INTEGER PerformanceFrequency,
; 1905 :             PLARGE_INTEGER PerformanceCounter );
; 1906 :         */
; 1907 :         PLARGE_INTEGER PerformanceFrequency = (PLARGE_INTEGER) va1;
; 1908 :         PLARGE_INTEGER PerformanceCounter   = (PLARGE_INTEGER) va2;
; 1909 : 
; 1910 :         if (PerformanceCounter == NULL)

	cmp	r9, rbx

; 1911 :             return STOR_STATUS_INVALID_PARAMETER;

	je	$LN46@StorPortEx

; 1912 : 
; 1913 :         if (PerformanceFrequency != NULL) {

	cmp	r8, rbx
	je	SHORT $LN14@StorPortEx

; 1914 :            PerformanceFrequency->LowPart  = 1;

	lea	esi, QWORD PTR [rcx-46]

; 1915 :            PerformanceFrequency->HighPart = 0;

	mov	DWORD PTR [r8+4], ebx
	mov	DWORD PTR [r8], esi
$LN14@StorPortEx:

; 1916 :         }
; 1917 : 
; 1918 :        *PerformanceCounter = KeQueryPerformanceCounter(PerformanceFrequency);

	mov	rcx, r8
	call	QWORD PTR __imp_KeQueryPerformanceCounter
	mov	QWORD PTR [rbp], rax

; 1919 :         return STOR_STATUS_SUCCESS;

	jmp	$LN90@StorPortEx
$LN16@StorPortEx:

; 1920 :     }
; 1921 : 
; 1922 : ///////////////////////////////////////////////////////////////////////////////////////
; 1923 :     if (FunctionCode == ExtFunctionRequestTimer) {

	cmp	ecx, 33					; 00000021H
	jne	SHORT $LN13@StorPortEx

; 1924 :         /*
; 1925 :         ULONG StorPortRequestTimer(
; 1926 :             PVOID HwDeviceExtension,
; 1927 :             PVOID TimerHandle,
; 1928 :             PHW_TIMER_EX TimerCallback,
; 1929 :             PVOID CallbackContext,
; 1930 :             ULONGLONG TimerValue,
; 1931 :             ULONGLONG TolerableDelay );
; 1932 :         */
; 1933 :         RAID_ADAPTER_EXTENSION  *Adapter;
; 1934 :         ULONG                    TolerDelay;
; 1935 :         LARGE_INTEGER            DueTime;
; 1936 : 
; 1937 : 
; 1938 :         STOR_TIMER_CONTEXT  *TimerHandle    = (STOR_TIMER_CONTEXT  *)             va1;
; 1939 :         PHW_TIMER_EX        TimerCallback   = (PHW_TIMER_EX)                      va2;
; 1940 :         PVOID               CallbackContext = (PVOID)                             va3;
; 1941 : 
; 1942 :         #ifdef _AMD64_
; 1943 :             ULONGLONG       TimerValue      = (ULONGLONG)va4; 
; 1944 :             ULONGLONG       TolerableDelay  = (ULONGLONG)va5; 
; 1945 :         #else
; 1946 :             ULONGLONG       TimerValue      = ((ULONGLONG)va5 << 32) + (ULONGLONG)va4; 
; 1947 :             ULONGLONG       TolerableDelay  = ((ULONGLONG)va7 << 32) + (ULONGLONG)va6; 
; 1948 :         #endif
; 1949 : 
; 1950 :         if (!HwDeviceExtension || !TimerHandle || !TimerCallback )

	cmp	rdx, rbx
	je	$LN46@StorPortEx
	cmp	r8, rbx
	je	$LN46@StorPortEx
	cmp	r9, rbx
	je	$LN46@StorPortEx

; 1951 :             return STOR_STATUS_INVALID_PARAMETER;
; 1952 : 
; 1953 :         Adapter = GetAdapter(HwDeviceExtension);
; 1954 : 
; 1955 :         if (TimerValue == 0) {

	mov	rcx, QWORD PTR va4$[rsp]
	cmp	rcx, rbx
	jne	SHORT $LN10@StorPortEx
	mov	rax, QWORD PTR [rdx-8]

; 1956 :             if (TimerHandle->Adapter != Adapter)

	mov	rcx, QWORD PTR [rax]
	cmp	QWORD PTR [r8], rcx

; 1957 :                 return STOR_STATUS_INVALID_PARAMETER;

	jne	$LN46@StorPortEx

; 1958 : 
; 1959 :             if (TimerHandle->Callback != TimerCallback)

	cmp	QWORD PTR [r8+136], r9

; 1960 :                 return STOR_STATUS_INVALID_PARAMETER;

	jne	$LN46@StorPortEx

; 1961 : 
; 1962 :             InterlockedExchangePointer((PVOID *)&TimerHandle->Callback, NULL);

	xchg	QWORD PTR [r8+136], rbx

; 1963 :             KeCancelTimer(&TimerHandle->Timer);

	lea	rcx, QWORD PTR [r8+8]
	call	QWORD PTR __imp_KeCancelTimer

; 1964 :             return STOR_STATUS_SUCCESS;

	jmp	$LN90@StorPortEx
$LN10@StorPortEx:

; 1965 :         }
; 1966 : 
; 1967 :         else {                                              // TimerValue > 0
; 1968 :             if (InterlockedCompareExchangePointer((PVOID *)&TimerHandle->Callback, TimerCallback, NULL))

	xor	eax, eax
	lock cmpxchg QWORD PTR [r8+136], rbp
	je	SHORT $LN6@StorPortEx

; 1969 :                     return STOR_STATUS_BUSY;

	mov	eax, -1056964596			; c100000cH
	jmp	$LN62@StorPortEx
$LN6@StorPortEx:

; 1970 : 
; 1971 :             TimerHandle->CallbackContext= CallbackContext;

	mov	rax, QWORD PTR va3$[rsp]
	mov	QWORD PTR [r8+144], rax

; 1972 : 
; 1973 :             DueTime.HighPart = (-10 * TimerValue) >> 32;

	mov	rax, rcx
	imul	rax, -10
	shr	rax, 32					; 00000020H

; 1974 :             DueTime.LowPart = -10 * (ULONG) TimerValue;

	imul	ecx, -10				; fffffff6H
	mov	DWORD PTR DueTime$27277[rsp+4], eax
	mov	DWORD PTR DueTime$27277[rsp], ecx

; 1975 : 
; 1976 :             TolerDelay = (ULONG) (TolerableDelay / 1000);
; 1977 :             if (TolerableDelay / 1000 >= 32) {
; 1978 :                 if (TolerableDelay != 1000 * (TolerableDelay / 1000))
; 1979 :                     ++TolerDelay;
; 1980 :             }
; 1981 :             else
; 1982 :                 TolerDelay = 0;
; 1983 : 
; 1984 :             if (KeGetCurrentIrql() > DISPATCH_LEVEL) {

	mov	rax, cr8
	cmp	al, 2

; 1985 :                 // TODO:  
; 1986 :                 //return RequestAddtionalTimerDeferred(Adapter, TimerHandle, TolerDelay, DueTime);
; 1987 :                 return STOR_STATUS_INSUFFICIENT_RESOURCES;

	ja	$LN92@StorPortEx

; 1988 :             }
; 1989 :             else {
; 1990 :                 KeSetCoalescableTimer(
; 1991 :                                 &TimerHandle->Timer,
; 1992 :                                 DueTime,
; 1993 :                                 0,
; 1994 :                                 TolerDelay,
; 1995 :                                 &TimerHandle->TimerDpc);

	mov	rdx, QWORD PTR DueTime$27277[rsp]
	lea	r9, QWORD PTR [r8+72]
	lea	rcx, QWORD PTR [r8+8]
	xor	r8d, r8d
	call	QWORD PTR __imp_KeSetTimerEx

; 1996 :                 return STOR_STATUS_SUCCESS;

	jmp	$LN90@StorPortEx
$LN59@StorPortEx:

; 1579 :             return StorPortExtendedFunction(FunctionCode, HwDeviceExtension,
; 1580 :                      va1, va2, va3, va4, va5, va6, va7, va8,
; 1581 :                      va9, va10, va11, va12, va13);

	mov	rax, QWORD PTR va13$[rsp]
	mov	QWORD PTR [rsp+112], rax
	mov	rax, QWORD PTR va12$[rsp]
	mov	QWORD PTR [rsp+104], rax
	mov	rax, QWORD PTR va11$[rsp]
	mov	QWORD PTR [rsp+96], rax
	mov	rax, QWORD PTR va10$[rsp]
	mov	QWORD PTR [rsp+88], rax
	mov	rax, QWORD PTR va9$[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR va8$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR va7$[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR va6$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR va5$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR va4$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR va3$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	StorPortExtendedFunction
$LN62@StorPortEx:

; 1997 :             }
; 1998 :         }    
; 1999 : 
; 2000 :         return STOR_STATUS_SUCCESS;
; 2001 :     }
; 2002 : 
; 2003 : 
; 2004 :     return STOR_STATUS_NOT_IMPLEMENTED;     // default answer to all unsupported functions
; 2005 :     
; 2006 : }    

	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r12
	ret	0
StorPortExtendedFunction_k8 ENDP
PUBLIC	StorportInit
;	COMDAT pdata
pdata	SEGMENT
$pdata$StorportInit DD imagerel $LN26
	DD	imagerel $LN26+2515
	DD	imagerel $unwind$StorportInit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorportInit DD 040a01H
	DD	0a340aH
	DD	07006720aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT StorportInit
_TEXT	SEGMENT
AnsiString$ = 32
AnsiString$29026 = 48
DeviceObject$ = 80
RegistryPath$ = 88
StorportInit PROC					; COMDAT

; 1046 : {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 64					; 00000040H

; 1047 :     ANSI_STRING     AnsiString;
; 1048 :     PVOID           BaseAdress;
; 1049 : 
; 1050 :     gIsWeInitialized = TRUE;

	mov	edi, 1
	mov	rbx, rdx
	mov	BYTE PTR gIsWeInitialized, dil

; 1051 :     gDumpMode = isDumpMode(RegistryPath);

	test	rdx, rdx
	je	SHORT $LN6@StorportIn
	jmp	SHORT $LN24@StorportIn
$LL13@StorportIn:
	lea	r8, OFFSET FLAT:MmShortTime
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_KeDelayExecutionThread
	mov	rdx, rbx
$LN24@StorportIn:
	lea	rcx, QWORD PTR AnsiString$29026[rsp]
	mov	r8b, dil
	call	QWORD PTR __imp_RtlUnicodeStringToAnsiString
	test	eax, eax
	js	SHORT $LL13@StorportIn
	movzx	ebx, WORD PTR AnsiString$29026[rsp]
	mov	rax, QWORD PTR AnsiString$29026[rsp+8]
	add	rbx, rax
	jmp	SHORT $LN25@StorportIn
$LL9@StorportIn:
	sub	rbx, rdi
	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN8@StorportIn
	cmp	BYTE PTR [rbx], 92			; 0000005cH
	je	SHORT $LN21@StorportIn
$LN25@StorportIn:
	cmp	rbx, rax
	ja	SHORT $LL9@StorportIn
	jmp	SHORT $LN8@StorportIn
$LN21@StorportIn:
	add	rbx, rdi
$LN8@StorportIn:
	lea	rdx, OFFSET FLAT:??_C@_04GGLOKIEE@dump?$AA@
	mov	rcx, rbx
	call	QWORD PTR __imp_strstr
	cmp	rax, rbx
	sete	dil
$LN6@StorportIn:
	mov	BYTE PTR gDumpMode, dil

; 1052 : 
; 1053 :     if (gDumpMode) {

	test	dil, dil
	je	$LN2@StorportIn

; 1054 :         BaseAdress = GetModuleBaseAddress_k8("dump_diskdump.sys", NULL, 0, 0);

	lea	rcx, OFFSET FLAT:??_C@_0BC@MKBGMCGD@dump_diskdump?4sys?$AA@FNODOBFM@
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	call	GetModuleBaseAddress_k8
	mov	rbx, rax

; 1055 :         if (BaseAdress == NULL) {

	test	rax, rax
	jne	SHORT $LN1@StorportIn

; 1056 :             gDumpMode = FALSE;      // error,  dump_diskdump.sys not found

	mov	BYTE PTR gDumpMode, al

; 1057 :             return;

	jmp	$LN2@StorportIn
$LN1@StorportIn:

; 1058 :         }
; 1059 : 
; 1060 :         GETROUTINE(ScsiPortMoveMemory)

	lea	rdx, OFFSET FLAT:??_C@_0BD@FPIOHHMD@ScsiPortMoveMemory?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1061 :         GETROUTINE(ScsiPortNotification)

	lea	rdx, OFFSET FLAT:??_C@_0BF@ILLOHBAK@ScsiPortNotification?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gScsiPortMoveMemory, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1062 :         GETROUTINE(StorPortAllocateRegistryBuffer)

	lea	rdx, OFFSET FLAT:??_C@_0BP@PAEBDHOF@StorPortAllocateRegistryBuffer?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gScsiPortNotification, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1063 :         GETROUTINE(StorPortBusy)

	lea	rdx, OFFSET FLAT:??_C@_0N@BEFCFNJH@StorPortBusy?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortAllocateRegistryBuffer, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1064 :         GETROUTINE(StorPortCompleteRequest)

	lea	rdx, OFFSET FLAT:??_C@_0BI@HEHKBONA@StorPortCompleteRequest?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortBusy, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1065 :         GETROUTINE(StorPortConvertUlongToPhysicalAddress)

	lea	rdx, OFFSET FLAT:??_C@_0CG@BMCEFJNP@StorPortConvertUlongToPhysicalAd@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortCompleteRequest, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1066 :         GETROUTINE(StorPortDebugPrint)

	lea	rdx, OFFSET FLAT:??_C@_0BD@BHHNMCLA@StorPortDebugPrint?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortConvertUlongToPhysicalAddress, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1067 :         GETROUTINE(StorPortDeviceBusy)

	lea	rdx, OFFSET FLAT:??_C@_0BD@HHADFJGL@StorPortDeviceBusy?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortDebugPrint, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1068 :         GETROUTINE(StorPortDeviceReady)

	lea	rdx, OFFSET FLAT:??_C@_0BE@KJDCEDBI@StorPortDeviceReady?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortDeviceBusy, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1069 :         GETROUTINE_WITH_TYPE(StorPortExtendedFunction, ULONG (*)(STORPORT_FUNCTION_CODE,PVOID,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR,ULONG_PTR))

	lea	rdx, OFFSET FLAT:??_C@_0BJ@NBKIKGJP@StorPortExtendedFunction?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortDeviceReady, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1070 :         GETROUTINE(StorPortFreeDeviceBase)

	lea	rdx, OFFSET FLAT:??_C@_0BH@MGAINBKN@StorPortFreeDeviceBase?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortExtendedFunction, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1071 :         GETROUTINE(StorPortFreeRegistryBuffer)

	lea	rdx, OFFSET FLAT:??_C@_0BL@DHIABHBB@StorPortFreeRegistryBuffer?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortFreeDeviceBase, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1072 :         GETROUTINE(StorPortGetBusData)

	lea	rdx, OFFSET FLAT:??_C@_0BD@GCOFJKCK@StorPortGetBusData?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortFreeRegistryBuffer, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1073 :         GETROUTINE(StorPortGetDeviceBase)

	lea	rdx, OFFSET FLAT:??_C@_0BG@JNDIICBO@StorPortGetDeviceBase?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetBusData, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1074 :         GETROUTINE(StorPortGetLogicalUnit)

	lea	rdx, OFFSET FLAT:??_C@_0BH@KLCPFFIK@StorPortGetLogicalUnit?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetDeviceBase, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1075 :         GETROUTINE(StorPortGetPhysicalAddress)

	lea	rdx, OFFSET FLAT:??_C@_0BL@BINBEEMP@StorPortGetPhysicalAddress?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetLogicalUnit, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1076 :         GETROUTINE(StorPortGetScatterGatherList)

	lea	rdx, OFFSET FLAT:??_C@_0BN@MKNFKDMF@StorPortGetScatterGatherList?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetPhysicalAddress, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1077 :         GETROUTINE(StorPortGetSrb)

	lea	rdx, OFFSET FLAT:??_C@_0P@HCFCOKL@StorPortGetSrb?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetScatterGatherList, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1078 :         GETROUTINE(StorPortGetUncachedExtension)

	lea	rdx, OFFSET FLAT:??_C@_0BN@HMBNJKCA@StorPortGetUncachedExtension?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetSrb, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1079 :         GETROUTINE(StorPortGetVirtualAddress)

	lea	rdx, OFFSET FLAT:??_C@_0BK@BHMOCJOF@StorPortGetVirtualAddress?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetUncachedExtension, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1080 :         GETROUTINE(StorPortLogError)

	lea	rdx, OFFSET FLAT:??_C@_0BB@PJCEKPO@StorPortLogError?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortGetVirtualAddress, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1081 :         GETROUTINE_WITH_TYPE(StorPortInitialize, ULONG (*)(PVOID,PVOID,_HW_INITIALIZATION_DATA *,PVOID))

	lea	rdx, OFFSET FLAT:??_C@_0BD@GCMJEEAJ@StorPortInitialize?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortLogError, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1082 :         GETROUTINE(StorPortMoveMemory)

	lea	rdx, OFFSET FLAT:??_C@_0BD@KOLGMFLA@StorPortMoveMemory?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortInitialize, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1083 :         GETROUTINE(StorPortNotification)

	lea	rdx, OFFSET FLAT:??_C@_0BF@KKMDHIKH@StorPortNotification?$AA@FNODOBFM@
	mov	QWORD PTR gStorPortMoveMemory, rax
	lea	rcx, QWORD PTR AnsiString$[rsp]
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1084 :         GETROUTINE(StorPortPause)

	lea	rdx, OFFSET FLAT:??_C@_0O@IFHHIDIA@StorPortPause?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortNotification, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1085 :         GETROUTINE(StorPortPauseDevice)

	lea	rdx, OFFSET FLAT:??_C@_0BE@HDDKBHCK@StorPortPauseDevice?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortPause, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1086 :         GETROUTINE(StorPortQuerySystemTime)

	lea	rdx, OFFSET FLAT:??_C@_0BI@KDMOFKKG@StorPortQuerySystemTime?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortPauseDevice, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1087 :         GETROUTINE(StorPortReadPortBufferUchar)

	lea	rdx, OFFSET FLAT:??_C@_0BM@HOGMPIOG@StorPortReadPortBufferUchar?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortQuerySystemTime, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1088 :         GETROUTINE(StorPortReadPortBufferUlong)

	lea	rdx, OFFSET FLAT:??_C@_0BM@FNACPGKH@StorPortReadPortBufferUlong?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadPortBufferUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1089 :         GETROUTINE(StorPortReadPortBufferUshort)

	lea	rdx, OFFSET FLAT:??_C@_0BN@OBENOCOP@StorPortReadPortBufferUshort?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadPortBufferUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1090 :         GETROUTINE(StorPortReadPortUchar)

	lea	rdx, OFFSET FLAT:??_C@_0BG@PPONEKFE@StorPortReadPortUchar?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadPortBufferUshort, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1091 :         GETROUTINE(StorPortReadPortUlong)

	lea	rdx, OFFSET FLAT:??_C@_0BG@NMIDEEBF@StorPortReadPortUlong?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadPortUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1092 :         GETROUTINE(StorPortReadPortUshort)

	lea	rdx, OFFSET FLAT:??_C@_0BH@MEKDLBPN@StorPortReadPortUshort?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadPortUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1093 :         GETROUTINE(StorPortReadRegisterBufferUchar)

	lea	rdx, OFFSET FLAT:??_C@_0CA@IPEIFNOH@StorPortReadRegisterBufferUchar?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadPortUshort, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1094 :         GETROUTINE(StorPortReadRegisterBufferUlong)

	lea	rdx, OFFSET FLAT:??_C@_0CA@KMCGFDKG@StorPortReadRegisterBufferUlong?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadRegisterBufferUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1095 :         GETROUTINE(StorPortReadRegisterBufferUshort)

	lea	rdx, OFFSET FLAT:??_C@_0CB@JGLLPGNM@StorPortReadRegisterBufferUshort@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadRegisterBufferUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1096 :         GETROUTINE(StorPortReadRegisterUchar)

	lea	rdx, OFFSET FLAT:??_C@_0BK@PMDMNBFF@StorPortReadRegisterUchar?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadRegisterBufferUshort, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1097 :         GETROUTINE(StorPortReadRegisterUlong)

	lea	rdx, OFFSET FLAT:??_C@_0BK@NPFCNPBE@StorPortReadRegisterUlong?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadRegisterUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1098 :         GETROUTINE(StorPortReadRegisterUshort)

	lea	rdx, OFFSET FLAT:??_C@_0BL@LDKHFAPA@StorPortReadRegisterUshort?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadRegisterUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1099 :         GETROUTINE(StorPortReady)

	lea	rdx, OFFSET FLAT:??_C@_0O@BNFKKMCL@StorPortReady?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReadRegisterUshort, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1100 :         GETROUTINE_WITH_TYPE(StorPortRegistryRead, BOOLEAN (*)(PVOID,PUCHAR,ULONG,ULONG,PUCHAR,PULONG))

	lea	rdx, OFFSET FLAT:??_C@_0BF@ICLOLJPJ@StorPortRegistryRead?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortReady, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1101 :         GETROUTINE(StorPortRegistryWrite)

	lea	rdx, OFFSET FLAT:??_C@_0BG@IHPGDKFN@StorPortRegistryWrite?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortRegistryRead, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1102 :         GETROUTINE(StorPortResume)

	lea	rdx, OFFSET FLAT:??_C@_0P@FNIBMDLK@StorPortResume?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortRegistryWrite, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1103 :         GETROUTINE(StorPortResumeDevice)

	lea	rdx, OFFSET FLAT:??_C@_0BF@KOLPEGFL@StorPortResumeDevice?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortResume, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1104 :         GETROUTINE(StorPortSetBusDataByOffset)

	lea	rdx, OFFSET FLAT:??_C@_0BL@DJHNLPFD@StorPortSetBusDataByOffset?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortResumeDevice, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1105 :         GETROUTINE(StorPortSetDeviceQueueDepth)

	lea	rdx, OFFSET FLAT:??_C@_0BM@KPMDOALK@StorPortSetDeviceQueueDepth?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortSetBusDataByOffset, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1106 :         GETROUTINE(StorPortStallExecution)

	lea	rdx, OFFSET FLAT:??_C@_0BH@OGJLKMMK@StorPortStallExecution?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortSetDeviceQueueDepth, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1107 :         GETROUTINE(StorPortSynchronizeAccess)

	lea	rdx, OFFSET FLAT:??_C@_0BK@FMFLKMCG@StorPortSynchronizeAccess?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortStallExecution, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1108 :         GETROUTINE(StorPortValidateRange)

	lea	rdx, OFFSET FLAT:??_C@_0BG@JOHPEADN@StorPortValidateRange?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortSynchronizeAccess, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1109 :         GETROUTINE(StorPortWritePortBufferUchar)

	lea	rdx, OFFSET FLAT:??_C@_0BN@HOPGPDLM@StorPortWritePortBufferUchar?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortValidateRange, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1110 :         GETROUTINE(StorPortWritePortBufferUlong)

	lea	rdx, OFFSET FLAT:??_C@_0BN@FNJIPNPN@StorPortWritePortBufferUlong?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWritePortBufferUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1111 :         GETROUTINE(StorPortWritePortBufferUshort)

	lea	rdx, OFFSET FLAT:??_C@_0BO@GKPDMAAO@StorPortWritePortBufferUshort?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWritePortBufferUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1112 :         GETROUTINE(StorPortWritePortUchar)

	lea	rdx, OFFSET FLAT:??_C@_0BH@ODGHFCAF@StorPortWritePortUchar?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWritePortBufferUshort, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1113 :         GETROUTINE(StorPortWritePortUlong)

	lea	rdx, OFFSET FLAT:??_C@_0BH@MAAJFMEE@StorPortWritePortUlong?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWritePortUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1114 :         GETROUTINE(StorPortWritePortUshort)

	lea	rdx, OFFSET FLAT:??_C@_0BI@NINDFKIH@StorPortWritePortUshort?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWritePortUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1115 :         GETROUTINE(StorPortWriteRegisterBufferUchar)

	lea	rdx, OFFSET FLAT:??_C@_0CB@KMADDPFA@StorPortWriteRegisterBufferUchar@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWritePortUshort, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1116 :         GETROUTINE(StorPortWriteRegisterBufferUlong)

	lea	rdx, OFFSET FLAT:??_C@_0CB@IPGNDBBB@StorPortWriteRegisterBufferUlong@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWriteRegisterBufferUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1117 :         GETROUTINE(StorPortWriteRegisterBufferUshort)

	lea	rdx, OFFSET FLAT:??_C@_0CC@MDJNJLJB@StorPortWriteRegisterBufferUshor@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWriteRegisterBufferUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1118 :         GETROUTINE(StorPortWriteRegisterUchar)

	lea	rdx, OFFSET FLAT:??_C@_0BL@EINFGHNE@StorPortWriteRegisterUchar?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWriteRegisterBufferUshort, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1119 :         GETROUTINE(StorPortWriteRegisterUlong)

	lea	rdx, OFFSET FLAT:??_C@_0BL@GLLLGJJF@StorPortWriteRegisterUlong?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWriteRegisterUchar, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8

; 1120 :         GETROUTINE(StorPortWriteRegisterUshort)

	lea	rdx, OFFSET FLAT:??_C@_0BM@CJKMAKPA@StorPortWriteRegisterUshort?$AA@FNODOBFM@
	lea	rcx, QWORD PTR AnsiString$[rsp]
	mov	QWORD PTR gStorPortWriteRegisterUlong, rax
	call	QWORD PTR __imp_RtlInitAnsiString
	lea	rdx, QWORD PTR AnsiString$[rsp]
	mov	rcx, rbx
	call	MiFindExportedRoutineByName_k8
	mov	QWORD PTR gStorPortWriteRegisterUshort, rax
$LN2@StorportIn:

; 1121 :     }
; 1122 : }

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
StorportInit ENDP
_TEXT	ENDS
PUBLIC	DllInitialize
;	COMDAT pdata
pdata	SEGMENT
$pdata$DllInitialize DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$DllInitialize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DllInitialize DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT DllInitialize
_TEXT	SEGMENT
RegistryPath$ = 48
DllInitialize PROC					; COMDAT

; 2021 : {

$LN3:
	sub	rsp, 40					; 00000028H

; 2022 :      /*     // debug loop
; 2023 :     __asm {
; 2024 :         L1:
; 2025 :         jmp L1
; 2026 :     }
; 2027 :     */
; 2028 :     
; 2029 :     StorportInit((PDEVICE_OBJECT) -1, RegistryPath);

	mov	rdx, rcx
	or	rcx, -1
	call	StorportInit

; 2030 : 
; 2031 :     return STATUS_SUCCESS;

	xor	eax, eax

; 2032 : }

	add	rsp, 40					; 00000028H
	ret	0
DllInitialize ENDP
_TEXT	ENDS
PUBLIC	StorPortInitialize_k8
;	COMDAT pdata
pdata	SEGMENT
$pdata$StorPortInitialize_k8 DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$StorPortInitialize_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorPortInitialize_k8 DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT StorPortInitialize_k8
_TEXT	SEGMENT
Argument1$ = 48
Argument2$ = 56
HwInitializationData$ = 64
HwContext$ = 72
StorPortInitialize_k8 PROC				; COMDAT

; 1484 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1485 :     if (!gIsWeInitialized)                  // dump mode, called from miniport

	cmp	BYTE PTR gIsWeInitialized, 0
	mov	rsi, r9
	mov	rbp, r8
	mov	rbx, rdx
	mov	rdi, rcx
	jne	SHORT $LN3@StorPortIn

; 1486 :         StorportInit((PDEVICE_OBJECT) Argument1, (PUNICODE_STRING) Argument2); // both args are null

	call	StorportInit
$LN3@StorPortIn:

; 1487 : 
; 1488 :     if (gDumpMode)          // passthrough

	cmp	BYTE PTR gDumpMode, 0

; 1489 :         return gStorPortInitialize(
; 1490 :                     Argument1,
; 1491 :                     Argument2,
; 1492 :                     HwInitializationData,
; 1493 :                     HwContext);

	mov	r9, rsi
	mov	r8, rbp
	mov	rdx, rbx
	mov	rcx, rdi
	je	SHORT $LN2@StorPortIn
	call	QWORD PTR gStorPortInitialize
	jmp	SHORT $LN1@StorPortIn
$LN2@StorPortIn:

; 1494 :     else
; 1495 :         return StorPortInitialize(
; 1496 :                     Argument1,
; 1497 :                     Argument2,
; 1498 :                     HwInitializationData,
; 1499 :                     HwContext);

	call	StorPortInitialize
$LN1@StorPortIn:

; 1500 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
StorPortInitialize_k8 ENDP
_TEXT	ENDS
END
