; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	TrampKeBugCheckEx
PUBLIC	UIntToPtr
PUBLIC	KeGetCurrentProcessorNumber
PUBLIC	EXP_GET_CURRENT_RUNDOWN_REF
PUBLIC	EXP_GET_PROCESSOR_RUNDOWN_REF
PUBLIC	PsGetCurrentThread
PUBLIC	KeEnterCriticalRegionThread
PUBLIC	KeGetCurrentPrcb
PUBLIC	ExFreeToPPLookasideList
PUBLIC	ExReleasePushLockShared
PUBLIC	KeGetCurrentThread
PUBLIC	KfRaiseIrql
PUBLIC	KeLowerIrql
PUBLIC	ExInitializeFastMutex
PUBLIC	KeInitializeSpinLock
PUBLIC	gGuardedRegionCounter
PUBLIC	MmShortTime
PUBLIC	??_C@_00CNPNBAHC@?$AA@FNODOBFM@			;  ?? ::FNODOBFM::`string'
EXTRN	__imp_KeBugCheckEx:PROC
EXTRN	__imp_KeSetEvent:PROC
EXTRN	__imp_KeNumberProcessors:BYTE
EXTRN	__imp_KeGetRecommendedSharedDataAlignment:PROC
EXTRN	__imp_ExInitializeRundownProtection:PROC
EXTRN	__imp_ExAcquireRundownProtection:PROC
EXTRN	__imp_ExReleaseRundownProtection:PROC
EXTRN	__imp_ExAcquireRundownProtectionEx:PROC
EXTRN	__imp_ExReleaseRundownProtectionEx:PROC
EXTRN	__imp_ExAcquireResourceExclusiveLite:PROC
EXTRN	__imp_ExAcquireResourceSharedLite:PROC
EXTRN	__imp_ExReleaseResourceLite:PROC
EXTRN	__imp_MmHighestUserAddress:QWORD
EXTRN	PsGetThreadWin32Thread:PROC
EXTRN	__imp_IoGetCurrentProcess:PROC
EXTRN	__imp_PsInitialSystemProcess:QWORD
EXTRN	SeReleaseSecurityDescriptor:PROC
EXTRN	__imp_ExQueryDepthSList:PROC
EXTRN	__imp_ExpInterlockedPushEntrySList:PROC
EXTRN	ExfReleasePushLock:PROC
EXTRN	__imp_KeBugCheck:PROC
EXTRN	MmGrowKernelStack:PROC
EXTRN	KeGetCurrentStackPointer:PROC
EXTRN	__imp_KeEnterCriticalRegion:PROC
EXTRN	__imp_KeLeaveCriticalRegion:PROC
EXTRN	__imp_ExAcquireFastMutex:PROC
EXTRN	__imp_ExTryToAcquireFastMutex:PROC
EXTRN	__imp_ExReleaseFastMutex:PROC
EXTRN	__imp_ExAcquireFastMutexUnsafe:PROC
EXTRN	__imp_ExReleaseFastMutexUnsafe:PROC
EXTRN	__imp_RtlFreeAnsiString:PROC
EXTRN	__imp_MmUserProbeAddress:QWORD
EXTRN	NtQuerySystemInformation:PROC
EXTRN	g_pfnKiServiceLinkage:QWORD
EXTRN	g_pfnKiServiceInternal:QWORD
EXTRN	NtQueryVirtualMemory_0x1F:PROC
EXTRN	NtQueryVirtualMemory_0x20:PROC
EXTRN	__imp_ZwRequestWaitReplyPort:PROC
	ALIGN	4

gGuardedRegionCounter DD 01H DUP (?)
;	COMDAT ??_C@_00CNPNBAHC@?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_00CNPNBAHC@?$AA@FNODOBFM@ DB 00H			;  ?? ::FNODOBFM::`string'
MmShortTime DD	0fffe7960H
	DD	0ffffffffH
KeTestAlertThread_magic1 DB 055H
	DB	08bH
	DB	0ecH
	DB	083H
	DB	0ecH
	DB	0cH
	DB	053H
	DB	056H
	DB	064H
	DB	08bH
	DB	035H
	DB	024H
	DB	01H
	DB	00H
	DB	00H
	DB	08dH
	DB	04eH
	DB	044H
	DB	08dH
	DB	055H
	DB	0f4H
	DB	0ffH
	DB	015H
	DB	011H
	DB	022H
	DB	033H
	DB	044H
	DB	0fH
	DB	0beH
	DB	045H
	DB	08H
	DB	08dH
	DB	044H
	DB	030H
	DB	05eH
	ORG $+5
KeTestAlertThread_magic1mask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+5
LpcRequestWaitReplyPortEx_magic1 DB 055H
	DB	08bH
	DB	0ecH
	DB	064H
	DB	0a1H
	DB	024H
	DB	01H
	DB	00H
	DB	00H
	DB	0fH
	DB	0beH
	DB	080H
	DB	0d7H
	DB	00H
	DB	00H
	DB	00H
	DB	050H
	DB	0ffH
	DB	075H
	DB	010H
	DB	0ffH
	DB	075H
	DB	0cH
	DB	0ffH
	DB	075H
	DB	08H
	DB	0e8H
	DB	011H
	DB	022H
	DB	033H
	DB	044H
	DB	05dH
	DB	0c2H
	DB	0cH
	DB	00H
	ORG $+5
LpcRequestWaitReplyPortEx_magic1mask DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
PUBLIC	RtlSectionTableFromVirtualAddress_k8
; Function compile flags: /Ogspy
; File d:\develop\mods\ntoskrnl_emu\wrk2003.c
;	COMDAT RtlSectionTableFromVirtualAddress_k8
_TEXT	SEGMENT
NtHeaders$ = 8
Base$ = 16
Address$ = 24
RtlSectionTableFromVirtualAddress_k8 PROC		; COMDAT

; 713  :     ULONG i;
; 714  :     PIMAGE_SECTION_HEADER NtSection;
; 715  : 
; 716  :     NtSection = IMAGE_FIRST_SECTION( NtHeaders );

	movzx	eax, WORD PTR [rcx+20]

; 717  :     for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {

	movzx	r10d, WORD PTR [rcx+6]
	xor	r9d, r9d
	lea	rdx, QWORD PTR [rax+rcx+24]
	cmp	r10d, r9d
	jbe	SHORT $LN10@RtlSection
$LL4@RtlSection:

; 718  :         if ((ULONG)Address >= NtSection->VirtualAddress &&
; 719  :             (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
; 720  :            ) {

	mov	ecx, DWORD PTR [rdx+12]
	cmp	r8d, ecx
	jb	SHORT $LN1@RtlSection
	add	ecx, DWORD PTR [rdx+16]
	cmp	r8d, ecx
	jb	SHORT $LN8@RtlSection
$LN1@RtlSection:

; 717  :     for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {

	inc	r9d

; 722  :             }
; 723  :         ++NtSection;

	add	rdx, 40					; 00000028H
	cmp	r9d, r10d
	jb	SHORT $LL4@RtlSection
$LN10@RtlSection:

; 724  :         }
; 725  : 
; 726  :     return NULL;

	xor	eax, eax

; 727  : }

	ret	0
$LN8@RtlSection:

; 721  :             return NtSection;

	mov	rax, rdx

; 727  : }

	ret	0
RtlSectionTableFromVirtualAddress_k8 ENDP
_TEXT	ENDS
PUBLIC	RtlImageNtHeaderEx_k8
; Function compile flags: /Ogspy
;	COMDAT RtlImageNtHeaderEx_k8
_TEXT	SEGMENT
Flags$ = 8
Base$ = 16
Size$ = 24
OutHeaders$ = 32
RtlImageNtHeaderEx_k8 PROC				; COMDAT

; 603  :     PIMAGE_NT_HEADERS NtHeaders = 0;
; 604  :     ULONG e_lfanew = 0;
; 605  :     BOOLEAN RangeCheck = 0;
; 606  :     NTSTATUS Status = 0;
; 607  :     const ULONG ValidFlags = 
; 608  :         RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK;
; 609  : 
; 610  :     if (OutHeaders != NULL) {

	xor	ecx, ecx
	mov	r8, rdx
	cmp	r9, rcx
	je	SHORT $LN28@RtlImageNt

; 611  :         *OutHeaders = NULL;

	mov	QWORD PTR [r9], rcx

; 615  :         goto Exit;
; 616  :     }
; 617  :     if ((Flags & ~ValidFlags) != 0) {
; 618  :         Status = STATUS_INVALID_PARAMETER;
; 619  :         goto Exit;
; 620  :     }
; 621  :     if (Base == NULL || Base == (PVOID)(LONG_PTR)-1) {

	cmp	rdx, rcx
	je	SHORT $LN28@RtlImageNt
	cmp	rdx, -1
	je	SHORT $LN28@RtlImageNt

; 622  :         Status = STATUS_INVALID_PARAMETER;
; 623  :         goto Exit;
; 624  :     }
; 625  : 
; 626  :     RangeCheck = ((Flags & RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK) == 0);
; 627  :     if (RangeCheck) {
; 628  :         if (Size < sizeof(IMAGE_DOS_HEADER)) {
; 629  :             Status = STATUS_INVALID_IMAGE_FORMAT;
; 630  :             goto Exit;
; 631  :         }
; 632  :     }
; 633  : 
; 634  :     //
; 635  :     // Exception handling is not available in the boot loader, and exceptions
; 636  :     // were not historically caught here in kernel mode. Drivers are considered
; 637  :     // trusted, so we can't get an exception here due to a bad file, but we
; 638  :     // could take an inpage error.
; 639  :     //
; 640  : #define EXIT goto Exit
; 641  :     if (((PIMAGE_DOS_HEADER)Base)->e_magic != IMAGE_DOS_SIGNATURE) {

	mov	eax, 23117				; 00005a4dH
	cmp	WORD PTR [rdx], ax
	je	SHORT $LN14@RtlImageNt
$LN30@RtlImageNt:

; 642  :         Status = STATUS_INVALID_IMAGE_FORMAT;

	mov	ecx, -1073741701			; ffffffffc000007bH

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jmp	SHORT $LN1@RtlImageNt
$LN14@RtlImageNt:

; 643  :         EXIT;
; 644  :     }
; 645  :     e_lfanew = ((PIMAGE_DOS_HEADER)Base)->e_lfanew;
; 646  :     if (RangeCheck) {
; 647  :         if (e_lfanew >= Size
; 648  : #define SIZEOF_PE_SIGNATURE 4
; 649  :             || e_lfanew >= (MAXULONG - SIZEOF_PE_SIGNATURE - sizeof(IMAGE_FILE_HEADER))
; 650  :             || (e_lfanew + SIZEOF_PE_SIGNATURE + sizeof(IMAGE_FILE_HEADER)) >= Size
; 651  :             ) {
; 652  :             Status = STATUS_INVALID_IMAGE_FORMAT;
; 653  :             EXIT;
; 654  :         }
; 655  :     }
; 656  : 
; 657  :     NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + e_lfanew);
; 658  : 
; 659  :     //
; 660  :     // In kernelmode, do not cross from usermode address to kernelmode address.
; 661  :     //
; 662  :     if (Base < MM_HIGHEST_USER_ADDRESS) {

	mov	rax, QWORD PTR __imp_MmHighestUserAddress
	mov	edx, DWORD PTR [rdx+60]
	mov	r10, QWORD PTR [rax]
	add	rdx, r8
	cmp	r8, r10
	jae	SHORT $LN5@RtlImageNt

; 663  :         if ((PVOID)NtHeaders >= MM_HIGHEST_USER_ADDRESS) {

	cmp	rdx, r10

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jae	SHORT $LN30@RtlImageNt
	lea	rax, QWORD PTR [rdx+264]
	cmp	rax, r10
	jae	SHORT $LN30@RtlImageNt
$LN5@RtlImageNt:

; 664  :             Status = STATUS_INVALID_IMAGE_FORMAT;
; 665  :             EXIT;
; 666  :         }
; 667  :         //
; 668  :         // Note that this check is slightly overeager since IMAGE_NT_HEADERS has
; 669  :         // a builtin array of data_directories that may be larger than the image
; 670  :         // actually has. A better check would be to add FileHeader.SizeOfOptionalHeader,
; 671  :         // after ensuring that the FileHeader does not cross the u/k boundary.
; 672  :         //
; 673  :         if ((PVOID)((PCHAR)NtHeaders + sizeof (IMAGE_NT_HEADERS)) >= MM_HIGHEST_USER_ADDRESS) {
; 674  :             Status = STATUS_INVALID_IMAGE_FORMAT;
; 675  :             EXIT;
; 676  :         }
; 677  :     }
; 678  : 
; 679  :     if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {

	cmp	DWORD PTR [rdx], 17744			; 00004550H

; 680  :         Status = STATUS_INVALID_IMAGE_FORMAT;
; 681  :         EXIT;
; 682  :     }
; 683  :     Status = STATUS_SUCCESS;
; 684  : 
; 685  : Exit:

	jne	SHORT $LN30@RtlImageNt

; 686  :     if (NT_SUCCESS(Status)) {
; 687  :         *OutHeaders = NtHeaders;

	mov	QWORD PTR [r9], rdx
	jmp	SHORT $LN1@RtlImageNt
$LN28@RtlImageNt:

; 612  :     }
; 613  :     if (OutHeaders == NULL) {
; 614  :         Status = STATUS_INVALID_PARAMETER;

	mov	ecx, -1073741811			; ffffffffc000000dH
$LN1@RtlImageNt:

; 688  :     }
; 689  :     return Status;

	mov	eax, ecx

; 690  : }

	ret	0
RtlImageNtHeaderEx_k8 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TrampKeBugCheckEx DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$TrampKeBugCheckEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TrampKeBugCheckEx DD 010401H
	DD	06204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT TrampKeBugCheckEx
_TEXT	SEGMENT
TrampKeBugCheckEx PROC					; COMDAT

; 14   : {

$LN4:
	sub	rsp, 56					; 00000038H

; 15   :     KeBugCheckEx(0xDEADBEEFL, 5, 0, 0, 1);

	xor	r9d, r9d
	xor	r8d, r8d
	mov	ecx, -559038737				; deadbeefH
	lea	edx, QWORD PTR [r9+5]
	mov	QWORD PTR [rsp+32], 1
	call	QWORD PTR __imp_KeBugCheckEx
	int	3
$LN3@TrampKeBug:
TrampKeBugCheckEx ENDP
PUBLIC	GetModuleBaseAddress_k8
EXTRN	memset:PROC
;	COMDAT pdata
; File d:\develop\ddk\winddk\7600.16385.1\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$GetModuleBaseAddress_k8 DD imagerel $LN23
	DD	imagerel $LN23+214
	DD	imagerel $unwind$GetModuleBaseAddress_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetModuleBaseAddress_k8 DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogspy
; File d:\develop\mods\ntoskrnl_emu\wrk2003.c
xdata	ENDS
;	COMDAT GetModuleBaseAddress_k8
_TEXT	SEGMENT
ReturnLength$ = 32
Modulename$ = 64
ModuleSize$ = 72
ByOrderMode$ = 80
OrderNum$ = 88
GetModuleBaseAddress_k8 PROC				; COMDAT

; 1475 : {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 1476 :     NTSTATUS                Status;
; 1477 :     PVOID                   FunctionAddress;
; 1478 :     LOGICAL                 Found;
; 1479 :     ULONG                   ReturnLength;
; 1480 :     PRTL_PROCESS_MODULES    ModuleInformation;
; 1481 :     PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
; 1482 :     CHAR                   *FileName;
; 1483 :     ULONG_PTR               OldUserProbeAddress;
; 1484 :     ULONG_PTR              *pUserProbeAddress;
; 1485 : 
; 1486 :     if (KeGetCurrentIrql() >= DISPATCH_LEVEL)

	mov	rax, cr8

; 1487 :         ModuleInformation = (PRTL_PROCESS_MODULES) ExAllocatePoolWithTag(NonPagedPool, NtQuery_BUFFERSIZE * sizeof(UCHAR), 'pmuD');

	mov	ebx, 102400				; 00019000H
	mov	r8d, 1886221636				; 706d7544H
	mov	rdx, rbx
	cmp	al, 2
	jb	SHORT $LN12@GetModuleB
	xor	ecx, ecx

; 1488 :     else    

	jmp	SHORT $LN22@GetModuleB
$LN12@GetModuleB:

; 1489 :         ModuleInformation = (PRTL_PROCESS_MODULES) ExAllocatePoolWithTag(PagedPool,    NtQuery_BUFFERSIZE * sizeof(UCHAR), 'pmuD');

	mov	ecx, 1
$LN22@GetModuleB:
	call	QWORD PTR __imp_ExAllocatePoolWithTag

; 1490 : 
; 1491 :     RtlZeroMemory(ModuleInformation, NtQuery_BUFFERSIZE * sizeof(UCHAR));

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	mov	rbp, rax
	call	memset

; 1492 : 
; 1493 :     pUserProbeAddress = &MmUserProbeAddress;

	mov	rsi, QWORD PTR __imp_MmUserProbeAddress

; 1494 :     OldUserProbeAddress = *pUserProbeAddress;
; 1495 :     *pUserProbeAddress  = (ULONG_PTR)-1; // hack to allow NtQuerySystemInformation write
; 1496 :                                          // to Buffer allocated in kernel space > 0x7FFF0000
; 1497 :     Status = NtQuerySystemInformation(  SystemModuleInformation,
; 1498 :                                         ModuleInformation,
; 1499 :                                         NtQuery_BUFFERSIZE * sizeof(UCHAR),
; 1500 :                                         &ReturnLength );

	lea	r9, QWORD PTR ReturnLength$[rsp]
	mov	rdi, QWORD PTR [rsi]
	or	QWORD PTR [rsi], -1
	mov	r8d, ebx
	mov	rdx, rbp
	mov	ecx, 11
	call	NtQuerySystemInformation

; 1501 :     *pUserProbeAddress  = OldUserProbeAddress;
; 1502 : 
; 1503 :     if (Status != STATUS_SUCCESS) {

	xor	ebx, ebx
	mov	QWORD PTR [rsi], rdi
	cmp	eax, ebx
	jne	SHORT $LN4@GetModuleB

; 1505 :         return NULL;
; 1506 :     }
; 1507 : 
; 1508 :     Found = FALSE;
; 1509 :     for (ULONG Index = 0; Index < ModuleInformation->NumberOfModules; Index++)

	mov	r8d, ebx
	cmp	DWORD PTR [rbp], ebx
	jbe	SHORT $LN4@GetModuleB
	lea	rdx, QWORD PTR [rbp+8]
$LL9@GetModuleB:

; 1510 :     {
; 1511 :         ModuleInfo = &ModuleInformation->Modules[Index];
; 1512 :         FileName = (CHAR *)ModuleInfo->FullPathName + ModuleInfo->OffsetToFileName;

	movzx	eax, WORD PTR [rdx+38]

; 1513 : 
; 1514 :         if (ByOrderMode && Index == OrderNum) {
; 1515 :             Found = TRUE;
; 1516 :             break;
; 1517 :         }
; 1518 : 
; 1519 :         if (strcmp(FileName, Modulename) == 0) {

	lea	rdi, OFFSET FLAT:??_C@_0BC@MKBGMCGD@dump_diskdump?4sys?$AA@FNODOBFM@
	mov	ecx, 18
	lea	rsi, QWORD PTR [rax+rdx+40]
	repe cmpsb
	je	SHORT $LN19@GetModuleB
	inc	r8d
	add	rdx, 296				; 00000128H
	cmp	r8d, DWORD PTR [rbp]
	jb	SHORT $LL9@GetModuleB
	jmp	SHORT $LN4@GetModuleB
$LN19@GetModuleB:

; 1520 :             Found = TRUE;
; 1521 :             break;
; 1522 :         }
; 1523 :     }
; 1524 :     
; 1525 :     if (Found == TRUE) {
; 1526 :         FunctionAddress = ModuleInfo->ImageBase;

	mov	rbx, QWORD PTR [rdx+16]
$LN4@GetModuleB:

; 1504 :         ExFreePoolWithTag(ModuleInformation, 'pmuD');

	mov	edx, 1886221636				; 706d7544H
	mov	rcx, rbp
	call	QWORD PTR __imp_ExFreePoolWithTag

; 1527 :         if (ModuleSize) {
; 1528 :             *ModuleSize = ModuleInfo->ImageSize;
; 1529 :         }
; 1530 :     } else {
; 1531 :         FunctionAddress = NULL;
; 1532 :         if (ModuleSize) {
; 1533 :             *ModuleSize = 0;
; 1534 :         }
; 1535 :     }
; 1536 : 
; 1537 :     ExFreePoolWithTag(ModuleInformation, 'pmuD');
; 1538 :     return FunctionAddress;
; 1539 : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
GetModuleBaseAddress_k8 ENDP
_TEXT	ENDS
PUBLIC	RtlAddressInSectionTable_k8
; Function compile flags: /Ogspy
;	COMDAT RtlAddressInSectionTable_k8
_TEXT	SEGMENT
NtHeaders$ = 8
Base$ = 16
Address$ = 24
RtlAddressInSectionTable_k8 PROC			; COMDAT

; 737  :     PIMAGE_SECTION_HEADER NtSection;
; 738  : 
; 739  :     NtSection = RtlSectionTableFromVirtualAddress_k8( NtHeaders,
; 740  :                                                    Base,
; 741  :                                                    Address
; 742  :                                                  );

	movzx	eax, WORD PTR [rcx+20]
	movzx	r11d, WORD PTR [rcx+6]
	xor	r10d, r10d
	lea	r9, QWORD PTR [rax+rcx+24]
	test	r11d, r11d
	je	SHORT $LN14@RtlAddress
$LL8@RtlAddress:
	mov	ecx, DWORD PTR [r9+12]
	cmp	r8d, ecx
	jb	SHORT $LN5@RtlAddress
	add	ecx, DWORD PTR [r9+16]
	cmp	r8d, ecx
	jb	SHORT $LN9@RtlAddress
$LN5@RtlAddress:
	inc	r10d
	add	r9, 40					; 00000028H
	cmp	r10d, r11d
	jb	SHORT $LL8@RtlAddress
$LN14@RtlAddress:
	xor	r9d, r9d
$LN9@RtlAddress:

; 743  :     if (NtSection != NULL) {

	test	r9, r9
	je	SHORT $LN2@RtlAddress

; 744  :         return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );

	mov	eax, DWORD PTR [r9+12]
	mov	ecx, DWORD PTR [r9+20]
	sub	rcx, rax
	mov	eax, r8d
	add	rcx, rdx
	add	rax, rcx

; 748  :         }
; 749  : }

	ret	0
$LN2@RtlAddress:

; 745  :         }
; 746  :     else {
; 747  :         return( NULL );

	xor	eax, eax

; 748  :         }
; 749  : }

	ret	0
RtlAddressInSectionTable_k8 ENDP
_TEXT	ENDS
PUBLIC	RtlImageNtHeader_k8
; Function compile flags: /Ogspy
;	COMDAT RtlImageNtHeader_k8
_TEXT	SEGMENT
Base$ = 8
RtlImageNtHeader_k8 PROC				; COMDAT

; 699  :     PIMAGE_NT_HEADERS NtHeaders = NULL;
; 700  :     (VOID)RtlImageNtHeaderEx_k8(RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK, Base, 0, &NtHeaders);

	xor	edx, edx
	cmp	rcx, rdx
	je	SHORT $LN3@RtlImageNt@2
	cmp	rcx, -1
	je	SHORT $LN3@RtlImageNt@2
	mov	eax, 23117				; 00005a4dH
	cmp	WORD PTR [rcx], ax
	jne	SHORT $LN3@RtlImageNt@2
	mov	r8d, DWORD PTR [rcx+60]
	mov	rax, QWORD PTR __imp_MmHighestUserAddress
	add	r8, rcx
	cmp	rcx, QWORD PTR [rax]
	jae	SHORT $LN7@RtlImageNt@2
	cmp	r8, QWORD PTR [rax]
	jae	SHORT $LN3@RtlImageNt@2
	lea	rcx, QWORD PTR [r8+264]
	cmp	rcx, QWORD PTR [rax]
	jae	SHORT $LN3@RtlImageNt@2
$LN7@RtlImageNt@2:
	cmp	DWORD PTR [r8], 17744			; 00004550H
	cmove	rdx, r8
$LN3@RtlImageNt@2:

; 701  :     return NtHeaders;

	mov	rax, rdx

; 702  : }

	ret	0
RtlImageNtHeader_k8 ENDP
PUBLIC	RtlpImageDirectoryEntryToData64_k8
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlpImageDirectoryEntryToData64_k8 DD imagerel $LN10
	DD	imagerel $LN10+103
	DD	imagerel $unwind$RtlpImageDirectoryEntryToData64_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlpImageDirectoryEntryToData64_k8 DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RtlpImageDirectoryEntryToData64_k8
_TEXT	SEGMENT
Base$ = 48
MappedAsImage$ = 56
DirectoryEntry$ = 64
Size$ = 72
NtHeaders$ = 80
RtlpImageDirectoryEntryToData64_k8 PROC			; COMDAT

; 795  : {

$LN10:
	sub	rsp, 40					; 00000028H
	mov	r11b, dl
	mov	rdx, rcx

; 796  :     ULONG DirectoryAddress;
; 797  : 
; 798  :     if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {

	mov	rcx, QWORD PTR NtHeaders$[rsp]
	cmp	DWORD PTR [rcx+132], 0
	mov	r10, r9
	ja	SHORT $LN6@RtlpImageD
$LN9@RtlpImageD:

; 799  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN7@RtlpImageD
$LN6@RtlpImageD:

; 800  :     }
; 801  : 
; 802  :     if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {

	mov	r8d, DWORD PTR [rcx+136]
	test	r8d, r8d

; 803  :         return( NULL );

	je	SHORT $LN9@RtlpImageD

; 804  :     }
; 805  : 
; 806  :     if (Base < MM_HIGHEST_USER_ADDRESS) {

	mov	rax, QWORD PTR __imp_MmHighestUserAddress
	mov	r9, QWORD PTR [rax]
	cmp	rdx, r9
	jae	SHORT $LN3@RtlpImageD

; 807  :         if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {

	lea	rax, QWORD PTR [rdx+r8]
	cmp	rax, r9

; 808  :             return( NULL );

	jae	SHORT $LN9@RtlpImageD
$LN3@RtlpImageD:

; 809  :         }
; 810  :     }
; 811  : 
; 812  :     *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;

	mov	eax, DWORD PTR [rcx+140]
	mov	DWORD PTR [r10], eax

; 813  :     if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {

	test	r11b, r11b
	jne	SHORT $LN1@RtlpImageD
	cmp	r8d, DWORD PTR [rcx+84]
	jb	SHORT $LN1@RtlpImageD

; 815  :     }
; 816  : 
; 817  :     return( RtlAddressInSectionTable_k8((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));

	call	RtlAddressInSectionTable_k8
	jmp	SHORT $LN7@RtlpImageD
$LN1@RtlpImageD:

; 814  :         return( (PVOID)((PCHAR)Base + DirectoryAddress) );

	lea	rax, QWORD PTR [rdx+r8]
$LN7@RtlpImageD:

; 818  : }

	add	rsp, 40					; 00000028H
	ret	0
RtlpImageDirectoryEntryToData64_k8 ENDP
_TEXT	ENDS
PUBLIC	RtlpImageDirectoryEntryToData32_k8
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlpImageDirectoryEntryToData32_k8 DD imagerel $LN10
	DD	imagerel $LN10+94
	DD	imagerel $unwind$RtlpImageDirectoryEntryToData32_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlpImageDirectoryEntryToData32_k8 DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RtlpImageDirectoryEntryToData32_k8
_TEXT	SEGMENT
Base$ = 48
MappedAsImage$ = 56
DirectoryEntry$ = 64
Size$ = 72
NtHeaders$ = 80
RtlpImageDirectoryEntryToData32_k8 PROC			; COMDAT

; 761  : {

$LN10:
	sub	rsp, 40					; 00000028H
	mov	r11b, dl
	mov	rdx, rcx

; 762  :     ULONG DirectoryAddress;
; 763  : 
; 764  :     if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {

	mov	rcx, QWORD PTR NtHeaders$[rsp]
	cmp	DWORD PTR [rcx+116], 0
	mov	r10, r9
	ja	SHORT $LN6@RtlpImageD@2
$LN9@RtlpImageD@2:

; 765  :         return( NULL );

	xor	eax, eax
	jmp	SHORT $LN7@RtlpImageD@2
$LN6@RtlpImageD@2:

; 766  :     }
; 767  : 
; 768  :     if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {

	mov	r8d, DWORD PTR [rcx+120]
	test	r8d, r8d

; 769  :         return( NULL );

	je	SHORT $LN9@RtlpImageD@2

; 770  :     }
; 771  : 
; 772  :     if (Base < MM_HIGHEST_USER_ADDRESS) {

	mov	rax, QWORD PTR __imp_MmHighestUserAddress
	mov	r9, QWORD PTR [rax]
	cmp	rdx, r9
	jae	SHORT $LN3@RtlpImageD@2

; 773  :         if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {

	lea	rax, QWORD PTR [rdx+r8]
	cmp	rax, r9

; 774  :             return( NULL );

	jae	SHORT $LN9@RtlpImageD@2
$LN3@RtlpImageD@2:

; 775  :         }
; 776  :     }
; 777  : 
; 778  :     *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;

	mov	eax, DWORD PTR [rcx+124]
	mov	DWORD PTR [r10], eax

; 779  :     if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {

	test	r11b, r11b
	jne	SHORT $LN1@RtlpImageD@2
	cmp	r8d, DWORD PTR [rcx+84]
	jb	SHORT $LN1@RtlpImageD@2

; 781  :     }
; 782  : 
; 783  :     return( RtlAddressInSectionTable_k8((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));

	call	RtlAddressInSectionTable_k8
	jmp	SHORT $LN7@RtlpImageD@2
$LN1@RtlpImageD@2:

; 780  :         return( (PVOID)((PCHAR)Base + DirectoryAddress) );

	lea	rax, QWORD PTR [rdx+r8]
$LN7@RtlpImageD@2:

; 784  : }

	add	rsp, 40					; 00000028H
	ret	0
RtlpImageDirectoryEntryToData32_k8 ENDP
PUBLIC	RtlImageDirectoryEntryToData_k8
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlImageDirectoryEntryToData_k8 DD imagerel $LN58
	DD	imagerel $LN58+260
	DD	imagerel $unwind$RtlImageDirectoryEntryToData_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlImageDirectoryEntryToData_k8 DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT RtlImageDirectoryEntryToData_k8
_TEXT	SEGMENT
Base$ = 48
MappedAsImage$ = 56
DirectoryEntry$ = 64
Size$ = 72
RtlImageDirectoryEntryToData_k8 PROC			; COMDAT

; 828  : {

$LN58:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	r11b, 1

; 829  :     PIMAGE_NT_HEADERS NtHeaders;
; 830  : 
; 831  :     if (LDR_IS_DATAFILE(Base)) {

	xor	edx, edx
	mov	rbx, r9
	mov	r10, rcx
	test	cl, r11b
	je	SHORT $LN6@RtlImageDi

; 832  :         Base = LDR_DATAFILE_TO_VIEW(Base);

	and	r10, -2

; 833  :         MappedAsImage = FALSE;

	mov	r11b, dl
$LN6@RtlImageDi:

; 834  :         }
; 835  : 
; 836  :     NtHeaders = RtlImageNtHeader_k8(Base);

	cmp	r10, rdx
	je	$LN56@RtlImageDi
	cmp	r10, -1
	je	$LN56@RtlImageDi
	mov	eax, 23117				; 00005a4dH
	cmp	WORD PTR [r10], ax
	jne	$LN56@RtlImageDi
	mov	rax, QWORD PTR __imp_MmHighestUserAddress
	mov	ecx, DWORD PTR [r10+60]
	mov	r9, QWORD PTR [rax]
	add	rcx, r10
	cmp	r10, r9
	jae	SHORT $LN15@RtlImageDi
	cmp	rcx, r9
	jae	$LN56@RtlImageDi
	lea	rax, QWORD PTR [rcx+264]
	cmp	rax, r9
	jae	$LN56@RtlImageDi
$LN15@RtlImageDi:
	cmp	DWORD PTR [rcx], 17744			; 00004550H

; 837  : 
; 838  :     if (!NtHeaders)

	jne	$LN56@RtlImageDi

; 840  : 
; 841  :     if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {

	mov	eax, 267				; 0000010bH
	cmp	WORD PTR [rcx+24], ax
	jne	SHORT $LN4@RtlImageDi

; 842  :         return (RtlpImageDirectoryEntryToData32_k8(Base,
; 843  :                                                 MappedAsImage,
; 844  :                                                 DirectoryEntry,
; 845  :                                                 Size,
; 846  :                                                 (PIMAGE_NT_HEADERS32)NtHeaders));

	cmp	DWORD PTR [rcx+116], edx
	jbe	SHORT $LN44@RtlImageDi
	mov	r8d, DWORD PTR [rcx+120]
	cmp	r8d, edx
	je	SHORT $LN44@RtlImageDi
	cmp	r10, r9
	jae	SHORT $LN40@RtlImageDi
	lea	rax, QWORD PTR [r10+r8]
	cmp	rax, r9
	jae	SHORT $LN44@RtlImageDi
$LN40@RtlImageDi:
	mov	eax, DWORD PTR [rcx+124]
$LN57@RtlImageDi:
	mov	DWORD PTR [rbx], eax
	cmp	r11b, dl
	jne	SHORT $LN38@RtlImageDi
	cmp	r8d, DWORD PTR [rcx+84]
	jb	SHORT $LN38@RtlImageDi
	mov	rdx, r10
	call	RtlAddressInSectionTable_k8
	mov	rdx, rax
	jmp	SHORT $LN44@RtlImageDi
$LN38@RtlImageDi:
	lea	rdx, QWORD PTR [r10+r8]
$LN44@RtlImageDi:
	mov	rax, rdx
	jmp	SHORT $LN1@RtlImageDi
$LN4@RtlImageDi:

; 847  :     } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {

	mov	eax, 523				; 0000020bH
	cmp	WORD PTR [rcx+24], ax
	jne	SHORT $LN56@RtlImageDi

; 848  :         return (RtlpImageDirectoryEntryToData64_k8(Base,
; 849  :                                                 MappedAsImage,
; 850  :                                                 DirectoryEntry,
; 851  :                                                 Size,
; 852  :                                                 (PIMAGE_NT_HEADERS64)NtHeaders));

	cmp	DWORD PTR [rcx+132], edx
	jbe	SHORT $LN44@RtlImageDi
	mov	r8d, DWORD PTR [rcx+136]
	cmp	r8d, edx
	je	SHORT $LN44@RtlImageDi
	cmp	r10, r9
	jae	SHORT $LN48@RtlImageDi
	lea	rax, QWORD PTR [r10+r8]
	cmp	rax, r9
	jae	SHORT $LN44@RtlImageDi
$LN48@RtlImageDi:
	mov	eax, DWORD PTR [rcx+140]
	jmp	SHORT $LN57@RtlImageDi
$LN56@RtlImageDi:

; 839  :         return NULL;

	xor	eax, eax
$LN1@RtlImageDi:

; 853  :     } else {
; 854  :         return (NULL);
; 855  :     }
; 856  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
RtlImageDirectoryEntryToData_k8 ENDP
PUBLIC	MiFindExportedRoutineByName_k8
;	COMDAT pdata
pdata	SEGMENT
$pdata$MiFindExportedRoutineByName_k8 DD imagerel $LN77
	DD	imagerel $LN77+397
	DD	imagerel $unwind$MiFindExportedRoutineByName_k8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MiFindExportedRoutineByName_k8 DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT MiFindExportedRoutineByName_k8
_TEXT	SEGMENT
DllBase$ = 48
AnsiImageRoutineName$ = 56
MiFindExportedRoutineByName_k8 PROC			; COMDAT

; 865  : {

$LN77:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 866  :     USHORT OrdinalNumber;
; 867  :     PULONG NameTableBase;
; 868  :     PUSHORT NameOrdinalTableBase;
; 869  :     PULONG Addr;
; 870  :     LONG High;
; 871  :     LONG Low;
; 872  :     LONG Middle;
; 873  :     LONG Result;
; 874  :     ULONG ExportSize;
; 875  :     PVOID FunctionAddress;
; 876  :     PIMAGE_EXPORT_DIRECTORY ExportDirectory;
; 877  : 
; 878  :     ExportDirectory = (PIMAGE_EXPORT_DIRECTORY) RtlImageDirectoryEntryToData_k8 (
; 879  :                                 DllBase,
; 880  :                                 TRUE,
; 881  :                                 IMAGE_DIRECTORY_ENTRY_EXPORT,
; 882  :                                 &ExportSize);

	mov	r10b, 1
	mov	rbp, rdx
	mov	rbx, rcx
	mov	rdx, rcx
	test	cl, r10b
	je	SHORT $LN17@MiFindExpo
	and	rdx, -2
	xor	r10b, r10b
$LN17@MiFindExpo:
	test	rdx, rdx
	je	$LN69@MiFindExpo
	cmp	rdx, -1
	je	$LN69@MiFindExpo
	mov	eax, 23117				; 00005a4dH
	cmp	WORD PTR [rdx], ax
	jne	$LN69@MiFindExpo
	mov	rax, QWORD PTR __imp_MmHighestUserAddress
	mov	ecx, DWORD PTR [rdx+60]
	mov	r8, QWORD PTR [rax]
	add	rcx, rdx
	cmp	rdx, r8
	jae	SHORT $LN26@MiFindExpo
	cmp	rcx, r8
	jae	$LN69@MiFindExpo
	lea	rax, QWORD PTR [rcx+264]
	cmp	rax, r8
	jae	$LN69@MiFindExpo
$LN26@MiFindExpo:
	cmp	DWORD PTR [rcx], 17744			; 00004550H
	jne	$LN69@MiFindExpo
	mov	eax, 267				; 0000010bH
	cmp	WORD PTR [rcx+24], ax
	jne	SHORT $LN15@MiFindExpo
	cmp	DWORD PTR [rcx+116], 0
	jbe	SHORT $LN13@MiFindExpo
	mov	r9d, DWORD PTR [rcx+120]
$LN76@MiFindExpo:
	test	r9d, r9d
	je	SHORT $LN13@MiFindExpo
	cmp	rdx, r8
	jae	SHORT $LN51@MiFindExpo
	lea	rax, QWORD PTR [rdx+r9]
	cmp	rax, r8
	jae	SHORT $LN13@MiFindExpo
$LN51@MiFindExpo:
	test	r10b, r10b
	jne	SHORT $LN49@MiFindExpo
	cmp	r9d, DWORD PTR [rcx+84]
	jb	SHORT $LN49@MiFindExpo
	mov	r8d, r9d
	call	RtlAddressInSectionTable_k8
	mov	rcx, rax
	jmp	SHORT $LN12@MiFindExpo
$LN49@MiFindExpo:
	lea	rcx, QWORD PTR [rdx+r9]
	jmp	SHORT $LN12@MiFindExpo
$LN15@MiFindExpo:
	mov	eax, 523				; 0000020bH
	cmp	WORD PTR [rcx+24], ax
	jne	SHORT $LN13@MiFindExpo
	cmp	DWORD PTR [rcx+132], 0
	jbe	SHORT $LN13@MiFindExpo
	mov	r9d, DWORD PTR [rcx+136]
	jmp	SHORT $LN76@MiFindExpo
$LN13@MiFindExpo:
	xor	ecx, ecx
$LN12@MiFindExpo:

; 883  : 
; 884  :     if (ExportDirectory == NULL) {

	test	rcx, rcx
	je	$LN69@MiFindExpo

; 886  :     }
; 887  : 
; 888  :     //
; 889  :     // Initialize the pointer to the array of RVA-based ansi export strings.
; 890  :     //
; 891  : 
; 892  :     NameTableBase = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNames);

	mov	esi, DWORD PTR [rcx+32]

; 893  : 
; 894  :     //
; 895  :     // Initialize the pointer to the array of USHORT ordinal numbers.
; 896  :     //
; 897  : 
; 898  :     NameOrdinalTableBase = (PUSHORT)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNameOrdinals);

	mov	edi, DWORD PTR [rcx+36]

; 899  : 
; 900  :     //
; 901  :     // Lookup the desired namethe name table using a binary search.
; 902  :     //
; 903  : 
; 904  :     Low = 0;
; 905  :     Middle = 0;
; 906  :     High = ExportDirectory->NumberOfNames - 1;

	mov	edx, DWORD PTR [rcx+24]
	add	rsi, rbx
	add	rdi, rbx
	xor	r8d, r8d
	sub	edx, 1

; 907  : 
; 908  :     while (High >= Low) {

	js	SHORT $LN69@MiFindExpo
$LL8@MiFindExpo:

; 909  : 
; 910  :         //
; 911  :         // Compute the next probe index and compare the import name
; 912  :         // with the export name entry.
; 913  :         //
; 914  : 
; 915  :         Middle = (Low + High) >> 1;

	lea	r10d, DWORD PTR [rdx+r8]
	sar	r10d, 1

; 916  : 
; 917  :         Result = strcmp (AnsiImageRoutineName->Buffer,
; 918  :                          (PCHAR)DllBase + NameTableBase[Middle]);

	movsxd	rax, r10d
	mov	r11d, DWORD PTR [rsi+rax*4]
	mov	rax, QWORD PTR [rbp+8]
	add	r11, rbx
	sub	r11, rax
$LL71@MiFindExpo:
	mov	r9b, BYTE PTR [rax]
	cmp	r9b, BYTE PTR [rax+r11]
	jne	SHORT $LN73@MiFindExpo
	inc	rax
	test	r9b, r9b
	jne	SHORT $LL71@MiFindExpo
	xor	eax, eax
	jmp	SHORT $LN72@MiFindExpo
$LN73@MiFindExpo:
	sbb	eax, eax
	sbb	eax, -1
$LN72@MiFindExpo:

; 919  : 
; 920  :         if (Result < 0) {

	test	eax, eax
	jns	SHORT $LN75@MiFindExpo

; 921  :             High = Middle - 1;

	lea	edx, DWORD PTR [r10-1]
	jmp	SHORT $LN3@MiFindExpo
$LN75@MiFindExpo:

; 922  :         }
; 923  :         else if (Result > 0) {

	jle	SHORT $LN4@MiFindExpo

; 924  :             Low = Middle + 1;

	lea	r8d, DWORD PTR [r10+1]
$LN3@MiFindExpo:

; 907  : 
; 908  :     while (High >= Low) {

	cmp	edx, r8d
	jge	SHORT $LL8@MiFindExpo
$LN4@MiFindExpo:

; 925  :         }
; 926  :         else {
; 927  :             break;
; 928  :         }
; 929  :     }
; 930  : 
; 931  :     //
; 932  :     // If the high index is less than the low index, then a matching
; 933  :     // table entry was not found. Otherwise, get the ordinal number
; 934  :     // from the ordinal table.
; 935  :     //
; 936  : 
; 937  :     if (High < Low) {

	cmp	edx, r8d
	jl	SHORT $LN69@MiFindExpo

; 938  :         return NULL;
; 939  :     }
; 940  : 
; 941  :     OrdinalNumber = NameOrdinalTableBase[Middle];

	movsxd	rax, r10d
	movzx	edx, WORD PTR [rdi+rax*2]

; 942  : 
; 943  :     //
; 944  :     // If the OrdinalNumber is not within the Export Address Table,
; 945  :     // then this image does not implement the function.  Return not found.
; 946  :     //
; 947  : 
; 948  :     if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {

	cmp	edx, DWORD PTR [rcx+20]

; 949  :         return NULL;

	jae	SHORT $LN69@MiFindExpo

; 950  :     }
; 951  : 
; 952  :     //
; 953  :     // Index into the array of RVA export addresses by ordinal number.
; 954  :     //
; 955  : 
; 956  :     Addr = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);
; 957  : 
; 958  :     FunctionAddress = (PVOID)((PCHAR)DllBase + Addr[OrdinalNumber]);
; 959  : 
; 960  :     //
; 961  :     // Forwarders are not used by the kernel and HAL to each other.
; 962  :     //
; 963  : 
; 964  :     return FunctionAddress;

	mov	eax, DWORD PTR [rcx+28]
	movzx	edx, dx
	lea	rcx, QWORD PTR [rbx+rax]
	mov	eax, DWORD PTR [rcx+rdx*4]
	add	rax, rbx
	jmp	SHORT $LN10@MiFindExpo
$LN69@MiFindExpo:

; 885  :         return NULL;

	xor	eax, eax
$LN10@MiFindExpo:

; 965  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
MiFindExportedRoutineByName_k8 ENDP
END
